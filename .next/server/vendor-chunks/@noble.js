"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble";
exports.ids = ["vendor-chunks/@noble"];
exports.modules = {

/***/ "(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n/** connects noble-curves to noble-hashes */ function getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs)=>(0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({\n            ...curveDef,\n            ...getHash(hash)\n        });\n    return {\n        ...create(defHash),\n        create\n    };\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUMxQjtBQUNxQjtBQUNQO0FBQ3hELDBDQUEwQyxHQUNuQyxTQUFTSSxRQUFRQyxJQUFJO0lBQ3hCLE9BQU87UUFDSEE7UUFDQUwsTUFBTSxDQUFDTSxLQUFLLEdBQUdDLE9BQVNQLHdEQUFJQSxDQUFDSyxNQUFNQyxLQUFLTCxnRUFBV0EsSUFBSU07UUFDdkRMLFdBQVdBLDhEQUFBQTtJQUNmO0FBQ0o7QUFDTyxTQUFTTSxZQUFZQyxRQUFRLEVBQUVDLE9BQU87SUFDekMsTUFBTUMsU0FBUyxDQUFDTixPQUFTRixxRUFBV0EsQ0FBQztZQUFFLEdBQUdNLFFBQVE7WUFBRSxHQUFHTCxRQUFRQyxLQUFLO1FBQUM7SUFDckUsT0FBTztRQUFFLEdBQUdNLE9BQU9ELFFBQVE7UUFBRUM7SUFBTztBQUN4QyxFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbW11bmUtcGFnZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzP2YyNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIHNob3J0IHdlaWVyc3RyYXNzIGN1cnZlcywgY29tYmluZWQgd2l0aCBub2JsZS1oYXNoZXMuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCI7XG4vKiogY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4geyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOlsiaG1hYyIsImNvbmNhdEJ5dGVzIiwicmFuZG9tQnl0ZXMiLCJ3ZWllcnN0cmFzcyIsImdldEhhc2giLCJoYXNoIiwia2V5IiwibXNncyIsImNyZWF0ZUN1cnZlIiwiY3VydmVEZWYiLCJkZWZIYXNoIiwiY3JlYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return {\n        windows,\n        windowSize,\n        mask,\n        maxNumber,\n        shiftBy\n    };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return {\n        nextN,\n        offset,\n        isZero,\n        isNeg,\n        isNegF,\n        offsetF\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes (elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder (elm, n, p = c.ZERO) {\n            let d = elm;\n            while(n > _0n){\n                if (n & _1n) p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */ precomputeWindow (elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for(let window = 0; window < windows; window++){\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for(let i = 1; i < windowSize; i++){\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */ wNAF (W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for(let window = 0; window < wo.windows; window++){\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                } else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return {\n                p,\n                f\n            };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */ wNAFUnsafe (W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for(let window = 0; window < wo.windows; window++){\n                if (n === _0n) break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    continue;\n                } else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes (W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached (P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe (P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize (P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        }\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength) throw new Error(\"arrays of points and scalars must have equal length\");\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12) windowSize = wbits - 3;\n    else if (wbits > 4) windowSize = wbits - 2;\n    else if (wbits > 0) windowSize = 2;\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < slength; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(windowSize);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNELG9FQUFvRSxHQUNkO0FBQ087QUFDN0QsTUFBTUssTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLFNBQVNFLGdCQUFnQkMsU0FBUyxFQUFFQyxJQUFJO0lBQ3BDLE1BQU1DLE1BQU1ELEtBQUtFLE1BQU07SUFDdkIsT0FBT0gsWUFBWUUsTUFBTUQ7QUFDN0I7QUFDQSxTQUFTRyxVQUFVQyxDQUFDLEVBQUVDLElBQUk7SUFDdEIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNILE1BQU1BLEtBQUssS0FBS0EsSUFBSUMsTUFDMUMsTUFBTSxJQUFJRyxNQUFNLHVDQUF1Q0gsT0FBTyxjQUFjRDtBQUNwRjtBQUNBLFNBQVNLLFVBQVVMLENBQUMsRUFBRU0sVUFBVTtJQUM1QlAsVUFBVUMsR0FBR007SUFDYixNQUFNQyxVQUFVQyxLQUFLQyxJQUFJLENBQUNILGFBQWFOLEtBQUssR0FBRyx1Q0FBdUM7SUFDdEYsTUFBTVUsYUFBYSxLQUFNVixDQUFBQSxJQUFJLElBQUkseUNBQXlDO0lBQzFFLE1BQU1XLFlBQVksS0FBS1gsR0FBRyxVQUFVO0lBQ3BDLE1BQU1ZLE9BQU92QixrREFBT0EsQ0FBQ1csSUFBSSw2QkFBNkI7SUFDdEQsTUFBTWEsVUFBVXJCLE9BQU9RLElBQUksUUFBUTtJQUNuQyxPQUFPO1FBQUVPO1FBQVNHO1FBQVlFO1FBQU1EO1FBQVdFO0lBQVE7QUFDM0Q7QUFDQSxTQUFTQyxZQUFZQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsS0FBSztJQUNqQyxNQUFNLEVBQUVQLFVBQVUsRUFBRUUsSUFBSSxFQUFFRCxTQUFTLEVBQUVFLE9BQU8sRUFBRSxHQUFHSTtJQUNqRCxJQUFJQyxRQUFRaEIsT0FBT2EsSUFBSUgsT0FBTyxrQkFBa0I7SUFDaEQsSUFBSU8sUUFB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LENBQUNVLE9BQU8sRUFBRTtZQUNyQztRQUNKO1FBQ0EsT0FBT0Q7SUFDWDtBQUNKO0FBQ08sU0FBU0UsY0FBY0MsS0FBSztJQUMvQjlHLDBEQUFhQSxDQUFDOEcsTUFBTUMsRUFBRTtJQUN0QjVHLHlEQUFjQSxDQUFDMkcsT0FBTztRQUNsQmxGLEdBQUc7UUFDSG9GLEdBQUc7UUFDSEMsSUFBSTtRQUNKQyxJQUFJO0lBQ1IsR0FBRztRQUNDQyxZQUFZO1FBQ1pDLGFBQWE7SUFDakI7SUFDQSxlQUFlO0lBQ2YsT0FBT0MsT0FBT0MsTUFBTSxDQUFDO1FBQ2pCLEdBQUd2SCxvREFBT0EsQ0FBQytHLE1BQU1sRixDQUFDLEVBQUVrRixNQUFNSyxVQUFVLENBQUM7UUFDckMsR0FBR0wsS0FBSztRQUNSLEdBQUc7WUFBRWhFLEdBQUdnRSxNQUFNQyxFQUFFLENBQUNRLEtBQUs7UUFBQyxDQUFDO0lBQzVCO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21tdW5lLXBhZ2UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanM/NjFkOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1ldGhvZHMgZm9yIGVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIGJ5IHNjYWxhcnMuXG4gKiBDb250YWlucyB3TkFGLCBwaXBwZW5nZXJcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgbkxlbmd0aCwgdmFsaWRhdGVGaWVsZCB9IGZyb20gXCIuL21vZHVsYXIuanNcIjtcbmltcG9ydCB7IGJpdExlbiwgYml0TWFzaywgdmFsaWRhdGVPYmplY3QgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gY29uc3RUaW1lTmVnYXRlKGNvbmRpdGlvbiwgaXRlbSkge1xuICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVcoVywgYml0cykge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoVykgfHwgVyA8PSAwIHx8IFcgPiBiaXRzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgd2luZG93IHNpemUsIGV4cGVjdGVkIFsxLi4nICsgYml0cyArICddLCBnb3QgVz0nICsgVyk7XG59XG5mdW5jdGlvbiBjYWxjV09wdHMoVywgc2NhbGFyQml0cykge1xuICAgIHZhbGlkYXRlVyhXLCBzY2FsYXJCaXRzKTtcbiAgICBjb25zdCB3aW5kb3dzID0gTWF0aC5jZWlsKHNjYWxhckJpdHMgLyBXKSArIDE7IC8vIFc9OCAzMy4gTm90IDMyLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7IC8vIFc9OCAxMjguIE5vdCAyNTYsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXOyAvLyBXPTggMjU2XG4gICAgY29uc3QgbWFzayA9IGJpdE1hc2soVyk7IC8vIFc9OCAyNTUgPT0gbWFzayAwYjExMTExMTExXG4gICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTsgLy8gVz04IDhcbiAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplLCBtYXNrLCBtYXhOdW1iZXIsIHNoaWZ0QnkgfTtcbn1cbmZ1bmN0aW9uIGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd09wdHMpIHtcbiAgICBjb25zdCB7IHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9ID0gd09wdHM7XG4gICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTsgLy8gZXh0cmFjdCBXIGJpdHMuXG4gICAgbGV0IG5leHROID0gbiA+PiBzaGlmdEJ5OyAvLyBzaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgIC8vIFdoYXQgYWN0dWFsbHkgaGFwcGVucyBoZXJlOlxuICAgIC8vIGNvbnN0IGhpZ2hlc3RCaXQgPSBOdW1iZXIobWFzayBeIChtYXNrID4+IDFuKSk7XG4gICAgLy8gbGV0IHdiaXRzMiA9IHdiaXRzIC0gMTsgLy8gc2tpcCB6ZXJvXG4gICAgLy8gaWYgKHdiaXRzMiAmIGhpZ2hlc3RCaXQpIHsgd2JpdHMyIF49IE51bWJlcihtYXNrKTsgLy8gKH4pO1xuICAgIC8vIHNwbGl0IGlmIGJpdHMgPiBtYXg6ICsyMjQgPT4gMjU2LTMyXG4gICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAvLyB3ZSBza2lwIHplcm8sIHdoaWNoIG1lYW5zIGluc3RlYWQgb2YgYD49IHNpemUtMWAsIHdlIGRvIGA+IHNpemVgXG4gICAgICAgIHdiaXRzIC09IG1heE51bWJlcjsgLy8gLTMyLCBjYW4gYmUgbWF4TnVtYmVyIC0gd2JpdHMsIGJ1dCB0aGVuIHdlIG5lZWQgdG8gc2V0IGlzTmVnIGhlcmUuXG4gICAgICAgIG5leHROICs9IF8xbjsgLy8gKzI1NiAoY2FycnkpXG4gICAgfVxuICAgIGNvbnN0IG9mZnNldFN0YXJ0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICBjb25zdCBvZmZzZXQgPSBvZmZzZXRTdGFydCArIE1hdGguYWJzKHdiaXRzKSAtIDE7IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3QgaXNaZXJvID0gd2JpdHMgPT09IDA7IC8vIGlzIGN1cnJlbnQgd2luZG93IHNsaWNlIGEgMD9cbiAgICBjb25zdCBpc05lZyA9IHdiaXRzIDwgMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgbmVnYXRpdmU/XG4gICAgY29uc3QgaXNOZWdGID0gd2luZG93ICUgMiAhPT0gMDsgLy8gZmFrZSByYW5kb20gc3RhdGVtZW50IGZvciBub2lzZVxuICAgIGNvbnN0IG9mZnNldEYgPSBvZmZzZXRTdGFydDsgLy8gZmFrZSBvZmZzZXQgZm9yIG5vaXNlXG4gICAgcmV0dXJuIHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZywgaXNOZWdGLCBvZmZzZXRGIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBleHBlY3RlZCcpO1xuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCBhdCBpbmRleCAnICsgaSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBleHBlY3RlZCcpO1xuICAgIHNjYWxhcnMuZm9yRWFjaCgocywgaSkgPT4ge1xuICAgICAgICBpZiAoIWZpZWxkLmlzVmFsaWQocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyIGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbi8vIFNpbmNlIHBvaW50cyBpbiBkaWZmZXJlbnQgZ3JvdXBzIGNhbm5vdCBiZSBlcXVhbCAoZGlmZmVyZW50IG9iamVjdCBjb25zdHJ1Y3RvciksXG4vLyB3ZSBjYW4gaGF2ZSBzaW5nbGUgcGxhY2UgdG8gc3RvcmUgcHJlY29tcHV0ZXMuXG4vLyBBbGxvd3MgdG8gbWFrZSBwb2ludHMgZnJvemVuIC8gaW1tdXRhYmxlLlxuY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwb2ludFdpbmRvd1NpemVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldFcoUCkge1xuICAgIHJldHVybiBwb2ludFdpbmRvd1NpemVzLmdldChQKSB8fCAxO1xufVxuLyoqXG4gKiBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4gKiBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbiAqIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuICogLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4gKiAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4gKiAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4gKiAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbiAqIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbiAqIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4gKlxuICogQHRvZG8gUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LlxuICogVGhpcyB3b3VsZCBhbGxvdyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIGhhc1ByZWNvbXB1dGVzKGVsbSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFcoZWxtKSAhPT0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4sIHAgPSBjLlpFUk8pIHtcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHBhcmFtIGVsbSBQb2ludCBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyBpPTEsIGJjIHdlIHNraXAgMFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBTbWFsbGVyIHZlcnNpb246XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLXNlY3AyNTZrMS9ibG9iLzQ3Y2IxNjY5YjZlNTA2YWQ2NmIzNWZlN2Q3NjEzMmFlOTc0NjVkYTIvaW5kZXgudHMjTDUwMi1MNTQxXG4gICAgICAgICAgICAvLyBUT0RPOiBjaGVjayB0aGUgc2NhbGFyIGlzIGxlc3MgdGhhbiBncm91cCBvcmRlcj9cbiAgICAgICAgICAgIC8vIHdOQUYgYmVoYXZpb3IgaXMgdW5kZWZpbmVkIG90aGVyd2lzZS4gQnV0IGhhdmUgdG8gY2FyZWZ1bGx5IHJlbW92ZVxuICAgICAgICAgICAgLy8gb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmUuXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRvcnNcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIGJpdHMpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICAvLyAobiA9PT0gXzBuKSBpcyBoYW5kbGVkIGFuZCBub3QgZWFybHktZXhpdGVkLiBpc0V2ZW4gYW5kIG9mZnNldEYgYXJlIHVzZWQgZm9yIG5vaXNlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfSA9IGNhbGNPZmZzZXRzKG4sIHdpbmRvdywgd28pO1xuICAgICAgICAgICAgICAgIG4gPSBuZXh0TjtcbiAgICAgICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgYXJlIDA6IGFkZCBnYXJiYWdlIHRvIGZha2UgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gSW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5OiBhZGQgcmFuZG9tIFwibm9pc2VcIiBwb2ludCB0byBmLlxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGlzTmVnRiwgcHJlY29tcHV0ZXNbb2Zmc2V0Rl0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgYXJlIDE6IGFkZCB0byByZXN1bHQgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShpc05lZywgcHJlY29tcHV0ZXNbb2Zmc2V0XSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybiBib3RoIHJlYWwgYW5kIGZha2UgcG9pbnRzOiBKSVQgd29uJ3QgZWxpbWluYXRlIGYuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyB1bnNhZmUgKG5vbiBjb25zdC10aW1lKSBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEBwYXJhbSBhY2MgYWNjdW11bGF0b3IgcG9pbnQgdG8gYWRkIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgd05BRlVuc2FmZShXLCBwcmVjb21wdXRlcywgbiwgYWNjID0gYy5aRVJPKSB7XG4gICAgICAgICAgICBjb25zdCB3byA9IGNhbGNXT3B0cyhXLCBiaXRzKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdvLndpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIEVhcmx5LWV4aXQsIHNraXAgMCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmV4dE4sIG9mZnNldCwgaXNaZXJvLCBpc05lZyB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICAgICAgICAgICAgbiA9IG5leHROO1xuICAgICAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93IGJpdHMgYXJlIDA6IHNraXAgcHJvY2Vzc2luZy5cbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gcHJlY29tcHV0ZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjID0gYWNjLmFkZChpc05lZyA/IGl0ZW0ubmVnYXRlKCkgOiBpdGVtKTsgLy8gUmUtdXNpbmcgYWNjIGFsbG93cyB0byBzYXZlIGFkZHMgaW4gTVNNXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcG9pbnRQcmVjb21wdXRlcy5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKVxuICAgICAgICAgICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBXID0gZ2V0VyhQKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZFVuc2FmZShQLCBuLCB0cmFuc2Zvcm0sIHByZXYpIHtcbiAgICAgICAgICAgIGNvbnN0IFcgPSBnZXRXKFApO1xuICAgICAgICAgICAgaWYgKFcgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zYWZlTGFkZGVyKFAsIG4sIHByZXYpOyAvLyBGb3IgVz0xIGxhZGRlciBpcyB+eDIgZmFzdGVyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGVW5zYWZlKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSwgbiwgcHJldik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgICAgICAgLy8gdXNpbmcgd2luZG93ZWQgbWV0aG9kLiBUaGlzIHNwZWNpZmllcyB3aW5kb3cgc2l6ZSBhbmRcbiAgICAgICAgLy8gc3RvcmVzIHByZWNvbXB1dGVkIHZhbHVlcy4gVXN1YWxseSBvbmx5IGJhc2UgcG9pbnQgd291bGQgYmUgcHJlY29tcHV0ZWQuXG4gICAgICAgIHNldFdpbmRvd1NpemUoUCwgVykge1xuICAgICAgICAgICAgdmFsaWRhdGVXKFcsIGJpdHMpO1xuICAgICAgICAgICAgcG9pbnRXaW5kb3dTaXplcy5zZXQoUCwgVyk7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZShQKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQaXBwZW5nZXIgYWxnb3JpdGhtIGZvciBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIDMweCBmYXN0ZXIgdnMgbmFpdmUgYWRkaXRpb24gb24gTD00MDk2LCAxMHggZmFzdGVyIHRoYW4gcHJlY29tcHV0ZXMuXG4gKiBGb3IgTj0yNTRiaXQsIEw9MSwgaXQgZG9lczogMTAyNCBBREQgKyAyNTQgREJMLiBGb3IgTD01OiAxNTM2IEFERCArIDI1NCBEQkwuXG4gKiBBbGdvcml0aG1pY2FsbHkgY29uc3RhbnQtdGltZSAoZm9yIHNhbWUgTCksIGV2ZW4gd2hlbiAxIHBvaW50ICsgc2NhbGFyLCBvciB3aGVuIHNjYWxhciA9IDAuXG4gKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZpZWxkTiBmaWVsZCBvdmVyIENVUlZFLk4gLSBpbXBvcnRhbnQgdGhhdCBpdCdzIG5vdCBvdmVyIENVUlZFLlBcbiAqIEBwYXJhbSBwb2ludHMgYXJyYXkgb2YgTCBjdXJ2ZSBwb2ludHNcbiAqIEBwYXJhbSBzY2FsYXJzIGFycmF5IG9mIEwgc2NhbGFycyAoYWthIHByaXZhdGUga2V5cyAvIGJpZ2ludHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaXBwZW5nZXIoYywgZmllbGROLCBwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAvLyBJZiB3ZSBzcGxpdCBzY2FsYXJzIGJ5IHNvbWUgd2luZG93IChsZXQncyBzYXkgOCBiaXRzKSwgZXZlcnkgY2h1bmsgd2lsbCBvbmx5XG4gICAgLy8gdGFrZSAyNTYgYnVja2V0cyBldmVuIGlmIHRoZXJlIGFyZSA0MDk2IHNjYWxhcnMsIGFsc28gcmUtdXNlcyBkb3VibGUuXG4gICAgLy8gVE9ETzpcbiAgICAvLyAtIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjQvNzUwLnBkZlxuICAgIC8vIC0gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzEwMjg3XG4gICAgLy8gMCBpcyBhY2NlcHRlZCBpbiBzY2FsYXJzXG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICBjb25zdCBwbGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBzbGVuZ3RoID0gc2NhbGFycy5sZW5ndGg7XG4gICAgaWYgKHBsZW5ndGggIT09IHNsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXlzIG9mIHBvaW50cyBhbmQgc2NhbGFycyBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoJyk7XG4gICAgLy8gaWYgKHBsZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcignYXJyYXkgbXVzdCBiZSBvZiBsZW5ndGggPj0gMicpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3Qgd2JpdHMgPSBiaXRMZW4oQmlnSW50KHBsZW5ndGgpKTtcbiAgICBsZXQgd2luZG93U2l6ZSA9IDE7IC8vIGJpdHNcbiAgICBpZiAod2JpdHMgPiAxMilcbiAgICAgICAgd2luZG93U2l6ZSA9IHdiaXRzIC0gMztcbiAgICBlbHNlIGlmICh3Yml0cyA+IDQpXG4gICAgICAgIHdpbmRvd1NpemUgPSB3Yml0cyAtIDI7XG4gICAgZWxzZSBpZiAod2JpdHMgPiAwKVxuICAgICAgICB3aW5kb3dTaXplID0gMjtcbiAgICBjb25zdCBNQVNLID0gYml0TWFzayh3aW5kb3dTaXplKTtcbiAgICBjb25zdCBidWNrZXRzID0gbmV3IEFycmF5KE51bWJlcihNQVNLKSArIDEpLmZpbGwoemVybyk7IC8vICsxIGZvciB6ZXJvIGFycmF5XG4gICAgY29uc3QgbGFzdEJpdHMgPSBNYXRoLmZsb29yKChmaWVsZE4uQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICAgIGxldCBzdW0gPSB6ZXJvO1xuICAgIGZvciAobGV0IGkgPSBsYXN0Qml0czsgaSA+PSAwOyBpIC09IHdpbmRvd1NpemUpIHtcbiAgICAgICAgYnVja2V0cy5maWxsKHplcm8pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHdiaXRzID0gTnVtYmVyKChzY2FsYXIgPj4gQmlnSW50KGkpKSAmIE1BU0spO1xuICAgICAgICAgICAgYnVja2V0c1t3Yml0c10gPSBidWNrZXRzW3diaXRzXS5hZGQocG9pbnRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzSSA9IHplcm87IC8vIG5vdCB1c2luZyB0aGlzIHdpbGwgZG8gc21hbGwgc3BlZWQtdXAsIGJ1dCB3aWxsIGxvc2UgY3RcbiAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gemVybzsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgc3VtSSA9IHN1bUkuYWRkKGJ1Y2tldHNbal0pO1xuICAgICAgICAgICAgcmVzSSA9IHJlc0kuYWRkKHN1bUkpO1xuICAgICAgICB9XG4gICAgICAgIHN1bSA9IHN1bS5hZGQocmVzSSk7XG4gICAgICAgIGlmIChpICE9PSAwKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgc3VtID0gc3VtLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBQcmVjb21wdXRlZCBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGROIGZpZWxkIG92ZXIgQ1VSVkUuTiAtIGltcG9ydGFudCB0aGF0IGl0J3Mgbm90IG92ZXIgQ1VSVkUuUFxuICogQHBhcmFtIHBvaW50cyBhcnJheSBvZiBMIGN1cnZlIHBvaW50c1xuICogQHJldHVybnMgZnVuY3Rpb24gd2hpY2ggbXVsdGlwbGllcyBwb2ludHMgd2l0aCBzY2FhcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZWNvbXB1dGVNU01VbnNhZmUoYywgZmllbGROLCBwb2ludHMsIHdpbmRvd1NpemUpIHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtYW5jZSBBbmFseXNpcyBvZiBXaW5kb3ctYmFzZWQgUHJlY29tcHV0YXRpb25cbiAgICAgKlxuICAgICAqIEJhc2UgQ2FzZSAoMjU2LWJpdCBzY2FsYXIsIDgtYml0IHdpbmRvdyk6XG4gICAgICogLSBTdGFuZGFyZCBwcmVjb21wdXRhdGlvbiByZXF1aXJlczpcbiAgICAgKiAgIC0gMzEgYWRkaXRpb25zIHBlciBzY2FsYXIgw5cgMjU2IHNjYWxhcnMgPSA3LDkzNiBvcHNcbiAgICAgKiAgIC0gUGx1cyAyNTUgc3VtbWFyeSBhZGRpdGlvbnMgPSA4LDE5MSB0b3RhbCBvcHNcbiAgICAgKiAgIE5vdGU6IFN1bW1hcnkgYWRkaXRpb25zIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGFjY3VtdWxhdG9yXG4gICAgICpcbiAgICAgKiBDaHVua2VkIFByZWNvbXB1dGF0aW9uIEFuYWx5c2lzOlxuICAgICAqIC0gVXNpbmcgMzIgY2h1bmtzIHJlcXVpcmVzOlxuICAgICAqICAgLSAyNTUgYWRkaXRpb25zIHBlciBjaHVua1xuICAgICAqICAgLSAyNTYgZG91YmxpbmdzXG4gICAgICogICAtIFRvdGFsOiAoMjU1IMOXIDMyKSArIDI1NiA9IDgsNDE2IG9wc1xuICAgICAqXG4gICAgICogTWVtb3J5IFVzYWdlIENvbXBhcmlzb246XG4gICAgICogV2luZG93IFNpemUgfCBTdGFuZGFyZCBQb2ludHMgfCBDaHVua2VkIFBvaW50c1xuICAgICAqIC0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgICAgNC1iaXQgICB8ICAgICA1MjAgICAgICAgICB8ICAgICAgMTVcbiAgICAgKiAgICAgOC1iaXQgICB8ICAgIDQsMjI0ICAgICAgICB8ICAgICAyNTVcbiAgICAgKiAgICAxMC1iaXQgICB8ICAgMTMsODI0ICAgICAgICB8ICAgMSwwMjNcbiAgICAgKiAgICAxNi1iaXQgICB8ICA1NTcsMDU2ICAgICAgICB8ICA2NSw1MzVcbiAgICAgKlxuICAgICAqIEtleSBBZHZhbnRhZ2VzOlxuICAgICAqIDEuIEVuYWJsZXMgbGFyZ2VyIHdpbmRvdyBzaXplcyBkdWUgdG8gcmVkdWNlZCBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgKiAyLiBNb3JlIGVmZmljaWVudCBmb3Igc21hbGxlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgIC0gMTYgY2h1bmtzOiAoMTYgw5cgMjU1KSArIDI1NiA9IDQsMzM2IG9wc1xuICAgICAqICAgIC0gfjJ4IGZhc3RlciB0aGFuIHN0YW5kYXJkIDgsMTkxIG9wc1xuICAgICAqXG4gICAgICogTGltaXRhdGlvbnM6XG4gICAgICogLSBOb3Qgc3VpdGFibGUgZm9yIHBsYWluIHByZWNvbXB1dGVzIChyZXF1aXJlcyAyNTYgY29uc3RhbnQgZG91YmxpbmdzKVxuICAgICAqIC0gUGVyZm9ybWFuY2UgZGVncmFkZXMgd2l0aCBsYXJnZXIgc2NhbGFyIGNvdW50czpcbiAgICAgKiAgIC0gT3B0aW1hbCBmb3IgfjI1NiBzY2FsYXJzXG4gICAgICogICAtIExlc3MgZWZmaWNpZW50IGZvciA0MDk2KyBzY2FsYXJzIChQaXBwZW5nZXIgcHJlZmVycmVkKVxuICAgICAqL1xuICAgIHZhbGlkYXRlVyh3aW5kb3dTaXplLCBmaWVsZE4uQklUUyk7XG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICBjb25zdCB6ZXJvID0gYy5aRVJPO1xuICAgIGNvbnN0IHRhYmxlU2l6ZSA9IDIgKiogd2luZG93U2l6ZSAtIDE7IC8vIHRhYmxlIHNpemUgKHdpdGhvdXQgemVybylcbiAgICBjb25zdCBjaHVua3MgPSBNYXRoLmNlaWwoZmllbGROLkJJVFMgLyB3aW5kb3dTaXplKTsgLy8gY2h1bmtzIG9mIGl0ZW1cbiAgICBjb25zdCBNQVNLID0gYml0TWFzayh3aW5kb3dTaXplKTtcbiAgICBjb25zdCB0YWJsZXMgPSBwb2ludHMubWFwKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYWNjID0gcDsgaSA8IHRhYmxlU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICByZXMucHVzaChhY2MpO1xuICAgICAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiAoc2NhbGFycykgPT4ge1xuICAgICAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICAgICAgaWYgKHNjYWxhcnMubGVuZ3RoID4gcG9pbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBtdXN0IGJlIHNtYWxsZXIgdGhhbiBhcnJheSBvZiBwb2ludHMnKTtcbiAgICAgICAgbGV0IHJlcyA9IHplcm87XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZG91YmxlIGlmIGFjY3VtdWxhdG9yIGlzIHN0aWxsIHplcm8uXG4gICAgICAgICAgICBpZiAocmVzICE9PSB6ZXJvKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2luZG93U2l6ZTsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuZG91YmxlKCk7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KGNodW5rcyAqIHdpbmRvd1NpemUgLSAoaSArIDEpICogd2luZG93U2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyID0gTnVtYmVyKChuID4+IHNoaWZ0QnkpICYgTUFTSyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB6ZXJvIHNjYWxhcnMgY2h1bmtzXG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmFkZCh0YWJsZXNbal1bY3VyciAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6WyJuTGVuZ3RoIiwidmFsaWRhdGVGaWVsZCIsImJpdExlbiIsImJpdE1hc2siLCJ2YWxpZGF0ZU9iamVjdCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsImNvbnN0VGltZU5lZ2F0ZSIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJ2YWxpZGF0ZVciLCJXIiwiYml0cyIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJFcnJvciIsImNhbGNXT3B0cyIsInNjYWxhckJpdHMiLCJ3aW5kb3dzIiwiTWF0aCIsImNlaWwiLCJ3aW5kb3dTaXplIiwibWF4TnVtYmVyIiwibWFzayIsInNoaWZ0QnkiLCJjYWxjT2Zmc2V0cyIsIm4iLCJ3aW5kb3ciLCJ3T3B0cyIsIndiaXRzIiwibmV4dE4iLCJvZmZzZXRTdGFydCIsIm9mZnNldCIsImFicyIsImlzWmVybyIsImlzTmVnIiwiaXNOZWdGIiwib2Zmc2V0RiIsInZhbGlkYXRlTVNNUG9pbnRzIiwicG9pbnRzIiwiYyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJwIiwiaSIsInZhbGlkYXRlTVNNU2NhbGFycyIsInNjYWxhcnMiLCJmaWVsZCIsInMiLCJpc1ZhbGlkIiwicG9pbnRQcmVjb21wdXRlcyIsIldlYWtNYXAiLCJwb2ludFdpbmRvd1NpemVzIiwiZ2V0VyIsIlAiLCJnZXQiLCJ3TkFGIiwiaGFzUHJlY29tcHV0ZXMiLCJlbG0iLCJ1bnNhZmVMYWRkZXIiLCJaRVJPIiwiZCIsImFkZCIsImRvdWJsZSIsInByZWNvbXB1dGVXaW5kb3ciLCJiYXNlIiwicHVzaCIsInByZWNvbXB1dGVzIiwiZiIsIkJBU0UiLCJ3byIsIndOQUZVbnNhZmUiLCJhY2MiLCJnZXRQcmVjb21wdXRlcyIsInRyYW5zZm9ybSIsImNvbXAiLCJzZXQiLCJ3TkFGQ2FjaGVkIiwid05BRkNhY2hlZFVuc2FmZSIsInByZXYiLCJzZXRXaW5kb3dTaXplIiwiZGVsZXRlIiwicGlwcGVuZ2VyIiwiZmllbGROIiwicGxlbmd0aCIsImxlbmd0aCIsInNsZW5ndGgiLCJ6ZXJvIiwiTUFTSyIsImJ1Y2tldHMiLCJmaWxsIiwibGFzdEJpdHMiLCJmbG9vciIsIkJJVFMiLCJzdW0iLCJqIiwic2NhbGFyIiwicmVzSSIsInN1bUkiLCJwcmVjb21wdXRlTVNNVW5zYWZlIiwidGFibGVTaXplIiwiY2h1bmtzIiwidGFibGVzIiwibWFwIiwicmVzIiwiY3VyciIsInZhbGlkYXRlQmFzaWMiLCJjdXJ2ZSIsIkZwIiwiaCIsIkd4IiwiR3kiLCJuQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJPYmplY3QiLCJmcmVlemUiLCJPUkRFUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.FpInvertBatch)(field, [\n            xd,\n            yd\n        ], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */ function createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve (msg, options) {\n            const u = hash_to_field(msg, 2, {\n                ...defaults,\n                DST: defaults.DST,\n                ...options\n            });\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve (msg, options) {\n            const u = hash_to_field(msg, 1, {\n                ...defaults,\n                DST: defaults.encodeDST,\n                ...options\n            });\n            return clear(map(u[0]));\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"expected array of bigints\");\n            return clear(map(scalars));\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWtEO0FBQzZDO0FBQy9GLDZGQUE2RjtBQUM3RixNQUFNTyxRQUFRSixzREFBZUE7QUFDN0IsNENBQTRDO0FBQzVDLFNBQVNLLE1BQU1DLEtBQUssRUFBRUMsTUFBTTtJQUN4QkMsS0FBS0Y7SUFDTEUsS0FBS0Q7SUFDTCxJQUFJRCxRQUFRLEtBQUtBLFNBQVMsS0FBTSxJQUFJQyxRQUNoQyxNQUFNLElBQUlFLE1BQU0sMEJBQTBCSDtJQUM5QyxNQUFNSSxNQUFNQyxNQUFNQyxJQUFJLENBQUM7UUFBRUw7SUFBTyxHQUFHTSxJQUFJLENBQUM7SUFDeEMsSUFBSyxJQUFJQyxJQUFJUCxTQUFTLEdBQUdPLEtBQUssR0FBR0EsSUFBSztRQUNsQ0osR0FBRyxDQUFDSSxFQUFFLEdBQUdSLFFBQVE7UUFDakJBLFdBQVc7SUFDZjtJQUNBLE9BQU8sSUFBSVMsV0FBV0w7QUFDMUI7QUFDQSxTQUFTTSxPQUFPQyxDQUFDLEVBQUVDLENBQUM7SUFDaEIsTUFBTUMsTUFBTSxJQUFJSixXQUFXRSxFQUFFVixNQUFNO0lBQ25DLElBQUssSUFBSU8sSUFBSSxHQUFHQSxJQUFJRyxFQUFFVixNQUFNLEVBQUVPLElBQUs7UUFDL0JLLEdBQUcsQ0FBQ0wsRUFBRSxHQUFHRyxDQUFDLENBQUNILEVBQUUsR0FBR0ksQ0FBQyxDQUFDSixFQUFFO0lBQ3hCO0lBQ0EsT0FBT0s7QUFDWDtBQUNBLFNBQVNYLEtBQUtZLElBQUk7SUFDZCxJQUFJLENBQUNDLE9BQU9DLGFBQWEsQ0FBQ0YsT0FDdEIsTUFBTSxJQUFJWCxNQUFNO0FBQ3hCO0FBQ0E7OztDQUdDLEdBQ00sU0FBU2MsbUJBQW1CQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsVUFBVSxFQUFFQyxDQUFDO0lBQ3RENUIsaURBQU1BLENBQUN5QjtJQUNQekIsaURBQU1BLENBQUMw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QUUsR0FBR2dFLFFBQVE7Z0JBQUUvRCxLQUFLK0QsU0FBUy9ELEdBQUc7Z0JBQUUsR0FBR3lCLE9BQU87WUFBQztZQUM3RSxNQUFNaUQsS0FBSzlCLElBQUlSLENBQUMsQ0FBQyxFQUFFO1lBQ25CLE1BQU11QyxLQUFLL0IsSUFBSVIsQ0FBQyxDQUFDLEVBQUU7WUFDbkIsT0FBTzhCLE1BQU1RLEdBQUdsQixHQUFHLENBQUNtQjtRQUN4QjtRQUNBLHlDQUF5QztRQUN6Qyx3RUFBd0U7UUFDeEVDLGVBQWM3RSxHQUFHLEVBQUUwQixPQUFPO1lBQ3RCLE1BQU1XLElBQUliLGNBQWN4QixLQUFLLEdBQUc7Z0JBQUUsR0FBR2dFLFFBQVE7Z0JBQUUvRCxLQUFLK0QsU0FBU2MsU0FBUztnQkFBRSxHQUFHcEQsT0FBTztZQUFDO1lBQ25GLE9BQU95QyxNQUFNdEIsSUFBSVIsQ0FBQyxDQUFDLEVBQUU7UUFDekI7UUFDQSwwQ0FBMEM7UUFDMUMwQixZQUFXZ0IsT0FBTztZQUNkLElBQUksQ0FBQzVGLE1BQU02RixPQUFPLENBQUNELFVBQ2YsTUFBTSxJQUFJOUYsTUFBTTtZQUNwQixLQUFLLE1BQU1LLEtBQUt5RixRQUNaLElBQUksT0FBT3pGLE1BQU0sVUFDYixNQUFNLElBQUlMLE1BQU07WUFDeEIsT0FBT2tGLE1BQU10QixJQUFJa0M7UUFDckI7SUFDSjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tbXVuZS1wYWdlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanM/MjBkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGcEludmVydEJhdGNoLCBtb2QgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG5pbXBvcnQgeyBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIHV0ZjhUb0J5dGVzLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGFudW0odmFsdWUpO1xuICAgIGFudW0obGVuZ3RoKTtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSTJPU1AgaW5wdXQ6ICcgKyB2YWx1ZSk7XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLyoqXG4gKiBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzLlxuICogW1JGQyA5MzgwIDUuMy4xXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFieXRlcyhEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4gKiAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbiAqIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4gKiAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbiAqIFtSRkMgOTM4MCA1LjMuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEYuXG4gKiBbUkZDIDkzODAgNS4yXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMikuXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKF9EU1QpIDogX0RTVDtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBjb2VmZiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3huLCB4ZCwgeW4sIHlkXSA9IGNvZWZmLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgLy8gNi42LjNcbiAgICAgICAgLy8gRXhjZXB0aW9uYWwgY2FzZXMgb2YgaXNvX21hcCBhcmUgaW5wdXRzIHRoYXQgY2F1c2UgdGhlIGRlbm9taW5hdG9yIG9mXG4gICAgICAgIC8vIGVpdGhlciByYXRpb25hbCBmdW5jdGlvbiB0byBldmFsdWF0ZSB0byB6ZXJvOyBzdWNoIGNhc2VzIE1VU1QgcmV0dXJuXG4gICAgICAgIC8vIHRoZSBpZGVudGl0eSBwb2ludCBvbiBFLlxuICAgICAgICBjb25zdCBbeGRfaW52LCB5ZF9pbnZdID0gRnBJbnZlcnRCYXRjaChmaWVsZCwgW3hkLCB5ZF0sIHRydWUpO1xuICAgICAgICB4ID0gZmllbGQubXVsKHhuLCB4ZF9pbnYpOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLm11bCh5biwgeWRfaW52KSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLyoqIENyZWF0ZXMgaGFzaC10by1jdXJ2ZSBtZXRob2RzIGZyb20gRUMgUG9pbnQgYW5kIG1hcFRvQ3VydmUgZnVuY3Rpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgZnVuY3Rpb24gbWFwKG51bSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKG51bSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhcihpbml0aWFsKSB7XG4gICAgICAgIGNvbnN0IFAgPSBpbml0aWFsLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgaWYgKFAuZXF1YWxzKFBvaW50LlpFUk8pKVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87IC8vIHplcm8gd2lsbCB0aHJvdyBpbiBhc3NlcnRcbiAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmYXVsdHMsIERTVDogZGVmYXVsdHMuRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgY29uc3QgdTAgPSBtYXAodVswXSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IG1hcCh1WzFdKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcih1MC5hZGQodTEpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmYXVsdHMsIERTVDogZGVmYXVsdHMuZW5jb2RlRFNULCAuLi5vcHRpb25zIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKG1hcCh1WzBdKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFNhbWUgYXMgZW5jb2RlVG9DdXJ2ZSwgYnV0IHdpdGhvdXQgaGFzaFxuICAgICAgICBtYXBUb0N1cnZlKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBzY2FsYXJzKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKG1hcChzY2FsYXJzKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIl0sIm5hbWVzIjpbIkZwSW52ZXJ0QmF0Y2giLCJtb2QiLCJhYnl0ZXMiLCJieXRlc1RvTnVtYmVyQkUiLCJjb25jYXRCeXRlcyIsInV0ZjhUb0J5dGVzIiwidmFsaWRhdGVPYmplY3QiLCJvczJpcCIsImkyb3NwIiwidmFsdWUiLCJsZW5ndGgiLCJhbnVtIiwiRXJyb3IiLCJyZXMiLCJBcnJheSIsImZyb20iLCJmaWxsIiwiaSIsIlVpbnQ4QXJyYXkiLCJzdHJ4b3IiLCJhIiwiYiIsImFyciIsIml0ZW0iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiZXhwYW5kX21lc3NhZ2VfeG1kIiwibXNnIiwiRFNUIiwibGVuSW5CeXRlcyIsIkgiLCJvdXRwdXRMZW4iLCJiX2luX2J5dGVzIiwiYmxvY2tMZW4iLCJyX2luX2J5dGVzIiwiZWxsIiwiTWF0aCIsImNlaWwiLCJEU1RfcHJpbWUiLCJaX3BhZCIsImxfaV9iX3N0ciIsImJfMCIsImFyZ3MiLCJwc2V1ZG9fcmFuZG9tX2J5dGVzIiwic2xpY2UiLCJleHBhbmRfbWVzc2FnZV94b2YiLCJrIiwiZGtMZW4iLCJjcmVhdGUiLCJ1cGRhdGUiLCJkaWdlc3QiLCJoYXNoX3RvX2ZpZWxkIiwiY291bnQiLCJvcHRpb25zIiwicCIsIm0iLCJoYXNoIiwiZXhwYW5kIiwiX0RTVCIsImxvZzJwIiwidG9TdHJpbmciLCJMIiwibGVuX2luX2J5dGVzIiwicHJiIiwidSIsImUiLCJqIiwiZWxtX29mZnNldCIsInR2Iiwic3ViYXJyYXkiLCJpc29nZW55TWFwIiwiZmllbGQiLCJtYXAiLCJjb2VmZiIsInJldmVyc2UiLCJ4IiwieSIsInhuIiwieGQiLCJ5biIsInlkIiwidmFsIiwicmVkdWNlIiwiYWNjIiwiYWRkIiwibXVsIiwieGRfaW52IiwieWRfaW52IiwiY3JlYXRlSGFzaGVyIiwiUG9pbnQiLCJtYXBUb0N1cnZlIiwiZGVmYXVsdHMiLCJudW0iLCJmcm9tQWZmaW5lIiwiY2xlYXIiLCJpbml0aWFsIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJlcXVhbHMiLCJaRVJPIiwiYXNzZXJ0VmFsaWRpdHkiLCJoYXNoVG9DdXJ2ZSIsInUwIiwidTEiLCJlbmNvZGVUb0N1cnZlIiwiZW5jb2RlRFNUIiwic2NhbGFycyIsImlzQXJyYXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    // Throw if root^2 != n\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n    return root;\n}\n// TODO: Commented-out for now. Provide test vectors.\n// Tonelli is too slow for extension fields Fp2.\n// That means we can't use sqrt (c1, c2...) even for initialization constants.\n// if (P % _16n === _9n) return sqrt9mod16;\n// // prettier-ignore\n// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {\n//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;\n//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic\n//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4\n//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1\n//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1\n//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1\n//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x\n//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x\n//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x\n//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2\n// }\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Initialization (precomputation).\n    if (P < BigInt(3)) throw new Error(\"sqrt is not defined for small field\");\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while(Q % _2n === _0n){\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while(FpLegendre(_Fp, Z) === 1){\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000) throw new Error(\"Cannot find square root: probably non-prime P\");\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1) return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n)) return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1) throw new Error(\"Cannot find square root\");\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while(!Fp.eql(t, Fp.ONE)){\n            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ‚â° 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while(!Fp.eql(t_tmp, Fp.ONE)){\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M) throw new Error(\"Cannot find square root\");\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ‚â° 3 (mod 4)\n * 2. P ‚â° 5 (mod 8)\n * 3. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P ‚â° 3 (mod 4) => ‚àön = n^((P+1)/4)\n    if (P % _4n === _3n) return sqrt3mod4;\n    // P ‚â° 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n) return sqrt5mod8;\n    // P ‚â° 9 (mod 16) not implemented, see above\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(Fp, num, power) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return Fp.ONE;\n    if (power === _1n) return num;\n    let p = Fp.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */ function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ‚â° 1    if a is a square (mod p), quadratic residue\n * * (a | p) ‚â° -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ‚â° 0    if a ‚â° 0 (mod p)\n */ function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no) throw new Error(\"invalid Legendre symbol result\");\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined) (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: redef.sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes)=>{\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c)=>c ? b : a\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ0Qsb0VBQW9FLEdBQ3RCO0FBQ3lGO0FBQ3ZJLGtCQUFrQjtBQUNsQixNQUFNUSxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTSxhQUFhLEdBQUdGLE9BQU8sSUFBSUcsTUFBTSxhQUFhLEdBQUdILE9BQU87QUFDdEcsa0JBQWtCO0FBQ2xCLE1BQU1JLE1BQU0sYUFBYSxHQUFHSixPQUFPLElBQUlLLE1BQU0sYUFBYSxHQUFHTCxPQUFPLElBQUlNLE1BQU0sYUFBYSxHQUFHTixPQUFPO0FBQ3JHLHdCQUF3QjtBQUNqQixTQUFTTyxJQUFJQyxDQUFDLEVBQUVDLENBQUM7SUFDcEIsTUFBTUMsU0FBU0YsSUFBSUM7SUFDbkIsT0FBT0MsVUFBVVgsTUFBTVcsU0FBU0QsSUFBSUM7QUFDeEM7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTQyxJQUFJQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUNsQyxPQUFPQyxNQUFNQyxNQUFNRixTQUFTRixLQUFLQztBQUNyQztBQUNBLDBEQUEwRCxHQUNuRCxTQUFTSSxLQUFLQyxDQUFDLEVBQUVMLEtBQUssRUFBRUMsTUFBTTtJQUNqQyxJQUFJSyxNQUFNRDtJQUNWLE1BQU9MLFVBQVVkLElBQUs7UUFDbEJvQixPQUFPQTtRQUNQQSxPQUFPTDtJQUNYO0lBQ0EsT0FBT0s7QUFDWDtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNDLE9BQU9DLE1BQU0sRUFBRVAsTUFBTTtJQUNqQyxJQUFJTyxXQUFXdEIsS0FDWCxNQUFNLElBQUl1QixNQUFNO0lBQ3BCLElBQUlSLFVBQVVmLEtBQ1YsTUFBTSxJQUFJdUIsTUFBTSw0Q0FBNENSO0lBQ2hFLGtGQUFrRjtJQUNsRixJQUFJTixJQUFJRCxJQUFJYyxRQUFRUDtJ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Q0FBQytJLFFBQVFoSiwwREFBZUEsQ0FBQ2dKO0lBQzNELE9BQU9sSSxJQUFJSyxLQUFLOEgsYUFBYXpJLE9BQU9BO0FBQ3hDO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTNEksb0JBQW9CQyxVQUFVO0lBQzFDLElBQUksT0FBT0EsZUFBZSxVQUN0QixNQUFNLElBQUl4SCxNQUFNO0lBQ3BCLE1BQU15SCxZQUFZRCxXQUFXcEMsUUFBUSxDQUFDLEdBQUd0QixNQUFNO0lBQy9DLE9BQU93QixLQUFLQyxJQUFJLENBQUNrQyxZQUFZO0FBQ2pDO0FBQ0E7Ozs7OztDQU1DLEdBQ00sU0FBU0MsaUJBQWlCRixVQUFVO0lBQ3ZDLE1BQU0xRCxTQUFTeUQsb0JBQW9CQztJQUNuQyxPQUFPMUQsU0FBU3dCLEtBQUtDLElBQUksQ0FBQ3pCLFNBQVM7QUFDdkM7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTNkQsZUFBZUMsR0FBRyxFQUFFSixVQUFVLEVBQUUvQixPQUFPLEtBQUs7SUFDeEQsTUFBTW9DLE1BQU1ELElBQUk5RCxNQUFNO0lBQ3RCLE1BQU1nRSxXQUFXUCxvQkFBb0JDO0lBQ3JDLE1BQU1GLFNBQVNJLGlCQUFpQkY7SUFDaEMsaUdBQWlHO0lBQ2pHLElBQUlLLE1BQU0sTUFBTUEsTUFBTVAsVUFBVU8sTUFBTSxNQUNsQyxNQUFNLElBQUk3SCxNQUFNLGNBQWNzSCxTQUFTLCtCQUErQk87SUFDMUUsTUFBTXZJLE1BQU1tRyxPQUFPckgsMERBQWVBLENBQUN3SixPQUFPekosMERBQWVBLENBQUN5SjtJQUMxRCwrRUFBK0U7SUFDL0UsTUFBTUcsVUFBVTlJLElBQUlLLEtBQUtrSSxhQUFhN0ksT0FBT0E7SUFDN0MsT0FBTzhHLE9BQU9sSCwwREFBZUEsQ0FBQ3dKLFNBQVNELFlBQVl4SiwwREFBZUEsQ0FBQ3lKLFNBQVNEO0FBQ2hGLEVBQ0EsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tbXVuZS1wYWdlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM/MGNhOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxzIGZvciBtb2R1bGFyIGRpdmlzaW9uIGFuZCBmaW5pdGUgZmllbGRzLlxuICogQSBmaW5pdGUgZmllbGQgb3ZlciAxMSBpcyBpbnRlZ2VyIG51bWJlciBvcGVyYXRpb25zIGBtb2QgMTFgLlxuICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgYW51bWJlciB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgYml0TWFzaywgYnl0ZXNUb051bWJlckJFLCBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvQnl0ZXNMRSwgdmFsaWRhdGVPYmplY3QsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiksIF8zbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNCksIF81biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNSksIF84biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOCk7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogVE9ETzogcmVtb3ZlLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgcmV0dXJuIEZwUG93KEZpZWxkKG1vZHVsbyksIG51bSwgcG93ZXIpO1xufVxuLyoqIERvZXMgYHheKDJecG93ZXIpYCBtb2QgcC4gYHBvdzIoMzAsIDQpYCA9PSBgMzBeKDJeNClgICovXG5leHBvcnQgZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvLlxuICogSW1wbGVtZW50ZWQgdXNpbmcgW0V1Y2xpZGVhbiBHQ0RdKGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmVydChudW1iZXIsIG1vZHVsbykge1xuICAgIGlmIChudW1iZXIgPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIG5vbi16ZXJvIG51bWJlcicpO1xuICAgIGlmIChtb2R1bG8gPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgcG9zaXRpdmUgbW9kdWx1cywgZ290ICcgKyBtb2R1bG8pO1xuICAgIC8vIEZlcm1hdCdzIGxpdHRsZSB0aGVvcmVtIFwiQ1QtbGlrZVwiIHZlcnNpb24gaW52KG4pID0gbl4obS0yKSBtb2QgbSBpcyAzMHggc2xvd2VyLlxuICAgIGxldCBhID0gbW9kKG51bWJlciwgbW9kdWxvKTtcbiAgICBsZXQgYiA9IG1vZHVsbztcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgeCA9IF8wbiwgeSA9IF8xbiwgdSA9IF8xbiwgdiA9IF8wbjtcbiAgICB3aGlsZSAoYSAhPT0gXzBuKSB7XG4gICAgICAgIC8vIEpJVCBhcHBsaWVzIG9wdGltaXphdGlvbiBpZiB0aG9zZSB0d28gbGluZXMgZm9sbG93IGVhY2ggb3RoZXJcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBiID0gYSwgYSA9IHIsIHggPSB1LCB5ID0gdiwgdSA9IG0sIHYgPSBuO1xuICAgIH1cbiAgICBjb25zdCBnY2QgPSBiO1xuICAgIGlmIChnY2QgIT09IF8xbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgcmV0dXJuIG1vZCh4LCBtb2R1bG8pO1xufVxuLy8gTm90IGFsbCByb290cyBhcmUgcG9zc2libGUhIEV4YW1wbGUgd2hpY2ggd2lsbCB0aHJvdzpcbi8vIGNvbnN0IE5VTSA9XG4vLyBuID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuLy8gRnAgPSBGaWVsZChCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiJykpO1xuZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgY29uc3QgcDFkaXY0ID0gKEZwLk9SREVSICsgXzFuKSAvIF80bjtcbiAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgLy8gVGhyb3cgaWYgcm9vdF4yICE9IG5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5mdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICBjb25zdCBwNWRpdjggPSAoRnAuT1JERVIgLSBfNW4pIC8gXzhuO1xuICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgcDVkaXY4KTtcbiAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbi8vIFRPRE86IENvbW1lbnRlZC1vdXQgZm9yIG5vdy4gUHJvdmlkZSB0ZXN0IHZlY3RvcnMuXG4vLyBUb25lbGxpIGlzIHRvbyBzbG93IGZvciBleHRlbnNpb24gZmllbGRzIEZwMi5cbi8vIFRoYXQgbWVhbnMgd2UgY2FuJ3QgdXNlIHNxcnQgKGMxLCBjMi4uLikgZXZlbiBmb3IgaW5pdGlhbGl6YXRpb24gY29uc3RhbnRzLlxuLy8gaWYgKFAgJSBfMTZuID09PSBfOW4pIHJldHVybiBzcXJ0OW1vZDE2O1xuLy8gLy8gcHJldHRpZXItaWdub3JlXG4vLyBmdW5jdGlvbiBzcXJ0OW1vZDE2PFQ+KEZwOiBJRmllbGQ8VD4sIG46IFQsIHA3ZGl2MTY/OiBiaWdpbnQpIHtcbi8vICAgaWYgKHA3ZGl2MTYgPT09IHVuZGVmaW5lZCkgcDdkaXYxNiA9IChGcC5PUkRFUiArIEJpZ0ludCg3KSkgLyBfMTZuO1xuLy8gICBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuLy8gICBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuLy8gICBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4vLyAgIGNvbnN0IGM0ID0gcDdkaXYxNjsgICAgICAgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbi8vICAgbGV0IHR2MSA9IEZwLnBvdyhuLCBjNCk7ICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbi8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4vLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbi8vICAgY29uc3QgZTEgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuLy8gICBjb25zdCBlMiA9IEZwLmVxbChGcC5zcXIodHYzKSwgbik7ICAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4vLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbi8vICAgY29uc3QgZTMgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuLy8gfVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gSW5pdGlhbGl6YXRpb24gKHByZWNvbXB1dGF0aW9uKS5cbiAgICBpZiAoUCA8IEJpZ0ludCgzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcXJ0IGlzIG5vdCBkZWZpbmVkIGZvciBzbWFsbCBmaWVsZCcpO1xuICAgIC8vIEZhY3RvciBQIC0gMSA9IFEgKiAyXlMsIHdoZXJlIFEgaXMgb2RkXG4gICAgbGV0IFEgPSBQIC0gXzFuO1xuICAgIGxldCBTID0gMDtcbiAgICB3aGlsZSAoUSAlIF8ybiA9PT0gXzBuKSB7XG4gICAgICAgIFEgLz0gXzJuO1xuICAgICAgICBTKys7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IHF1YWRyYXRpYyBub24tcmVzaWR1ZSBaID49IDJcbiAgICBsZXQgWiA9IF8ybjtcbiAgICBjb25zdCBfRnAgPSBGaWVsZChQKTtcbiAgICB3aGlsZSAoRnBMZWdlbmRyZShfRnAsIFopID09PSAxKSB7XG4gICAgICAgIC8vIEJhc2ljIHByaW1hbGl0eSB0ZXN0IGZvciBQLiBBZnRlciB4IGl0ZXJhdGlvbnMsIGNoYW5jZSBvZlxuICAgICAgICAvLyBub3QgZmluZGluZyBxdWFkcmF0aWMgbm9uLXJlc2lkdWUgaXMgMl54LCBzbyAyXjEwMDAuXG4gICAgICAgIGlmIChaKysgPiAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdDogcHJvYmFibHkgbm9uLXByaW1lIFAnKTtcbiAgICB9XG4gICAgLy8gRmFzdC1wYXRoOyB1c3VhbGx5IGRvbmUgYmVmb3JlIFosIGJ1dCB3ZSBkbyBcInByaW1hbGl0eSB0ZXN0XCIuXG4gICAgaWYgKFMgPT09IDEpXG4gICAgICAgIHJldHVybiBzcXJ0M21vZDQ7XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgLy8gVE9ETzogdGVzdCBvbiBGcDIgYW5kIG90aGVyc1xuICAgIGxldCBjYyA9IF9GcC5wb3coWiwgUSk7IC8vIGMgPSB6XlFcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIGlmIChGcC5pczAobikpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgLy8gQ2hlY2sgaWYgbiBpcyBhIHF1YWRyYXRpYyByZXNpZHVlIHVzaW5nIExlZ2VuZHJlIHN5bWJvbFxuICAgICAgICBpZiAoRnBMZWdlbmRyZShGcCwgbikgIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdmFyaWFibGVzIGZvciB0aGUgbWFpbiBsb29wXG4gICAgICAgIGxldCBNID0gUztcbiAgICAgICAgbGV0IGMgPSBGcC5tdWwoRnAuT05FLCBjYyk7IC8vIGMgPSB6XlEsIG1vdmUgY2MgZnJvbSBmaWVsZCBfRnAgaW50byBmaWVsZCBGcFxuICAgICAgICBsZXQgdCA9IEZwLnBvdyhuLCBRKTsgLy8gdCA9IG5eUSwgZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICBsZXQgUiA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBSID0gbl4oKFErMSkvMiksIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICAvLyBNYWluIGxvb3BcbiAgICAgICAgLy8gd2hpbGUgdCAhPSAxXG4gICAgICAgIHdoaWxlICghRnAuZXFsKHQsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5pczAodCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGlmIHQ9MCByZXR1cm4gUj0wXG4gICAgICAgICAgICBsZXQgaSA9IDE7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBzbWFsbGVzdCBpID49IDEgc3VjaCB0aGF0IHReKDJeaSkg4omhIDEgKG1vZCBQKVxuICAgICAgICAgICAgbGV0IHRfdG1wID0gRnAuc3FyKHQpOyAvLyB0XigyXjEpXG4gICAgICAgICAgICB3aGlsZSAoIUZwLmVxbCh0X3RtcCwgRnAuT05FKSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB0X3RtcCA9IEZwLnNxcih0X3RtcCk7IC8vIHReKDJeMikuLi5cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gTSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBleHBvbmVudCBmb3IgYjogMl4oTSAtIGkgLSAxKVxuICAgICAgICAgICAgY29uc3QgZXhwb25lbnQgPSBfMW4gPDwgQmlnSW50KE0gLSBpIC0gMSk7IC8vIGJpZ2ludCBpcyBpbXBvcnRhbnRcbiAgICAgICAgICAgIGNvbnN0IGIgPSBGcC5wb3coYywgZXhwb25lbnQpOyAvLyBiID0gMl4oTSAtIGkgLSAxKVxuICAgICAgICAgICAgLy8gVXBkYXRlIHZhcmlhYmxlc1xuICAgICAgICAgICAgTSA9IGk7XG4gICAgICAgICAgICBjID0gRnAuc3FyKGIpOyAvLyBjID0gYl4yXG4gICAgICAgICAgICB0ID0gRnAubXVsKHQsIGMpOyAvLyB0ID0gKHQgKiBiXjIpXG4gICAgICAgICAgICBSID0gRnAubXVsKFIsIGIpOyAvLyBSID0gUipiXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFI7XG4gICAgfTtcbn1cbi8qKlxuICogU3F1YXJlIHJvb3QgZm9yIGEgZmluaXRlIGZpZWxkLiBXaWxsIHRyeSBvcHRpbWl6ZWQgdmVyc2lvbnMgZmlyc3Q6XG4gKlxuICogMS4gUCDiiaEgMyAobW9kIDQpXG4gKiAyLiBQIOKJoSA1IChtb2QgOClcbiAqIDMuIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICpcbiAqIERpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAqIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBQIOKJoSAzIChtb2QgNCkgPT4g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbilcbiAgICAgICAgcmV0dXJuIHNxcnQzbW9kNDtcbiAgICAvLyBQIOKJoSA1IChtb2QgOCkgPT4gQXRraW4gYWxnb3JpdGhtLCBwYWdlIDEwIG9mIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZlxuICAgIGlmIChQICUgXzhuID09PSBfNW4pXG4gICAgICAgIHJldHVybiBzcXJ0NW1vZDg7XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KSBub3QgaW1wbGVtZW50ZWQsIHNlZSBhYm92ZVxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhGcCwgbnVtLCBwb3dlcikge1xuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGV4cG9uZW50LCBuZWdhdGl2ZXMgdW5zdXBwb3J0ZWQnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIEZwLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IEZwLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IEZwLm11bChwLCBkKTtcbiAgICAgICAgZCA9IEZwLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIEV4Y2VwdGlvbi1mcmVlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3IgMCBlbGVtZW50cy5cbiAqIEBwYXJhbSBwYXNzWmVybyBtYXAgMCB0byAwIChpbnN0ZWFkIG9mIHVuZGVmaW5lZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goRnAsIG51bXMsIHBhc3NaZXJvID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnZlcnRlZCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCkuZmlsbChwYXNzWmVybyA/IEZwLlpFUk8gOiB1bmRlZmluZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBtdWx0aXBsaWVkQWNjID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChGcC5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGludmVydGVkW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gRnAubXVsKGFjYywgbnVtKTtcbiAgICB9LCBGcC5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZEFjYyA9IEZwLmludihtdWx0aXBsaWVkQWNjKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKEZwLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgaW52ZXJ0ZWRbaV0gPSBGcC5tdWwoYWNjLCBpbnZlcnRlZFtpXSk7XG4gICAgICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkQWNjKTtcbiAgICByZXR1cm4gaW52ZXJ0ZWQ7XG59XG4vLyBUT0RPOiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBGcERpdihGcCwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gRnAubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBGcC5PUkRFUikgOiBGcC5pbnYocmhzKSk7XG59XG4vKipcbiAqIExlZ2VuZHJlIHN5bWJvbC5cbiAqIExlZ2VuZHJlIGNvbnN0YW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApXG4gKiB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICpcbiAqICogKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcExlZ2VuZHJlKEZwLCBuKSB7XG4gICAgLy8gV2UgY2FuIHVzZSAzcmQgYXJndW1lbnQgYXMgb3B0aW9uYWwgY2FjaGUgb2YgdGhpcyB2YWx1ZVxuICAgIC8vIGJ1dCBzZWVtcyB1bm5lZWRlZCBmb3Igbm93LiBUaGUgb3BlcmF0aW9uIGlzIHZlcnkgZmFzdC5cbiAgICBjb25zdCBwMW1vZDIgPSAoRnAuT1JERVIgLSBfMW4pIC8gXzJuO1xuICAgIGNvbnN0IHBvd2VyZWQgPSBGcC5wb3cobiwgcDFtb2QyKTtcbiAgICBjb25zdCB5ZXMgPSBGcC5lcWwocG93ZXJlZCwgRnAuT05FKTtcbiAgICBjb25zdCB6ZXJvID0gRnAuZXFsKHBvd2VyZWQsIEZwLlpFUk8pO1xuICAgIGNvbnN0IG5vID0gRnAuZXFsKHBvd2VyZWQsIEZwLm5lZyhGcC5PTkUpKTtcbiAgICBpZiAoIXllcyAmJiAhemVybyAmJiAhbm8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBMZWdlbmRyZSBzeW1ib2wgcmVzdWx0Jyk7XG4gICAgcmV0dXJuIHllcyA/IDEgOiB6ZXJvID8gMCA6IC0xO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShGcCwgbikge1xuICAgIGNvbnN0IGwgPSBGcExlZ2VuZHJlKEZwLCBuKTtcbiAgICByZXR1cm4gbCA9PT0gMTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGlmIChuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFudW1iZXIobkJpdExlbmd0aCk7XG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIEZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBTZWN1cml0eSBub3RlOiBvcGVyYXRpb25zIGRvbid0IGNoZWNrICdpc1ZhbGlkJyBmb3IgYWxsIGVsZW1lbnRzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICogaXQgaXMgY2FsbGVyIHJlc3BvbnNpYmlsaXR5IHRvIGNoZWNrIHRoaXMuXG4gKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiBvZiA8PSAyMDQ4IGJ5dGVzJyk7XG4gICAgbGV0IHNxcnRQOyAvLyBjYWNoZWQgc3FydFBcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBpc0xFLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJyArIHR5cGVvZiBudW0pO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8XG4gICAgICAgICAgICAoKG4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNxcnRQKVxuICAgICAgICAgICAgICAgICAgICBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNxcnRQKGYsIG4pO1xuICAgICAgICAgICAgfSksXG4gICAgICAgIHRvQnl0ZXM6IChudW0pID0+IChpc0xFID8gbnVtYmVyVG9CeXRlc0xFKG51bSwgQllURVMpIDogbnVtYmVyVG9CeXRlc0JFKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgQllURVMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBUT0RPOiB3ZSBkb24ndCBuZWVkIGl0IGhlcmUsIG1vdmUgb3V0IHRvIHNlcGFyYXRlIGZuXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFdlIGNhbid0IG1vdmUgdGhpcyBvdXQgYmVjYXVzZSBGcDYsIEZwMTIgaW1wbGVtZW50IGl0XG4gICAgICAgIC8vIGFuZCBpdCdzIHVuY2xlYXIgd2hhdCB0byByZXR1cm4gaW4gdGhlcmUuXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRPZGQoRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkXCIpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBgbWFwS2V5VG9GaWVsZGAgaW5zdGVhZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgaGFzaExlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShoYXNoKSA6IGJ5dGVzVG9OdW1iZXJCRShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBpZiAodHlwZW9mIGZpZWxkT3JkZXIgIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkIG9yZGVyIG11c3QgYmUgYmlnaW50Jyk7XG4gICAgY29uc3QgYml0TGVuZ3RoID0gZmllbGRPcmRlci50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGguY2VpbChiaXRMZW5ndGggLyA4KTtcbn1cbi8qKlxuICogUmV0dXJucyBtaW5pbWFsIGFtb3VudCBvZiBieXRlcyB0aGF0IGNhbiBiZSBzYWZlbHkgcmVkdWNlZFxuICogYnkgZmllbGQgb3JkZXIuXG4gKiBTaG91bGQgYmUgMl4tMTI4IGZvciAxMjgtYml0IGN1cnZlIHN1Y2ggYXMgUDI1Ni5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiB0YXJnZXQgaGFzaFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICByZXR1cm4gbGVuZ3RoICsgTWF0aC5jZWlsKGxlbmd0aCAvIDIpO1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobiArIG4vMikgb3IgbW9yZSBieXRlcyBvZiB1bmlmb3JtIGlucHV0IGUuZy4gZnJvbSBDU1BSTkcgb3IgS0RGXG4gKiBhbmQgY29udmVydCB0aGVtIGludG8gcHJpdmF0ZSBzY2FsYXIsIHdpdGggdGhlIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gKiBOZWVkcyBhdCBsZWFzdCA0OCBieXRlcyBvZiBpbnB1dCBmb3IgMzItYnl0ZSBwcml2YXRlIGtleS5cbiAqIGh0dHBzOi8vcmVzZWFyY2gua3VkZWxza2lzZWN1cml0eS5jb20vMjAyMC8wNy8yOC90aGUtZGVmaW5pdGl2ZS1ndWlkZS10by1tb2R1bG8tYmlhcy1hbmQtaG93LXRvLWF2b2lkLWl0L1xuICogRklQUyAxODYtNSwgQS4yIGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9wdWJsaWNhdGlvbnMvZGV0YWlsL2ZpcHMvMTg2LzUvZmluYWxcbiAqIFJGQyA5MzgwLCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTVcbiAqIEBwYXJhbSBoYXNoIGhhc2ggb3V0cHV0IGZyb20gU0hBMyBvciBhIHNpbWlsYXIgZnVuY3Rpb25cbiAqIEBwYXJhbSBncm91cE9yZGVyIHNpemUgb2Ygc3ViZ3JvdXAgLSAoZS5nLiBzZWNwMjU2azEuQ1VSVkUubilcbiAqIEBwYXJhbSBpc0xFIGludGVycHJldCBoYXNoIGJ5dGVzIGFzIExFIG51bVxuICogQHJldHVybnMgdmFsaWQgcHJpdmF0ZSBzY2FsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkICcgKyBtaW5MZW4gKyAnLTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAnICsgbGVuKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGtleSkgOiBieXRlc1RvTnVtYmVyQkUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6WyJhbnVtYmVyIiwiYml0TWFzayIsImJ5dGVzVG9OdW1iZXJCRSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0JFIiwibnVtYmVyVG9CeXRlc0xFIiwidmFsaWRhdGVPYmplY3QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJfNW4iLCJfOG4iLCJtb2QiLCJhIiwiYiIsInJlc3VsdCIsInBvdyIsIm51bSIsInBvd2VyIiwibW9kdWxvIiwiRnBQb3ciLCJGaWVsZCIsInBvdzIiLCJ4IiwicmVzIiwiaW52ZXJ0IiwibnVtYmVyIiwiRXJyb3IiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwic3FydDNtb2Q0IiwiRnAiLCJwMWRpdjQiLCJPUkRFUiIsInJvb3QiLCJlcWwiLCJzcXIiLCJzcXJ0NW1vZDgiLCJwNWRpdjgiLCJuMiIsIm11bCIsIm52IiwiaSIsInN1YiIsIk9ORSIsInRvbmVsbGlTaGFua3MiLCJQIiwiUSIsIlMiLCJaIiwiX0ZwIiwiRnBMZWdlbmRyZSIsImNjIiwiUTFkaXYyIiwidG9uZWxsaVNsb3ciLCJpczAiLCJNIiwiYyIsInQiLCJSIiwiWkVSTyIsInRfdG1wIiwiZXhwb25lbnQiLCJGcFNxcnQiLCJpc05lZ2F0aXZlTEUiLCJGSUVMRF9GSUVMRFMiLCJ2YWxpZGF0ZUZpZWxkIiwiZmllbGQiLCJpbml0aWFsIiwiTUFTSyIsIkJZVEVTIiwiQklUUyIsIm9wdHMiLCJyZWR1Y2UiLCJtYXAiLCJ2YWwiLCJwIiwiZCIsIkZwSW52ZXJ0QmF0Y2giLCJudW1zIiwicGFzc1plcm8iLCJpbnZlcnRlZCIsIkFycmF5IiwibGVuZ3RoIiwiZmlsbCIsInVuZGVmaW5lZCIsIm11bHRpcGxpZWRBY2MiLCJhY2MiLCJpbnZlcnRlZEFjYyIsImludiIsInJlZHVjZVJpZ2h0IiwiRnBEaXYiLCJsaHMiLCJyaHMiLCJwMW1vZDIiLCJwb3dlcmVkIiwieWVzIiwiemVybyIsIm5vIiwibmVnIiwiRnBJc1NxdWFyZSIsImwiLCJuTGVuZ3RoIiwibkJpdExlbmd0aCIsIl9uQml0TGVuZ3RoIiwidG9TdHJpbmciLCJuQnl0ZUxlbmd0aCIsIk1hdGgiLCJjZWlsIiwiYml0TGVuIiwiaXNMRSIsInJlZGVmIiwic3FydFAiLCJmIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzT2RkIiwiYWRkIiwiZGl2Iiwic3FyTiIsImFkZE4iLCJzdWJOIiwibXVsTiIsInNxcnQiLCJ0b0J5dGVzIiwiZnJvbUJ5dGVzIiwiYnl0ZXMiLCJpbnZlcnRCYXRjaCIsImxzdCIsImNtb3YiLCJGcFNxcnRPZGQiLCJlbG0iLCJGcFNxcnRFdmVuIiwiaGFzaFRvUHJpdmF0ZVNjYWxhciIsImhhc2giLCJncm91cE9yZGVyIiwiaGFzaExlbiIsIm1pbkxlbiIsImdldEZpZWxkQnl0ZXNMZW5ndGgiLCJmaWVsZE9yZGVyIiwiYml0TGVuZ3RoIiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwia2V5IiwibGVuIiwiZmllbGRMZW4iLCJyZWR1Y2VkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/**\n * Hex, bytes and number utilities.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\nfunction abytes(item) {\n    if (!isBytes(item)) throw new Error(\"Uint8Array expected\");\n}\nfunction abool(title, value) {\n    if (typeof value !== \"boolean\") throw new Error(title + \" boolean expected, got \" + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\" + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    return hex === \"\" ? _0n : BigInt(\"0x\" + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = // @ts-ignore\ntypeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\";\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = hexToBytes(hex);\n        } catch (e) {\n            throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\n        }\n    } else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(title + \" must be hex string or Uint8Array\");\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n)=>typeof n === \"bigint\" && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */ function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max)) throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;\n// DRBG\nconst u8n = (len)=>new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr)=>Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0))=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([\n            0x00\n        ]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8fr([\n            0x01\n        ]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || isBytes(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(\"invalid validator function\");\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(\"param \" + String(fieldName) + \" is invalid. Expected \" + type + \", got \" + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */ const notImplemented = ()=>{\n    throw new Error(\"not implemented\");\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */ function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args)=>{\n        const val = map.get(arg);\n        if (val !== undefined) return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxvRUFBb0UsR0FDcEUsMEVBQTBFO0FBQzFFLDhEQUE4RDtBQUM5RCwrRUFBK0U7QUFDL0UsdUNBQXVDO0FBQ3ZDLE1BQU1BLE1BQU0sYUFBYSxHQUFHQyxPQUFPO0FBQ25DLE1BQU1DLE1BQU0sYUFBYSxHQUFHRCxPQUFPO0FBQzVCLFNBQVNFLFFBQVFDLENBQUM7SUFDckIsT0FBT0EsYUFBYUMsY0FBZUMsWUFBWUMsTUFBTSxDQUFDSCxNQUFNQSxFQUFFSSxXQUFXLENBQUNDLElBQUksS0FBSztBQUN2RjtBQUNPLFNBQVNDLE9BQU9DLElBQUk7SUFDdkIsSUFBSSxDQUFDUixRQUFRUSxPQUNULE1BQU0sSUFBSUMsTUFBTTtBQUN4QjtBQUNPLFNBQVNDLE1BQU1DLEtBQUssRUFBRUMsS0FBSztJQUM5QixJQUFJLE9BQU9BLFVBQVUsV0FDakIsTUFBTSxJQUFJSCxNQUFNRSxRQUFRLDRCQUE0QkM7QUFDNUQ7QUFDQSwyQkFBMkI7QUFDcEIsU0FBU0Msb0JBQW9CQyxHQUFHO0lBQ25DLE1BQU1DLE1BQU1ELElBQUlFLFFBQVEsQ0FBQztJQUN6QixPQUFPRCxJQUFJRSxNQUFNLEdBQUcsSUFBSSxNQUFNRixNQUFNQTtBQUN4QztBQUNPLFNBQVNHLFlBQVlILEdBQUc7SUFDM0IsSUFBSSxPQUFPQSxRQUFRLFVBQ2YsTUFBTSxJQUFJTixNQUFNLDhCQUE4QixPQUFPTTtJQUN6RCxPQUFPQSxRQUFRLEtBQUtsQixNQUFNQyxPQUFPLE9BQU9pQixNQUFNLGFBQWE7QUFDL0Q7QUFDQSx5RkFBeUY7QUFDekYsTUFBTUksZ0JBQ04sYUFBYTtBQUNiLE9BQU9qQixXQUFXa0IsSUFBSSxDQUFDLEVBQUUsRUFBRUMsS0FBSyxLQUFLLGNBQWMsT0FBT25CLFdBQVdvQixPQUFP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QUNYO0FBQ0Esc0JBQXNCO0FBQ3RCLHVFQUF1RTtBQUN2RSxnRkFBZ0Y7QUFDaEYsNEJBQTRCO0FBQzVCLDJEQUEyRDtBQUMzRCxxRUFBcUU7QUFDckUsK0RBQStEO0FBQy9ELDREQUE0RDtBQUM1RDs7Q0FFQyxHQUNNLE1BQU1nQixpQkFBaUI7SUFDMUIsTUFBTSxJQUFJMUgsTUFBTTtBQUNwQixFQUFFO0FBQ0Y7OztDQUdDLEdBQ00sU0FBUzJILFNBQVNDLEVBQUU7SUFDdkIsTUFBTUMsTUFBTSxJQUFJQztJQUNoQixPQUFPLENBQUNDLEtBQUssR0FBR0M7UUFDWixNQUFNL0IsTUFBTTRCLElBQUlJLEdBQUcsQ0FBQ0Y7UUFDcEIsSUFBSTlCLFFBQVEzRCxXQUNSLE9BQU8yRDtRQUNYLE1BQU1pQyxXQUFXTixHQUFHRyxRQUFRQztRQUM1QkgsSUFBSXJFLEdBQUcsQ0FBQ3VFLEtBQUtHO1FBQ2IsT0FBT0E7SUFDWDtBQUNKLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tbXVuZS1wYWdlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzP2I3OGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyAxMDAgbGluZXMgb2YgY29kZSBpbiB0aGUgZmlsZSBhcmUgZHVwbGljYXRlZCBmcm9tIG5vYmxlLWhhc2hlcyAodXRpbHMpLlxuLy8gVGhpcyBpcyBPSzogYGFic3RyYWN0YCBkaXJlY3RvcnkgZG9lcyBub3QgdXNlIG5vYmxlLWhhc2hlcy5cbi8vIFVzZXIgbWF5IG9wdC1pbiBpbnRvIHVzaW5nIGRpZmZlcmVudCBoYXNoaW5nIGxpYnJhcnkuIFRoaXMgd2F5LCBub2JsZS1oYXNoZXNcbi8vIHdvbid0IGJlIGluY2x1ZGVkIGludG8gdGhlaXIgYnVuZGxlLlxuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFieXRlcyhpdGVtKSB7XG4gICAgaWYgKCFpc0J5dGVzKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhYm9vbCh0aXRsZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgYm9vbGVhbiBleHBlY3RlZCwgZ290ICcgKyB2YWx1ZSk7XG59XG4vLyBVc2VkIGluIHdlaWVyc3RyYXNzLCBkZXJcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gJzAnICsgaGV4IDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIHJldHVybiBoZXggPT09ICcnID8gXzBuIDogQmlnSW50KCcweCcgKyBoZXgpOyAvLyBCaWcgRW5kaWFuXG59XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IFxuLy8gQHRzLWlnbm9yZVxudHlwZW9mIFVpbnQ4QXJyYXkuZnJvbShbXSkudG9IZXggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUhleCA9PT0gJ2Z1bmN0aW9uJztcbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBDb252ZXJ0IGJ5dGUgYXJyYXkgdG8gaGV4IHN0cmluZy4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBieXRlcy50b0hleCgpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XG4gICAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7IC8vICdCJyA9PiA2Ni0oNjUtMTApXG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheS4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUhleChoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7IC8vIG11bHRpcGx5IGZpcnN0IG9jdGV0LCBlLmcuICdhMycgPT4gMTAqMTYrMyA9PiAxNjAgKyAzID0+IDE2M1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBCRTogQmlnIEVuZGlhbiwgTEU6IExpdHRsZSBFbmRpYW5cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKGJ5dGVzKS5yZXZlcnNlKCkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG51bWJlclRvSGV4VW5wYWRkZWQobikpO1xufVxuLyoqXG4gKiBUYWtlcyBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNvbnZlcnRzIHRvIFVpbnQ4QXJyYXkuXG4gKiBWYWxpZGF0ZXMgb3V0cHV0IGxlbmd0aC5cbiAqIFdpbGwgdGhyb3cgZXJyb3IgZm9yIG90aGVyIHR5cGVzLlxuICogQHBhcmFtIHRpdGxlIGRlc2NyaXB0aXZlIHRpdGxlIGZvciBhbiBlcnJvciBlLmcuICdwcml2YXRlIGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzKGhleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXksIGNhdXNlOiAnICsgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG9mIGxlbmd0aCAnICsgZXhwZWN0ZWRMZW5ndGggKyAnIGV4cGVjdGVkLCBnb3QgJyArIGxlbik7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBleHBlY3RlZCcpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8vIElzIHBvc2l0aXZlIGJpZ2ludFxuY29uc3QgaXNQb3NCaWcgPSAobikgPT4gdHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8PSBuO1xuZXhwb3J0IGZ1bmN0aW9uIGluUmFuZ2UobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gaXNQb3NCaWcobikgJiYgaXNQb3NCaWcobWluKSAmJiBpc1Bvc0JpZyhtYXgpICYmIG1pbiA8PSBuICYmIG4gPCBtYXg7XG59XG4vKipcbiAqIEFzc2VydHMgbWluIDw9IG4gPCBtYXguIE5PVEU6IEl0J3MgPCBtYXggYW5kIG5vdCA8PSBtYXguXG4gKiBAZXhhbXBsZVxuICogYUluUmFuZ2UoJ3gnLCB4LCAxbiwgMjU2bik7IC8vIHdvdWxkIGFzc3VtZSB4IGlzIGluICgxbi4uMjU1bilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFJblJhbmdlKHRpdGxlLCBuLCBtaW4sIG1heCkge1xuICAgIC8vIFdoeSBtaW4gPD0gbiA8IG1heCBhbmQgbm90IGEgKG1pbiA8IG4gPCBtYXgpIE9SIGIgKG1pbiA8PSBuIDw9IG1heCk/XG4gICAgLy8gY29uc2lkZXIgUD0yNTZuLCBtaW49MG4sIG1heD1QXG4gICAgLy8gLSBhIGZvciBtaW49MCB3b3VsZCByZXF1aXJlIC0xOiAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIC0xbiwgUClgXG4gICAgLy8gLSBiIHdvdWxkIGNvbW1vbmx5IHJlcXVpcmUgc3VidHJhY3Rpb246ICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQIC0gMW4pYFxuICAgIC8vIC0gb3VyIHdheSBpcyB0aGUgY2xlYW5lc3Q6ICAgICAgICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUClcbiAgICBpZiAoIWluUmFuZ2UobiwgbWluLCBtYXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkICcgKyB0aXRsZSArICc6ICcgKyBtaW4gKyAnIDw9IG4gPCAnICsgbWF4ICsgJywgZ290ICcgKyBuKTtcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqIFRPRE86IG1lcmdlIHdpdGggbkxlbmd0aCBpbiBtb2R1bGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzFuIDw8IEJpZ0ludChuKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbmNvbnN0IHU4ZnIgPSAoYXJyKSA9PiBVaW50OEFycmF5LmZyb20oYXJyKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuLyoqXG4gKiBNaW5pbWFsIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHdpbGwgY2FsbCBEUkJHIHVudGlsIDJuZCBhcmcgcmV0dXJucyBzb21ldGhpbmcgbWVhbmluZ2Z1bFxuICogQGV4YW1wbGVcbiAqICAgY29uc3QgZHJiZyA9IGNyZWF0ZUhtYWNEUkJHPEtleT4oMzIsIDMyLCBobWFjKTtcbiAqICAgZHJiZyhzZWVkLCBieXRlc1RvS2V5KTsgLy8gYnl0ZXNUb0tleSBtdXN0IHJldHVybiBLZXkgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigwKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlcyh2YWwpLFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb24nKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJhbSAnICsgU3RyaW5nKGZpZWxkTmFtZSkgKyAnIGlzIGludmFsaWQuIEV4cGVjdGVkICcgKyB0eXBlICsgJywgZ290ICcgKyB2YWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLyoqXG4gKiB0aHJvd3Mgbm90IGltcGxlbWVudGVkIGVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCBub3RJbXBsZW1lbnRlZCA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbi8qKlxuICogTWVtb2l6ZXMgKGNhY2hlcykgY29tcHV0YXRpb24gcmVzdWx0LlxuICogVXNlcyBXZWFrTWFwOiB0aGUgdmFsdWUgaXMgZ29pbmcgYXV0by1jbGVhbmVkIGJ5IEdDIGFmdGVyIGxhc3QgcmVmZXJlbmNlIGlzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplZChmbikge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChhcmcsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gbWFwLmdldChhcmcpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGZuKGFyZywgLi4uYXJncyk7XG4gICAgICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbIl8wbiIsIkJpZ0ludCIsIl8xbiIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiY29uc3RydWN0b3IiLCJuYW1lIiwiYWJ5dGVzIiwiaXRlbSIsIkVycm9yIiwiYWJvb2wiLCJ0aXRsZSIsInZhbHVlIiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsIm51bSIsImhleCIsInRvU3RyaW5nIiwibGVuZ3RoIiwiaGV4VG9OdW1iZXIiLCJoYXNIZXhCdWlsdGluIiwiZnJvbSIsInRvSGV4IiwiZnJvbUhleCIsImhleGVzIiwiQXJyYXkiLCJfIiwiaSIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImJ5dGVzIiwiYXNjaWlzIiwiXzAiLCJfOSIsIkEiLCJGIiwiZiIsImFzY2lpVG9CYXNlMTYiLCJjaCIsImhleFRvQnl0ZXMiLCJobCIsImFsIiwiYXJyYXkiLCJhaSIsImhpIiwibjEiLCJjaGFyQ29kZUF0IiwibjIiLCJ1bmRlZmluZWQiLCJjaGFyIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwicmV2ZXJzZSIsIm51bWJlclRvQnl0ZXNCRSIsIm4iLCJsZW4iLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJlbnN1cmVCeXRlcyIsImV4cGVjdGVkTGVuZ3RoIiwicmVzIiwiZSIsImNvbmNhdEJ5dGVzIiwiYXJyYXlzIiwic3VtIiwicGFkIiwic2V0IiwiZXF1YWxCeXRlcyIsImIiLCJkaWZmIiwidXRmOFRvQnl0ZXMiLCJzdHIiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImlzUG9zQmlnIiwiaW5SYW5nZSIsIm1pbiIsIm1heCIsImFJblJhbmdlIiwiYml0TGVuIiwiYml0R2V0IiwicG9zIiwiYml0U2V0IiwiYml0TWFzayIsInU4biIsInU4ZnIiLCJhcnIiLCJjcmVhdGVIbWFjRHJiZyIsImhhc2hMZW4iLCJxQnl0ZUxlbiIsImhtYWNGbiIsInYiLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsInJlc2VlZCIsInNlZWQiLCJnZW4iLCJvdXQiLCJzbCIsInNsaWNlIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJOdW1iZXIiLCJpc0FycmF5IiwiZmllbGQiLCJvYmplY3QiLCJGcCIsImlzVmFsaWQiLCJoYXNoIiwib3V0cHV0TGVuIiwidmFsaWRhdGVPYmplY3QiLCJ2YWxpZGF0b3JzIiwib3B0VmFsaWRhdG9ycyIsImNoZWNrRmllbGQiLCJmaWVsZE5hbWUiLCJ0eXBlIiwiaXNPcHRpb25hbCIsImNoZWNrVmFsIiwiU3RyaW5nIiwiT2JqZWN0IiwiZW50cmllcyIsIm5vdEltcGxlbWVudGVkIiwibWVtb2l6ZWQiLCJmbiIsIm1hcCIsIldlYWtNYXAiLCJhcmciLCJhcmdzIiwiZ2V0IiwiY29tcHV0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   DERErr: () => (/* binding */ DERErr),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y¬≤ = x¬≥ + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * Gx: Base point (x, y) aka generator point. Gx = x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // prettier-ignore\n\n// prettier-ignore\n\n// prettier-ignore\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"lowS\", opts.lowS);\n    if (opts.prehash !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"prehash\", opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(opts, {\n        a: \"field\",\n        b: \"field\"\n    }, {\n        allowInfinityPoint: \"boolean\",\n        allowedPrivateKeyLengths: \"array\",\n        clearCofactor: \"function\",\n        fromBytes: \"function\",\n        isTorsionFree: \"function\",\n        toBytes: \"function\",\n        wrapPrivateKey: \"boolean\"\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error(\"invalid endo: CURVE.a must be 0\");\n        }\n        if (typeof endo !== \"object\" || typeof endo.beta !== \"bigint\" || typeof endo.splitScalar !== \"function\") {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"splitScalar\": function');\n        }\n    }\n    return Object.freeze({\n        ...opts\n    });\n}\nclass DERErr extends Error {\n    constructor(m = \"\"){\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(len.length / 2 | 128) : \"\";\n            const t = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"signature\", hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\nfunction numToSizedHex(num, size) {\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, size));\n}\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{\n        const a = point.toAffine();\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Uint8Array.from([\n            0x04\n        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n    const fromBytes = CURVE.fromBytes || ((bytes)=>{\n        // const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n            x,\n            y\n        };\n    });\n    /**\n     * y¬≤ = x¬≥ + ax + b: Short weierstrass curve formula. Takes x, returns y¬≤.\n     * @returns y¬≤\n     */ function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x¬≤ * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x¬≥ + a * x + b\n    }\n    function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y¬≤\n        const right = weierstrassEquation(x); // x¬≥ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y¬≤ = x¬≥ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    // Test 2: discriminant Œî part should be non-zero: 4a¬≥ + 27b¬≤ != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error(\"bad curve params: a or b\");\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== \"bigint\") {\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(key)) key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== \"string\" || !lengths.includes(key.length)) throw new Error(\"invalid private key\");\n            key = key.padStart(nByteLength * 2, \"0\");\n        }\n        let num;\n        try {\n            num = typeof key === \"bigint\" ? key : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"private key\", key, nByteLength));\n        } catch (error) {\n            throw new Error(\"invalid private key, expected hex or \" + nByteLength + \" bytes, got \" + typeof key);\n        }\n        if (wrapPrivateKey) num = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(num, N); // disabled by default, enabled for BLS\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"private key\", num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz)=>{\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE)) return {\n            x,\n            y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x: ax,\n            y: ay\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not FE\");\n        if (!isValidXY(x, y)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z) ‚àã (x=X/Z, y=Y/Z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        constructor(px, py, pz){\n            if (px == null || !Fp.isValid(px)) throw new Error(\"x required\");\n            if (py == null || !Fp.isValid(py) || Fp.is0(py)) throw new Error(\"y required\");\n            if (pz == null || !Fp.isValid(pz)) throw new Error(\"z required\");\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            const is0 = (i)=>Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */ static normalizeZ(points) {\n            const toInv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(Fp, points.map((p)=>p.pz));\n            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */ static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"pointHex\", hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd) return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */ equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */ negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"scalar\", sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n) return I;\n            if (this.is0() || sc === _1n) return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            /** See docs for {@link EndomorphismOpts} */ let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while(k1 > _0n || k2 > _0n){\n                if (k1 & _1n) k1p = k1p.add(d);\n                if (k2 & _1n) k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg) k1p = k1p.negate();\n            if (k2neg) k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"scalar\", scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            /** See docs for {@link EndomorphismOpts} */ if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            } else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */ multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ‚àã (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n) return true; // No subgroups, always torsion-free\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(this.toRawBytes(isCompressed));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    const { endo, nBitLength } = CURVE;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(opts, {\n        hash: \"hash\",\n        hmac: \"function\",\n        randomBytes: \"function\"\n    }, {\n        bits2int: \"function\",\n        bits2int_modN: \"function\",\n        lowS: \"boolean\"\n    });\n    return Object.freeze({\n        lowS: true,\n        ...opts\n    });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */ function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({\n        ...CURVE,\n        toBytes (_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)(\"isCompressed\", isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([\n                    point.hasEvenY() ? 0x02 : 0x03\n                ]), x);\n            } else {\n                return cat(Uint8Array.from([\n                    0x04\n                ]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes (bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(tail);\n                if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(x, _1n, Fp.ORDER)) throw new Error(\"Point is not on curve\");\n                const y2 = weierstrassEquation(x); // y¬≤ = x¬≥ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y¬≤ ^ (p+1)/4\n                } catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                    throw new Error(\"Point is not on curve\" + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n                return {\n                    x,\n                    y\n                };\n            } else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return {\n                    x,\n                    y\n                };\n            } else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error(\"invalid Point, expected length of \" + cl + \", or uncompressed \" + ul + \", got \" + len);\n            }\n        }\n    });\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"r\", r, _1n, CURVE_ORDER); // r in [1..N]\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"s\", s, _1n, CURVE_ORDER); // s in [1..N]\n            this.r = r;\n            this.s = s;\n            if (recovery != null) this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"compactSignature\", hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"DER\", hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */ assertValidity() {}\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash)); // Truncate hash\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n            const prefix = (rec & 1) === 0 ? \"02\" : \"03\";\n            const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q) throw new Error(\"point at infinify\"); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig(this);\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(this.toCompactHex());\n        }\n        toCompactHex() {\n            const l = nByteLength;\n            return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);\n        }\n    }\n    const utils = {\n        isValidPrivateKey (privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            } catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */ randomPrivateKey: ()=>{\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength)(CURVE.n);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */ precompute (windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        }\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        if (typeof item === \"bigint\") return false;\n        if (item instanceof Point) return true;\n        const arr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"key\", item);\n        const len = arr.length;\n        const fpl = Fp.BYTES;\n        const compLen = fpl + 1; // e.g. 33 for 32\n        const uncompLen = 2 * fpl + 1; // e.g. 65 for 32\n        if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) {\n            return undefined;\n        } else {\n            return len === compLen || len === uncompLen;\n        }\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA) === true) throw new Error(\"first arg must be private key\");\n        if (isProbPub(publicB) === false) throw new Error(\"second arg must be public key\");\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int || function(bytes) {\n        // Our custom check \"just in case\", for protection against DoS\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {\n        return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */ function int2octets(num) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"num < 2^\" + nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        validateSigVerOpts(opts);\n        if (prehash) msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"prehashed msgHash\", hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ‚àà [1,q‚àí1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    const defaultSigOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    const defaultVerOpts = {\n        lowS: CURVE.lowS,\n        prehash: false\n    };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G √ó k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */ function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg)(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1‚ãÖG - U2‚ãÖP\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"publicKey\", publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        if (format !== undefined && format !== \"compact\" && format !== \"der\") throw new Error(\"format must be compact or der\");\n        const isHex = typeof sg === \"string\" || (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(sg);\n        const isObj = !isHex && !format && typeof sg === \"object\" && sg !== null && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n        if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj) _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== \"compact\") _sig = Signature.fromDER(sg);\n                } catch (derError) {\n                    if (!(derError instanceof DER.Err)) throw derError;\n                }\n                if (!_sig && format !== \"der\") _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        } catch (error) {\n            return false;\n        }\n        if (!_sig) return false;\n        if (lowS && _sig.hasHighS()) return false;\n        if (prehash) msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1‚ãÖG + u2‚ãÖP\n        if (!R) return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(Fp, [\n            tv4\n        ], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0NDLEdBQ0Qsb0VBQW9FLEdBQ3BFLGtCQUFrQjtBQUMwQztBQUM1RCxrQkFBa0I7QUFDZ0c7QUFDbEgsa0JBQWtCO0FBQ3lNO0FBQzNOLFNBQVN5QixtQkFBbUJDLElBQUk7SUFDNUIsSUFBSUEsS0FBS0MsSUFBSSxLQUFLQyxXQUNkakIsZ0RBQUtBLENBQUMsUUFBUWUsS0FBS0MsSUFBSTtJQUMzQixJQUFJRCxLQUFLRyxPQUFPLEtBQUtELFdBQ2pCakIsZ0RBQUtBLENBQUMsV0FBV2UsS0FBS0csT0FBTztBQUNyQztBQUNBLFNBQVNDLGtCQUFrQkMsS0FBSztJQUM1QixNQUFNTCxPQUFPekIsd0RBQWFBLENBQUM4QjtJQUMzQlAseURBQWNBLENBQUNFLE1BQU07UUFDakJNLEdBQUc7UUFDSEMsR0FBRztJQUNQLEdBQUc7UUFDQ0Msb0JBQW9CO1FBQ3BCQywwQkFBMEI7UUFDMUJDLGVBQWU7UUFDZkMsV0FBVztRQUNYQyxlQUFlO1FBQ2ZDLFNBQVM7UUFDVEMsZ0JBQWdCO0lBQ3BCO0lBQ0EsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLEVBQUUsRUFBRVYsQ0FBQyxFQUFFLEdBQUdOO0lBQ3hCLElBQUllLE1BQU07UUFDTixJQUFJLENBQUNDLEdBQUdDLEdBQUcsQ0FBQ1gsR0FBR1UsR0FBR0UsSUFBSSxHQUFHO1lBQ3JCLE1BQU0sSUFBSUMsTUFBTTtRQUNwQjtRQUNBLElBQUksT0FBT0osU0FBUyxZQUNoQixPQUFPQSxLQUFLSyxJQUFJLEtBQUssWUFDckIsT0FBT0wsS0FBS00sV0FBVyxLQUFLLFlBQVk7WUFDeEMsTUFBTSxJQUFJRixNQUFNO1FBQ3BCO0lBQ0o7SUFDQSxPQUFPRyxPQUFPQyxNQUFNLENBQUM7UUFBRSxHQUFH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LElBQUlBLEdBQUdtUCxLQUFLLDRCQUE0QjtRQUMzRCxNQUFNTyxVQUFVeFcsMERBQWFBLENBQUNzQyxJQUFJO1lBQUN1VDtTQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUU7UUFDakRoUCxJQUFJdkUsR0FBR2dGLEdBQUcsQ0FBQ1QsR0FBRzJQLFVBQVUsb0JBQW9CO1FBQzVDLE9BQU87WUFBRTNQO1lBQUdDO1FBQUU7SUFDbEI7QUFDSixFQUNBLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbW11bmUtcGFnZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz9iNThiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2hvcnQgV2VpZXJzdHJhc3MgY3VydmUgbWV0aG9kcy4gVGhlIGZvcm11bGEgaXM6IHnCsiA9IHjCsyArIGF4ICsgYi5cbiAqXG4gKiAjIyMgUGFyYW1ldGVyc1xuICpcbiAqIFRvIGluaXRpYWxpemUgYSB3ZWllcnN0cmFzcyBjdXJ2ZSwgb25lIG5lZWRzIHRvIHBhc3MgZm9sbG93aW5nIHBhcmFtczpcbiAqXG4gKiAqIGE6IGZvcm11bGEgcGFyYW1cbiAqICogYjogZm9ybXVsYSBwYXJhbVxuICogKiBGcDogZmluaXRlIGZpZWxkIG9mIHByaW1lIGNoYXJhY3RlcmlzdGljIFA7IG1heSBiZSBjb21wbGV4IChGcDIpLiBBcml0aG1ldGljcyBpcyBkb25lIGluIGZpZWxkXG4gKiAqIG46IG9yZGVyIG9mIHByaW1lIHN1Ymdyb3VwIGEuay5hIHRvdGFsIGFtb3VudCBvZiB2YWxpZCBjdXJ2ZSBwb2ludHNcbiAqICogR3g6IEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnQuIEd4ID0geCBjb29yZGluYXRlXG4gKiAqIEd5OiAuLi55IGNvb3JkaW5hdGVcbiAqICogaDogY29mYWN0b3IsIHVzdWFsbHkgMS4gaCpuID0gY3VydmUgZ3JvdXAgb3JkZXIgKG4gaXMgb25seSBzdWJncm91cCBvcmRlcilcbiAqICogbG93Uzogd2hldGhlciB0byBlbmFibGUgKGRlZmF1bHQpIG9yIGRpc2FibGUgXCJsb3ctc1wiIG5vbi1tYWxsZWFibGUgc2lnbmF0dXJlc1xuICpcbiAqICMjIyBEZXNpZ24gcmF0aW9uYWxlIGZvciB0eXBlc1xuICpcbiAqICogSW50ZXJhY3Rpb24gYmV0d2VlbiBjbGFzc2VzIGZyb20gZGlmZmVyZW50IGN1cnZlcyBzaG91bGQgZmFpbDpcbiAqICAgYGsyNTYuUG9pbnQuQkFTRS5hZGQocDI1Ni5Qb2ludC5CQVNFKWBcbiAqICogRm9yIHRoaXMgcHVycG9zZSB3ZSB3YW50IHRvIHVzZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IsIHdoaWNoIGlzIGZhc3QgYW5kIHdvcmtzIGR1cmluZyBydW50aW1lXG4gKiAqIERpZmZlcmVudCBjYWxscyBvZiBgY3VydmUoKWAgd291bGQgcmV0dXJuIGRpZmZlcmVudCBjbGFzc2VzIC1cbiAqICAgYGN1cnZlKHBhcmFtcykgIT09IGN1cnZlKHBhcmFtcylgOiBpZiBzb21lYm9keSBkZWNpZGVkIHRvIG1vbmtleS1wYXRjaCB0aGVpciBjdXJ2ZSxcbiAqICAgaXQgd29uJ3QgYWZmZWN0IG90aGVyc1xuICpcbiAqIFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdHlwZXMgZm9yIGNsYXNzZXMgY3JlYXRlZCBpbnNpZGUgYSBmdW5jdGlvbi4gQ2xhc3NlcyBpcyBvbmUgaW5zdGFuY2VcbiAqIG9mIG5vbWluYXRpdmUgdHlwZXMgaW4gVHlwZVNjcmlwdCBhbmQgaW50ZXJmYWNlcyBvbmx5IGNoZWNrIGZvciBzaGFwZSwgc28gaXQncyBoYXJkIHRvIGNyZWF0ZVxuICogdW5pcXVlIHR5cGUgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogV2UgY2FuIHVzZSBnZW5lcmljIHR5cGVzIHZpYSBzb21lIHBhcmFtLCBsaWtlIGN1cnZlIG9wdHMsIGJ1dCB0aGF0IHdvdWxkOlxuICogICAgIDEuIEVuYWJsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIGBjdXJ2ZShwYXJhbXMpYCBhbmQgYGN1cnZlKHBhcmFtcylgIChjdXJ2ZXMgb2Ygc2FtZSBwYXJhbXMpXG4gKiAgICAgd2hpY2ggaXMgaGFyZCB0byBkZWJ1Zy5cbiAqICAgICAyLiBQYXJhbXMgY2FuIGJlIGdlbmVyaWMgYW5kIHdlIGNhbid0IGVuZm9yY2UgdGhlbSB0byBiZSBjb25zdGFudCB2YWx1ZTpcbiAqICAgICBpZiBzb21lYm9keSBjcmVhdGVzIGN1cnZlIGZyb20gbm9uLWNvbnN0YW50IHBhcmFtcyxcbiAqICAgICBpdCB3b3VsZCBiZSBhbGxvd2VkIHRvIGludGVyYWN0IHdpdGggb3RoZXIgY3VydmVzIHdpdGggbm9uLWNvbnN0YW50IHBhcmFtc1xuICpcbiAqIEB0b2RvIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTcuaHRtbCN1bmlxdWUtc3ltYm9sXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgcGlwcGVuZ2VyLCB2YWxpZGF0ZUJhc2ljLCB3TkFGIH0gZnJvbSBcIi4vY3VydmUuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIGdldE1pbkhhc2hMZW5ndGgsIGludmVydCwgbWFwSGFzaFRvRmllbGQsIG1vZCwgdmFsaWRhdGVGaWVsZCB9IGZyb20gXCIuL21vZHVsYXIuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYUluUmFuZ2UsIGFib29sLCBiaXRNYXNrLCBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBjcmVhdGVIbWFjRHJiZywgZW5zdXJlQnl0ZXMsIGhleFRvQnl0ZXMsIGluUmFuZ2UsIGlzQnl0ZXMsIG1lbW9pemVkLCBudW1iZXJUb0J5dGVzQkUsIG51bWJlclRvSGV4VW5wYWRkZWQsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmZ1bmN0aW9uIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKSB7XG4gICAgaWYgKG9wdHMubG93UyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhYm9vbCgnbG93UycsIG9wdHMubG93Uyk7XG4gICAgaWYgKG9wdHMucHJlaGFzaCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhYm9vbCgncHJlaGFzaCcsIG9wdHMucHJlaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBvaW50T3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiAnYXJyYXknLFxuICAgICAgICBjbGVhckNvZmFjdG9yOiAnZnVuY3Rpb24nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG86IENVUlZFLmEgbXVzdCBiZSAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kbzogZXhwZWN0ZWQgXCJiZXRhXCI6IGJpZ2ludCBhbmQgXCJzcGxpdFNjYWxhclwiOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbmV4cG9ydCBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobSA9ICcnKSB7XG4gICAgICAgIHN1cGVyKG0pO1xuICAgIH1cbn1cbi8qKlxuICogQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllcy4gQVNOIGlzIHZlcnkgY29tcGxleCAmIGZyYWdpbGUuIEZvcm1hdDpcbiAqXG4gKiAgICAgWzB4MzAgKFNFUVVFTkNFKSwgYnl0ZWxlbmd0aCwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgUiwgMHgwMiAoSU5URUdFUiksIGludExlbmd0aCwgU11cbiAqXG4gKiBEb2NzOiBodHRwczovL2xldHNlbmNyeXB0Lm9yZy9kb2NzL2Etd2FybS13ZWxjb21lLXRvLWFzbjEtYW5kLWRlci8sIGh0dHBzOi8vbHVjYS5udG9wLm9yZy9UZWFjaGluZy9BcHB1bnRpL2FzbjEuaHRtbFxuICovXG5leHBvcnQgY29uc3QgREVSID0ge1xuICAgIC8vIGFzbi4xIERFUiBlbmNvZGluZyB1dGlsc1xuICAgIEVycjogREVSRXJyLFxuICAgIC8vIEJhc2ljIGJ1aWxkaW5nIGJsb2NrIGlzIFRMViAoVGFnLUxlbmd0aC1WYWx1ZSlcbiAgICBfdGx2OiB7XG4gICAgICAgIGVuY29kZTogKHRhZywgZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB1bnBhZGRlZCBkYXRhJyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhTGVuID0gZGF0YS5sZW5ndGggLyAyO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbnVtYmVyVG9IZXhVbnBhZGRlZChkYXRhTGVuKTtcbiAgICAgICAgICAgIGlmICgobGVuLmxlbmd0aCAvIDIpICYgMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiBsb25nIGZvcm0gbGVuZ3RoIHRvbyBiaWcnKTtcbiAgICAgICAgICAgIC8vIGxlbmd0aCBvZiBsZW5ndGggd2l0aCBsb25nIGZvcm0gZmxhZ1xuICAgICAgICAgICAgY29uc3QgbGVuTGVuID0gZGF0YUxlbiA+IDEyNyA/IG51bWJlclRvSGV4VW5wYWRkZWQoKGxlbi5sZW5ndGggLyAyKSB8IDEyOCkgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IHQgPSBudW1iZXJUb0hleFVucGFkZGVkKHRhZyk7XG4gICAgICAgICAgICByZXR1cm4gdCArIGxlbkxlbiArIGxlbiArIGRhdGE7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHYgLSB2YWx1ZSwgbCAtIGxlZnQgYnl0ZXMgKHVucGFyc2VkKVxuICAgICAgICBkZWNvZGUodGFnLCBkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhW3BvcysrXSAhPT0gdGFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB0bHYnKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBjb25zdCBpc0xvbmcgPSAhIShmaXJzdCAmIDEyOCk7IC8vIEZpcnN0IGJpdCBvZiBmaXJzdCBsZW5ndGggYnl0ZSBpcyBmbGFnIGZvciBzaG9ydC9sb25nIGZvcm1cbiAgICAgICAgICAgIGxldCBsZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKCFpc0xvbmcpXG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gZmlyc3Q7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMb25nIGZvcm06IFtsb25nRmxhZygxYml0KSwgbGVuZ3RoTGVuZ3RoKDdiaXQpLCBsZW5ndGggKEJFKV1cbiAgICAgICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBmaXJzdCAmIDEyNztcbiAgICAgICAgICAgICAgICBpZiAoIWxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IGluZGVmaW5pdGUgbGVuZ3RoIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuTGVuID4gNClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IGJ5dGUgbGVuZ3RoIGlzIHRvbyBiaWcnKTsgLy8gdGhpcyB3aWxsIG92ZXJmbG93IHUzMiBpbiBqc1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aEJ5dGVzID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbkxlbik7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzLmxlbmd0aCAhPT0gbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogbGVuZ3RoIGJ5dGVzIG5vdCBjb21wbGV0ZScpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlc1swXSA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IHplcm8gbGVmdG1vc3QgYnl0ZScpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYiBvZiBsZW5ndGhCeXRlcylcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gKGxlbmd0aCA8PCA4KSB8IGI7XG4gICAgICAgICAgICAgICAgcG9zICs9IGxlbkxlbjtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDwgMTI4KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogbm90IG1pbmltYWwgZW5jb2RpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHYgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICh2Lmxlbmd0aCAhPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiB3cm9uZyB2YWx1ZSBsZW5ndGgnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHYsIGw6IGRhdGEuc3ViYXJyYXkocG9zICsgbGVuZ3RoKSB9O1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgLy8gaHR0cHM6Ly9jcnlwdG8uc3RhY2tleGNoYW5nZS5jb20vYS81NzczNCBMZWZ0bW9zdCBiaXQgb2YgZmlyc3QgYnl0ZSBpcyAnbmVnYXRpdmUnIGZsYWcsXG4gICAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgLy8gLSBpZiBuZXh0IGJ5dGUgZG9lc24ndCBoYXZlIGEgZmxhZywgbGVhZGluZyB6ZXJvIGlzIG5vdCBhbGxvd2VkIChtaW5pbWFsIGVuY29kaW5nKVxuICAgIF9pbnQ6IHtcbiAgICAgICAgZW5jb2RlKG51bSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmIChudW0gPCBfMG4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludGVnZXI6IG5lZ2F0aXZlIGludGVnZXJzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgbGV0IGhleCA9IG51bWJlclRvSGV4VW5wYWRkZWQobnVtKTtcbiAgICAgICAgICAgIC8vIFBhZCB3aXRoIHplcm8gYnl0ZSBpZiBuZWdhdGl2ZSBmbGFnIGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaGV4WzBdLCAxNikgJiAwYjEwMDApXG4gICAgICAgICAgICAgICAgaGV4ID0gJzAwJyArIGhleDtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndW5leHBlY3RlZCBERVIgcGFyc2luZyBhc3NlcnRpb246IHVucGFkZGVkIGhleCcpO1xuICAgICAgICAgICAgcmV0dXJuIGhleDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdID09PSAweDAwICYmICEoZGF0YVsxXSAmIDEyOCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJCRShkYXRhKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFLCBfaW50OiBpbnQsIF90bHY6IHRsdiB9ID0gREVSO1xuICAgICAgICBjb25zdCBkYXRhID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIGhleCk7XG4gICAgICAgIGNvbnN0IHsgdjogc2VxQnl0ZXMsIGw6IHNlcUxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDMwLCBkYXRhKTtcbiAgICAgICAgaWYgKHNlcUxlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICBjb25zdCB7IHY6IHJCeXRlcywgbDogckxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDAyLCBzZXFCeXRlcyk7XG4gICAgICAgIGNvbnN0IHsgdjogc0J5dGVzLCBsOiBzTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHJMZWZ0Qnl0ZXMpO1xuICAgICAgICBpZiAoc0xlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByOiBpbnQuZGVjb2RlKHJCeXRlcyksIHM6IGludC5kZWNvZGUoc0J5dGVzKSB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgY29uc3QgeyBfdGx2OiB0bHYsIF9pbnQ6IGludCB9ID0gREVSO1xuICAgICAgICBjb25zdCBycyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucikpO1xuICAgICAgICBjb25zdCBzcyA9IHRsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucykpO1xuICAgICAgICBjb25zdCBzZXEgPSBycyArIHNzO1xuICAgICAgICByZXR1cm4gdGx2LmVuY29kZSgweDMwLCBzZXEpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gbnVtVG9TaXplZEhleChudW0sIHNpemUpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChudW1iZXJUb0J5dGVzQkUobnVtLCBzaXplKSk7XG59XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwgQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGEuIFRha2VzIHgsIHJldHVybnMgecKyLlxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4wrIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geMKzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRYWSh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICByZXR1cm4gRnAuZXFsKGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gVGVzdCAxOiBlcXVhdGlvbiB5wrIgPSB4wrMgKyBheCArIGIgc2hvdWxkIHdvcmsgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICBpZiAoIWlzVmFsaWRYWShDVVJWRS5HeCwgQ1VSVkUuR3kpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludCcpO1xuICAgIC8vIFRlc3QgMjogZGlzY3JpbWluYW50IM6UIHBhcnQgc2hvdWxkIGJlIG5vbi16ZXJvOiA0YcKzICsgMjdiwrIgIT0gMC5cbiAgICAvLyBHdWFyYW50ZWVzIGN1cnZlIGlzIGdlbnVzLTEsIHNtb290aCAobm9uLXNpbmd1bGFyKS5cbiAgICBjb25zdCBfNGEzID0gRnAubXVsKEZwLnBvdyhDVVJWRS5hLCBfM24pLCBfNG4pO1xuICAgIGNvbnN0IF8yN2IyID0gRnAubXVsKEZwLnNxcihDVVJWRS5iKSwgQmlnSW50KDI3KSk7XG4gICAgaWYgKEZwLmlzMChGcC5hZGQoXzRhMywgXzI3YjIpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY3VydmUgcGFyYW1zOiBhIG9yIGInKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gaW5SYW5nZShudW0sIF8xbiwgQ1VSVkUubik7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChpc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleScpO1xuICAgICAgICAgICAga2V5ID0ga2V5LnBhZFN0YXJ0KG5CeXRlTGVuZ3RoICogMiwgJzAnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID1cbiAgICAgICAgICAgICAgICB0eXBlb2Yga2V5ID09PSAnYmlnaW50J1xuICAgICAgICAgICAgICAgICAgICA/IGtleVxuICAgICAgICAgICAgICAgICAgICA6IGJ5dGVzVG9OdW1iZXJCRShlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBrZXksIGV4cGVjdGVkIGhleCBvciAnICsgbkJ5dGVMZW5ndGggKyAnIGJ5dGVzLCBnb3QgJyArIHR5cGVvZiBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZChudW0sIE4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgYUluUmFuZ2UoJ3ByaXZhdGUga2V5JywgbnVtLCBfMW4sIE4pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXByanBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLy8gTWVtb2l6ZWQgdG9BZmZpbmUgLyB2YWxpZGl0eSBjaGVjay4gVGhleSBhcmUgaGVhdnkuIFBvaW50cyBhcmUgaW1tdXRhYmxlLlxuICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAvLyAoWCwgWSwgWikg4oiLICh4PVgvWiwgeT1ZL1opXG4gICAgY29uc3QgdG9BZmZpbmVNZW1vID0gbWVtb2l6ZWQoKHAsIGl6KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gcDtcbiAgICAgICAgLy8gRmFzdC1wYXRoIGZvciBub3JtYWxpemVkIHBvaW50c1xuICAgICAgICBpZiAoRnAuZXFsKHosIEZwLk9ORSkpXG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIGNvbnN0IGlzMCA9IHAuaXMwKCk7XG4gICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KHopO1xuICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBGcC5tdWwoeiwgaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICB9KTtcbiAgICAvLyBOT1RFOiBvbiBleGNlcHRpb24gdGhpcyB3aWxsIGNyYXNoICdjYWNoZWQnIGFuZCBubyB2YWx1ZSB3aWxsIGJlIHNldC5cbiAgICAvLyBPdGhlcndpc2UgdHJ1ZSB3aWxsIGJlIHJldHVyblxuICAgIGNvbnN0IGFzc2VydFZhbGlkTWVtbyA9IG1lbW9pemVkKChwKSA9PiB7XG4gICAgICAgIGlmIChwLmlzMCgpKSB7XG4gICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgLy8gSW4gQkxTLCBaRVJPIGNhbiBiZSBzZXJpYWxpemVkLCBzbyB3ZSBhbGxvdyBpdC5cbiAgICAgICAgICAgIC8vICgwLCAwLCAwKSBpcyBpbnZhbGlkIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8uXG4gICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAocC5weSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcC50b0FmZmluZSgpO1xuICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICBpZiAoIWlzVmFsaWRYWSh4LCB5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6IChYLCBZLCBaKSDiiIsgKHg9WC9aLCB5PVkvWilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkgfHwgRnAuaXMwKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnBJbnZlcnRCYXRjaChGcCwgcG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXNjYWxhciBNdWx0aXBsaWNhdGlvblxuICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICAgICAgcmV0dXJuIHBpcHBlbmdlcihQb2ludCwgRm4sIHBvaW50cywgc2NhbGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gXCJQcml2YXRlIG1ldGhvZFwiLCBkb24ndCB1c2UgaXQgZGlyZWN0bHlcbiAgICAgICAgX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSkge1xuICAgICAgICAgICAgd25hZi5zZXRXaW5kb3dTaXplKHRoaXMsIHdpbmRvd1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgYXNzZXJ0VmFsaWRNZW1vKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoRnAuaXNPZGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICFGcC5pc09kZCh5KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXByanBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFwcmpwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgbiwgUG9pbnQubm9ybWFsaXplWik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKHNjKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8sIG46IE4gfSA9IENVUlZFO1xuICAgICAgICAgICAgYUluUmFuZ2UoJ3NjYWxhcicsIHNjLCBfMG4sIE4pO1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAoc2MgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzMCgpIHx8IHNjID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAvLyBDYXNlIGE6IG5vIGVuZG9tb3JwaGlzbS4gQ2FzZSBiOiBoYXMgcHJlY29tcHV0ZXMuXG4gICAgICAgICAgICBpZiAoIWVuZG8gfHwgd25hZi5oYXNQcmVjb21wdXRlcyh0aGlzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkVW5zYWZlKHRoaXMsIHNjLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgICAgIC8vIENhc2UgYzogZW5kb21vcnBoaXNtXG4gICAgICAgICAgICAvKiogU2VlIGRvY3MgZm9yIHtAbGluayBFbmRvbW9ycGhpc21PcHRzfSAqL1xuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2MpO1xuICAgICAgICAgICAgbGV0IGsxcCA9IEk7XG4gICAgICAgICAgICBsZXQgazJwID0gSTtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazFwID0gazFwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgZCA9IGQuZG91YmxlKCk7XG4gICAgICAgICAgICAgICAgazEgPj49IF8xbjtcbiAgICAgICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RhbnQgdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAgICAgKiBidXQgdGFrZXMgMnggbG9uZ2VyIHRvIGdlbmVyYXRlIGFuZCBjb25zdW1lcyAyeCBtZW1vcnkuXG4gICAgICAgICAqIFVzZXMgcHJlY29tcHV0ZXMgd2hlbiBhdmFpbGFibGUuXG4gICAgICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgICAgICogQHBhcmFtIHNjYWxhciBieSB3aGljaCB0aGUgcG9pbnQgd291bGQgYmUgbXVsdGlwbGllZFxuICAgICAgICAgKiBAcmV0dXJucyBOZXcgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgeyBlbmRvLCBuOiBOIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGFJblJhbmdlKCdzY2FsYXInLCBzY2FsYXIsIF8xbiwgTik7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIC8qKiBTZWUgZG9jcyBmb3Ige0BsaW5rIEVuZG9tb3JwaGlzbU9wdHN9ICovXG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpeik7XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYmFzZSAvIGdlbmVyYXRvciBwb2ludFxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIC8vIHplcm8gLyBpbmZpbml0eSAvIGlkZW50aXR5IHBvaW50XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pOyAvLyAwLCAxLCAwXG4gICAgY29uc3QgeyBlbmRvLCBuQml0TGVuZ3RoIH0gPSBDVVJWRTtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgZW5kbyA/IE1hdGguY2VpbChuQml0TGVuZ3RoIC8gMikgOiBuQml0TGVuZ3RoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgc2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgYW5kIEVDRFNBIHNpZ25hdHVyZSBtZXRob2RzIGZvciBpdC5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBGaWVsZCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG4gKiAvLyBCZWZvcmUgdGhhdCwgZGVmaW5lIEJpZ0ludC1zOiBhLCBiLCBwLCBuLCBHeCwgR3lcbiAqIGNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3MoeyBhLCBiLCBGcDogRmllbGQocCksIG4sIEd4LCBHeSwgaDogMW4gfSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSLCBuQnl0ZUxlbmd0aCwgbkJpdExlbmd0aCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgY29tcHJlc3NlZExlbiA9IEZwLkJZVEVTICsgMTsgLy8gZS5nLiAzMyBmb3IgMzJcbiAgICBjb25zdCB1bmNvbXByZXNzZWRMZW4gPSAyICogRnAuQllURVMgKyAxOyAvLyBlLmcuIDY1IGZvciAzMlxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52TihhKSB7XG4gICAgICAgIHJldHVybiBpbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IGNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oW3BvaW50Lmhhc0V2ZW5ZKCkgPyAweDAyIDogMHgwM10pLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFsweDA0XSksIHgsIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gdGhpcy5hc3NlcnRWYWxpZGl0eSgpIGlzIGRvbmUgaW5zaWRlIG9mIGZyb21IZXhcbiAgICAgICAgICAgIGlmIChsZW4gPT09IGNvbXByZXNzZWRMZW4gJiYgKGhlYWQgPT09IDB4MDIgfHwgaGVhZCA9PT0gMHgwMykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gYnl0ZXNUb051bWJlckJFKHRhaWwpO1xuICAgICAgICAgICAgICAgIGlmICghaW5SYW5nZSh4LCBfMW4sIEZwLk9SREVSKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5MiA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHnCsiA9IHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgICAgIGxldCB5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKHNxcnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXggPSBzcXJ0RXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/ICc6ICcgKyBzcXJ0RXJyb3IubWVzc2FnZSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScgKyBzdWZmaXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsID0gY29tcHJlc3NlZExlbjtcbiAgICAgICAgICAgICAgICBjb25zdCB1bCA9IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUG9pbnQsIGV4cGVjdGVkIGxlbmd0aCBvZiAnICsgY2wgKyAnLCBvciB1bmNvbXByZXNzZWQgJyArIHVsICsgJywgZ290ICcgKyBsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IGJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgYUluUmFuZ2UoJ3InLCByLCBfMW4sIENVUlZFX09SREVSKTsgLy8gciBpbiBbMS4uTl1cbiAgICAgICAgICAgIGFJblJhbmdlKCdzJywgcywgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHMgaW4gWzEuLk5dXG4gICAgICAgICAgICB0aGlzLnIgPSByO1xuICAgICAgICAgICAgdGhpcy5zID0gcztcbiAgICAgICAgICAgIGlmIChyZWNvdmVyeSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcnkgPSByZWNvdmVyeTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IG5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0b2RvIHJlbW92ZVxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7IH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub1NpemVkSGV4KHJhZGosIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IG5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvU2l6ZWRIZXgodGhpcy5yLCBsKSArIG51bVRvU2l6ZWRIZXgodGhpcy5zLCBsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBnZXRNaW5IYXNoTGVuZ3RoKENVUlZFLm4pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcEhhc2hUb0ZpZWxkKENVUlZFLnJhbmRvbUJ5dGVzKGxlbmd0aCksIENVUlZFLm4pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBwcmVjb21wdXRlIHRhYmxlIGZvciBhbiBhcmJpdHJhcnkgRUMgcG9pbnQuIE1ha2VzIHBvaW50IFwiY2FjaGVkXCIuXG4gICAgICAgICAqIEFsbG93cyB0byBtYXNzaXZlbHkgc3BlZWQtdXAgYHBvaW50Lm11bHRpcGx5KHNjYWxhcilgLlxuICAgICAgICAgKiBAcmV0dXJucyBjYWNoZWQgcG9pbnRcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3QgZmFzdCA9IHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LmZyb21IZXgoc29tZW9uZXNQdWJLZXkpKTtcbiAgICAgICAgICogZmFzdC5tdWx0aXBseShwcml2S2V5KTsgLy8gbXVjaCBmYXN0ZXIgRUNESCBub3dcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcG9pbnQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgICAgICBwb2ludC5tdWx0aXBseShCaWdJbnQoMykpOyAvLyAzIGlzIGFyYml0cmFyeSwganVzdCBuZWVkIGFueSBudW1iZXIgaGVyZVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9LFxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBwcml2YXRlIGtleS4gQ2hlY2tzIGZvciB2YWxpZGl0eSBvZiB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIFB1YmxpYyBrZXksIGZ1bGwgd2hlbiBpc0NvbXByZXNzZWQ9ZmFsc2U7IHNob3J0IHdoZW4gaXNDb21wcmVzc2VkPXRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWljayBhbmQgZGlydHkgY2hlY2sgZm9yIGl0ZW0gYmVpbmcgcHVibGljIGtleS4gRG9lcyBub3QgdmFsaWRhdGUgaGV4LCBvciBiZWluZyBvbi1jdXJ2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb2JQdWIoaXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IGFyciA9IGVuc3VyZUJ5dGVzKCdrZXknLCBpdGVtKTtcbiAgICAgICAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZnBsID0gRnAuQllURVM7XG4gICAgICAgIGNvbnN0IGNvbXBMZW4gPSBmcGwgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgICAgICBjb25zdCB1bmNvbXBMZW4gPSAyICogZnBsICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICAgICAgaWYgKENVUlZFLmFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyB8fCBuQnl0ZUxlbmd0aCA9PT0gY29tcExlbikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXBMZW4gfHwgbGVuID09PSB1bmNvbXBMZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkgPT09IHRydWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHVibGljQikgPT09IGZhbHNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIE91ciBjdXN0b20gY2hlY2sgXCJqdXN0IGluIGNhc2VcIiwgZm9yIHByb3RlY3Rpb24gYWdhaW5zdCBEb1NcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiA4MTkyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgaXMgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gbkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gYml0TWFzayhuQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGFJblJhbmdlKCdudW0gPCAyXicgKyBuQml0TGVuZ3RoLCBudW0sIF8wbiwgT1JERVJfTUFTSyk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShudW0sIG5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLFxuICAgIC8vIHRoaXMgd2lsbCBiZSBpbnZhbGlkIGF0IGxlYXN0IGZvciBQNTIxLiBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCwgZm9ybWF0IH0gPSBvcHRzO1xuICAgICAgICAvLyBWZXJpZnkgb3B0cywgZGVkdWNlIHNpZ25hdHVyZSBmb3JtYXRcbiAgICAgICAgdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpO1xuICAgICAgICBpZiAoJ3N0cmljdCcgaW4gb3B0cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJpY3Qgd2FzIHJlbmFtZWQgdG8gbG93UycpO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSB1bmRlZmluZWQgJiYgZm9ybWF0ICE9PSAnY29tcGFjdCcgJiYgZm9ybWF0ICE9PSAnZGVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZm9ybWF0IG11c3QgYmUgY29tcGFjdCBvciBkZXInKTtcbiAgICAgICAgY29uc3QgaXNIZXggPSB0eXBlb2Ygc2cgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXMoc2cpO1xuICAgICAgICBjb25zdCBpc09iaiA9ICFpc0hleCAmJlxuICAgICAgICAgICAgIWZvcm1hdCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgc2cgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnO1xuICAgICAgICBpZiAoIWlzSGV4ICYmICFpc09iailcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzaWduYXR1cmUsIGV4cGVjdGVkIFVpbnQ4QXJyYXksIGhleCBzdHJpbmcgb3IgU2lnbmF0dXJlIGluc3RhbmNlJyk7XG4gICAgICAgIGxldCBfc2lnID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgUDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc09iailcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShzZy5yLCBzZy5zKTtcbiAgICAgICAgICAgIGlmIChpc0hleCkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgIT09ICdjb21wYWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZGVyRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3NpZyAmJiBmb3JtYXQgIT09ICdkZXInKVxuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfc2lnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgdmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgY29uc3QgdHY0X2ludiA9IEZwSW52ZXJ0QmF0Y2goRnAsIFt0djRdLCB0cnVlKVswXTtcbiAgICAgICAgeCA9IEZwLm11bCh4LCB0djRfaW52KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsicGlwcGVuZ2VyIiwidmFsaWRhdGVCYXNpYyIsIndOQUYiLCJGaWVsZCIsIkZwSW52ZXJ0QmF0Y2giLCJnZXRNaW5IYXNoTGVuZ3RoIiwiaW52ZXJ0IiwibWFwSGFzaFRvRmllbGQiLCJtb2QiLCJ2YWxpZGF0ZUZpZWxkIiwiYUluUmFuZ2UiLCJhYm9vbCIsImJpdE1hc2siLCJieXRlc1RvSGV4IiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJjcmVhdGVIbWFjRHJiZyIsImVuc3VyZUJ5dGVzIiwiaGV4VG9CeXRlcyIsImluUmFuZ2UiLCJpc0J5dGVzIiwibWVtb2l6ZWQiLCJudW1iZXJUb0J5dGVzQkUiLCJudW1iZXJUb0hleFVucGFkZGVkIiwidmFsaWRhdGVPYmplY3QiLCJ2YWxpZGF0ZVNpZ1Zlck9wdHMiLCJvcHRzIiwibG93UyIsInVuZGVmaW5lZCIsInByZWhhc2giLCJ2YWxpZGF0ZVBvaW50T3B0cyIsImN1cnZlIiwiYSIsImIiLCJhbGxvd0luZmluaXR5UG9pbnQiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJjbGVhckNvZmFjdG9yIiwiZnJvbUJ5dGVzIiwiaXNUb3JzaW9uRnJlZSIsInRvQnl0ZXMiLCJ3cmFwUHJpdmF0ZUtleSIsImVuZG8iLCJGcCIsImVxbCIsIlpFUk8iLCJFcnJvciIsImJldGEiLCJzcGxpdFNjYWxhciIsIk9iamVjdCIsImZyZWV6ZSIsIkRFUkVyciIsImNvbnN0cnVjdG9yIiwibSIsIkRFUiIsIkVyciIsIl90bHYiLCJlbmNvZGUiLCJ0YWciLCJkYXRhIiwiRSIsImxlbmd0aCIsImRhdGFMZW4iLCJsZW4iLCJsZW5MZW4iLCJ0IiwiZGVjb2RlIiwicG9zIiwiZmlyc3QiLCJpc0xvbmciLCJsZW5ndGhCeXRlcyIsInN1YmFycmF5IiwidiIsImwiLCJfaW50IiwibnVtIiwiXzBuIiwiaGV4IiwiTnVtYmVyIiwicGFyc2VJbnQiLCJ0b1NpZyIsImludCIsInRsdiIsInNlcUJ5dGVzIiwic2VxTGVmdEJ5dGVzIiwickJ5dGVzIiwickxlZnRCeXRlcyIsInNCeXRlcyIsInNMZWZ0Qnl0ZXMiLCJyIiwicyIsImhleEZyb21TaWciLCJzaWciLCJycyIsInNzIiwic2VxIiwibnVtVG9TaXplZEhleCIsInNpemUiLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJ3ZWllcnN0cmFzc1BvaW50cyIsIkNVUlZFIiwiRm4iLCJuIiwibkJpdExlbmd0aCIsIl9jIiwicG9pbnQiLCJfaXNDb21wcmVzc2VkIiwidG9BZmZpbmUiLCJVaW50OEFycmF5IiwiZnJvbSIsIngiLCJ5IiwiYnl0ZXMiLCJ0YWlsIiwiQllURVMiLCJ3ZWllcnN0cmFzc0VxdWF0aW9uIiwieDIiLCJzcXIiLCJ4MyIsIm11bCIsImFkZCIsImlzVmFsaWRYWSIsImxlZnQiLCJyaWdodCIsIkd4IiwiR3kiLCJfNGEzIiwicG93IiwiXzI3YjIiLCJpczAiLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwia2V5IiwibGVuZ3RocyIsIm5CeXRlTGVuZ3RoIiwiTiIsImluY2x1ZGVzIiwicGFkU3RhcnQiLCJlcnJvciIsImFwcmpwb2ludCIsIm90aGVyIiwiUG9pbnQiLCJ0b0FmZmluZU1lbW8iLCJwIiwiaXoiLCJweCIsInB5IiwicHoiLCJ6IiwiT05FIiwiaW52IiwiYXgiLCJheSIsInp6IiwiYXNzZXJ0VmFsaWRNZW1vIiwiaXNWYWxpZCIsImZyb21BZmZpbmUiLCJpIiwibm9ybWFsaXplWiIsInBvaW50cyIsInRvSW52IiwibWFwIiwiZnJvbUhleCIsIlAiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsIkJBU0UiLCJtdWx0aXBseSIsIm1zbSIsInNjYWxhcnMiLCJfc2V0V2luZG93U2l6ZSIsIndpbmRvd1NpemUiLCJ3bmFmIiwic2V0V2luZG93U2l6ZSIsImhhc0V2ZW5ZIiwiaXNPZGQiLCJlcXVhbHMiLCJYMSIsIlkxIiwiWjEiLCJYMiIsIlkyIiwiWjIiLCJVMSIsIlUyIiwibmVnYXRlIiwibmVnIiwiZG91YmxlIiwiYjMiLCJYMyIsIlkzIiwiWjMiLCJ0MCIsInQxIiwidDIiLCJ0MyIsInN1YiIsInQ0IiwidDUiLCJzdWJ0cmFjdCIsIndOQUZDYWNoZWQiLCJtdWx0aXBseVVuc2FmZSIsInNjIiwiSSIsImhhc1ByZWNvbXB1dGVzIiwid05BRkNhY2hlZFVuc2FmZSIsImsxbmVnIiwiazEiLCJrMm5lZyIsImsyIiwiazFwIiwiazJwIiwiZCIsInNjYWxhciIsImZha2UiLCJmIiwiZjFwIiwiZjJwIiwiY29uc3RUaW1lTmVnYXRlIiwibXVsdGlwbHlBbmRBZGRVbnNhZmUiLCJRIiwiRyIsInN1bSIsImgiLCJjb2ZhY3RvciIsInRvUmF3Qnl0ZXMiLCJpc0NvbXByZXNzZWQiLCJ0b0hleCIsIk1hdGgiLCJjZWlsIiwiUHJvamVjdGl2ZVBvaW50IiwidmFsaWRhdGVPcHRzIiwiaGFzaCIsImhtYWMiLCJyYW5kb21CeXRlcyIsImJpdHMyaW50IiwiYml0czJpbnRfbW9kTiIsIndlaWVyc3RyYXNzIiwiY3VydmVEZWYiLCJDVVJWRV9PUkRFUiIsImNvbXByZXNzZWRMZW4iLCJ1bmNvbXByZXNzZWRMZW4iLCJtb2ROIiwiaW52TiIsImNhdCIsImhlYWQiLCJPUkRFUiIsInkyIiwic3FydCIsInNxcnRFcnJvciIsInN1ZmZpeCIsIm1lc3NhZ2UiLCJpc1lPZGQiLCJpc0hlYWRPZGQiLCJjbCIsInVsIiwiaXNCaWdnZXJUaGFuSGFsZk9yZGVyIiwibnVtYmVyIiwiSEFMRiIsIm5vcm1hbGl6ZVMiLCJzbGNOdW0iLCJ0byIsInNsaWNlIiwiU2lnbmF0dXJlIiwicmVjb3ZlcnkiLCJmcm9tQ29tcGFjdCIsImZyb21ERVIiLCJhZGRSZWNvdmVyeUJpdCIsInJlY292ZXJQdWJsaWNLZXkiLCJtc2dIYXNoIiwicmVjIiwicmFkaiIsInByZWZpeCIsIlIiLCJpciIsInUxIiwidTIiLCJoYXNIaWdoUyIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RFUkhleCIsInRvQ29tcGFjdFJhd0J5dGVzIiwidG9Db21wYWN0SGV4IiwidXRpbHMiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInJhbmRvbVByaXZhdGVLZXkiLCJwcmVjb21wdXRlIiwiZ2V0UHVibGljS2V5IiwiaXNQcm9iUHViIiwiaXRlbSIsImFyciIsImZwbCIsImNvbXBMZW4iLCJ1bmNvbXBMZW4iLCJnZXRTaGFyZWRTZWNyZXQiLCJwcml2YXRlQSIsInB1YmxpY0IiLCJkZWx0YSIsIk9SREVSX01BU0siLCJpbnQyb2N0ZXRzIiwicHJlcFNpZyIsImRlZmF1bHRTaWdPcHRzIiwic29tZSIsImsiLCJleHRyYUVudHJvcHkiLCJlbnQiLCJoMWludCIsInNlZWRBcmdzIiwiZSIsInB1c2giLCJzZWVkIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsInEiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwic2lnbiIsInByaXZLZXkiLCJDIiwiZHJiZyIsIm91dHB1dExlbiIsInZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInNnIiwiZm9ybWF0IiwiaXNIZXgiLCJpc09iaiIsIl9zaWciLCJkZXJFcnJvciIsImlzIiwiU1dVRnBTcXJ0UmF0aW8iLCJaIiwibyIsImMxIiwiXzJuX3Bvd19jMV8xIiwiXzJuX3Bvd19jMSIsImMyIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsInNxcnRSYXRpbyIsInUiLCJ0djEiLCJ0djIiLCJ0djMiLCJ0djUiLCJ0djQiLCJpc1FSIiwiY21vdiIsInR2djUiLCJlMSIsInZhbHVlIiwieTEiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwiQSIsIkIiLCJ0djYiLCJ0djRfaW52Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1),\n/* harmony export */   secp256k1_hasher: () => (/* binding */ secp256k1_hasher)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\nconst secp256k1P = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\");\nconst secp256k1N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b)=>(a + b / _2n) / b;\n/**\n * ‚àön = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n * ```\n */ const secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: _0n,\n    b: BigInt(7),\n    Fp: Fpk1,\n    n: secp256k1N,\n    Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n    Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n    h: BigInt(1),\n    lowS: true,\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n        splitScalar: (k)=>{\n            const n = secp256k1N;\n            const a1 = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\");\n            const b1 = -_1n * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\");\n            const a2 = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\");\n            const b2 = a1;\n            const POW_2_128 = BigInt(\"0x100000000000000000000000000000000\"); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg) k1 = n - k1;\n            if (k2neg) k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error(\"splitScalar: Endomorphism failed, k=\" + k);\n            }\n            return {\n                k1neg,\n                k1,\n                k2neg,\n                k2\n            };\n        }\n    }\n}, _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toRawBytes(true).slice(1);\nconst numTo32b = (n)=>(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x)=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = /* @__PURE__ */ (()=>secp256k1.ProjectivePoint)();\nconst GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'‚ãÖG; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return {\n        scalar: scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.aInRange)(\"x\", x, _1n, secp256k1P); // Fail if x ‚â• p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x¬≥ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return modN(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'‚â•n. Ret bytes(d'‚ãÖG)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n) throw new Error(\"sign failed: k is zero\"); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'‚ãÖG.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"message\", message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ‚â• p.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(r, _1n, secp256k1P)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ‚â• n.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(s, _1n, secp256k1N)) return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s‚ãÖG - e‚ãÖP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ‚â† r.\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n * ```\n */ const schnorr = /* @__PURE__ */ (()=>({\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        utils: {\n            randomPrivateKey: secp256k1.utils.randomPrivateKey,\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n            bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n            taggedHash,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        }\n    }))();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */ const secp256k1_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\nconst hashToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7OztDQVdDLEdBQ0Qsb0VBQW9FLEdBQ3hCO0FBQ007QUFDRDtBQUNzQjtBQUNkO0FBQzREO0FBQ3JEO0FBQ2hFLE1BQU1lLGFBQWFDLE9BQU87QUFDMUIsTUFBTUMsYUFBYUQsT0FBTztBQUMxQixNQUFNRSxNQUFNRixPQUFPO0FBQ25CLE1BQU1HLE1BQU1ILE9BQU87QUFDbkIsTUFBTUksTUFBTUosT0FBTztBQUNuQixNQUFNSyxhQUFhLENBQUNDLEdBQUdDLElBQU0sQ0FBQ0QsSUFBSUMsSUFBSUgsR0FBRSxJQUFLRztBQUM3Qzs7O0NBR0MsR0FDRCxTQUFTQyxRQUFRQyxDQUFDO0lBQ2QsTUFBTUMsSUFBSVg7SUFDVixrQkFBa0I7SUFDbEIsTUFBTVksTUFBTVgsT0FBTyxJQUFJWSxNQUFNWixPQUFPLElBQUlhLE9BQU9iLE9BQU8sS0FBS2MsT0FBT2QsT0FBTztJQUN6RSxrQkFBa0I7SUFDbEIsTUFBTWUsT0FBT2YsT0FBTyxLQUFLZ0IsT0FBT2hCLE9BQU8sS0FBS2lCLE9BQU9qQixPQUFPO0lBQzFELE1BQU1rQixLQUFLLElBQUtULElBQUlBLElBQUtDLEdBQUcsVUFBVTtJQUN0QyxNQUFNUyxLQUFLLEtBQU1ELEtBQUtULElBQUtDLEdBQUcsTUFBTTtJQUNwQyxNQUFNVSxLQUFLLDJEQUFNRCxJQUFJUixLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNVyxLQUFLLDJEQUFNRCxJQUFJVCxLQUFLRCxLQUFLUyxLQUFNVDtJQUNyQyxNQUFNWSxNQUFNLDJEQUFNRCxJQUFJakIsS0FBS00sS0FBS1EsS0FBTVI7SUFDdEMsTUFBTWEsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUgsS0FBS1ksTUFBT1o7SUFDekMsTUFBTWMsTUFBTSwyREFBTUQsS0FBS1QsTUFBTUosS0FBS2EsTUFBT2I7SUFDekMs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VztRQUNYckQsR0FBR3hELEtBQUs4RyxLQUFLO1FBQ2J0QyxHQUFHO1FBQ0h4RCxHQUFHO1FBQ0grRixRQUFRO1FBQ1JDLE1BQU1oSyxzREFBTUE7SUFDaEIsRUFBQyxJQUFLO0FBQ0MsTUFBTWlLLGNBQThCLGFBQUgsR0FBSSxLQUFNUCxpQkFBaUJPLFdBQVcsSUFBSTtBQUMzRSxNQUFNQyxnQkFBZ0MsYUFBSCxHQUFJLEtBQU1SLGlCQUFpQlEsYUFBYSxJQUFJLENBQ3RGLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbW11bmUtcGFnZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/ZDEyMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE5JU1Qgc2VjcDI1NmsxLiBTZWUgW3BkZl0oaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMi12Mi5wZGYpLlxuICpcbiAqIFNlZW1zIHRvIGJlIHJpZ2lkIChub3QgYmFja2Rvb3JlZClcbiAqIFthcyBwZXIgZGlzY3Vzc2lvbl0oaHR0cHM6Ly9iaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzUpLlxuICpcbiAqIHNlY3AyNTZrMSBiZWxvbmdzIHRvIEtvYmxpdHogY3VydmVzOiBpdCBoYXMgZWZmaWNpZW50bHkgY29tcHV0YWJsZSBlbmRvbW9ycGhpc20uXG4gKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAqIFtTZWUgZXhwbGFuYXRpb25dKGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NikuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tIFwiLi9fc2hvcnR3X3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSBcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpblJhbmdlLCBudW1iZXJUb0J5dGVzQkUsIH0gZnJvbSBcIi4vYWJzdHJhY3QvdXRpbHMuanNcIjtcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcGsxLmVxbChGcGsxLnNxcihyb290KSwgeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICByZXR1cm4gcm9vdDtcbn1cbmNvbnN0IEZwazEgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuLyoqXG4gKiBzZWNwMjU2azEgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuXG4gKlxuICogRmllbGQ6IGAybioqMjU2biAtIDJuKiozMm4gLSAybioqOW4gLSAybioqOG4gLSAybioqN24gLSAybioqNm4gLSAybioqNG4gLSAxbmBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogY29uc3QgcHViID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleShwcml2KTtcbiAqIGNvbnN0IG1zZyA9IG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDEpOyAvLyBtZXNzYWdlIGhhc2ggKG5vdCBtZXNzYWdlKSBpbiBlY2RzYVxuICogY29uc3Qgc2lnID0gc2VjcDI1NmsxLnNpZ24obXNnLCBwcml2KTsgLy8gYHtwcmVoYXNoOiB0cnVlfWAgb3B0aW9uIGlzIGF2YWlsYWJsZVxuICogY29uc3QgaXNWYWxpZCA9IHNlY3AyNTZrMS52ZXJpZnkoc2lnLCBtc2csIHB1YikgPT09IHRydWU7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBfMG4sXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwOiBGcGsxLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgZW5kbzoge1xuICAgICAgICAvLyBFbmRvbW9ycGhpc20sIHNlZSBhYm92ZVxuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbi8qKiBBbiBvYmplY3QgbWFwcGluZyB0YWdzIHRvIHRoZWlyIHRhZ2dlZCBoYXNoIHByZWZpeCBvZiBbU0hBMjU2KHRhZykgfCBTSEEyNTYodGFnKV0gKi9cbmNvbnN0IFRBR0dFRF9IQVNIX1BSRUZJWEVTID0ge307XG5mdW5jdGlvbiB0YWdnZWRIYXNoKHRhZywgLi4ubWVzc2FnZXMpIHtcbiAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0YWdIID0gc2hhMjU2KFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvUmF3Qnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBudW1UbzMyYiA9IChuKSA9PiBudW1iZXJUb0J5dGVzQkUobiwgMzIpO1xuY29uc3QgbW9kUCA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxUCk7XG5jb25zdCBtb2ROID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFOKTtcbmNvbnN0IFBvaW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50KSgpO1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgYUluUmFuZ2UoJ3gnLCB4LCBfMW4sIHNlY3AyNTZrMVApOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFO1xuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4obnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gbnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKG51bShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChudW0ocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gbnVtKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghaW5SYW5nZShyLCBfMW4sIHNlY3AyNTZrMVApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFpblJhbmdlKHMsIF8xbiwgc2VjcDI1NmsxTikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHByaXYgPSBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqIGNvbnN0IHB1YiA9IHNjaG5vcnIuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgcHJpdik7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2Nobm9yci52ZXJpZnkoc2lnLCBtc2csIHB1Yik7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwazEsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnBrMSwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gc2VjcDI1NmsxIHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMV9oYXNoZXIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHNlY3AyNTZrMV9oYXNoZXIuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gc2VjcDI1NmsxX2hhc2hlci5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6WyJzaGEyNTYiLCJyYW5kb21CeXRlcyIsImNyZWF0ZUN1cnZlIiwiY3JlYXRlSGFzaGVyIiwiaXNvZ2VueU1hcCIsIkZpZWxkIiwibW9kIiwicG93MiIsImFJblJhbmdlIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJlbnN1cmVCeXRlcyIsImluUmFuZ2UiLCJudW1iZXJUb0J5dGVzQkUiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwic2VjcDI1NmsxUCIsIkJpZ0ludCIsInNlY3AyNTZrMU4iLCJfMG4iLCJfMW4iLCJfMm4iLCJkaXZOZWFyZXN0IiwiYSIsImIiLCJzcXJ0TW9kIiwieSIsIlAiLCJfM24iLCJfNm4iLCJfMTFuIiwiXzIybiIsIl8yM24iLCJfNDRuIiwiXzg4biIsImIyIiwiYjMiLCJiNiIsImI5IiwiYjExIiwiYjIyIiwiYjQ0IiwiYjg4IiwiYjE3NiIsImIyMjAiLCJiMjIzIiwidDEiLCJ0MiIsInJvb3QiLCJGcGsxIiwiZXFsIiwic3FyIiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJzcXJ0Iiwic2VjcDI1NmsxIiwiRnAiLCJuIiwiR3giLCJHeSIsImgiLCJsb3dTIiwiZW5kbyIsImJldGEiLCJzcGxpdFNjYWxhciIsImsiLCJhMSIsImIxIiwiYTIiLCJQT1dfMl8xMjgiLCJjMSIsImMyIiwiazEiLCJrMiIsImsxbmVnIiwiazJuZWciLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJ0YWciLCJtZXNzYWdlcyIsInRhZ1AiLCJ0YWdIIiwiVWludDhBcnJheSIsImZyb20iLCJjIiwiY2hhckNvZGVBdCIsInBvaW50VG9CeXRlcyIsInBvaW50IiwidG9SYXdCeXRlcyIsInNsaWNlIiwibnVtVG8zMmIiLCJtb2RQIiwieCIsIm1vZE4iLCJQb2ludCIsIlByb2plY3RpdmVQb2ludCIsIkdtdWxBZGQiLCJRIiwiQkFTRSIsIm11bHRpcGx5QW5kQWRkVW5zYWZlIiwic2Nobm9yckdldEV4dFB1YktleSIsInByaXYiLCJkXyIsInV0aWxzIiwibm9ybVByaXZhdGVLZXlUb1NjYWxhciIsInAiLCJmcm9tUHJpdmF0ZUtleSIsInNjYWxhciIsImhhc0V2ZW5ZIiwiYnl0ZXMiLCJsaWZ0X3giLCJ4eCIsImFzc2VydFZhbGlkaXR5IiwibnVtIiwiY2hhbGxlbmdlIiwiYXJncyIsInNjaG5vcnJHZXRQdWJsaWNLZXkiLCJwcml2YXRlS2V5Iiwic2Nobm9yclNpZ24iLCJtZXNzYWdlIiwiYXV4UmFuZCIsIm0iLCJweCIsImQiLCJ0IiwicmFuZCIsImtfIiwicngiLCJlIiwic2lnIiwic2V0Iiwic2Nobm9yclZlcmlmeSIsInNpZ25hdHVyZSIsInB1YmxpY0tleSIsInB1YiIsInIiLCJzdWJhcnJheSIsInMiLCJSIiwidG9BZmZpbmUiLCJlcnJvciIsInNjaG5vcnIiLCJnZXRQdWJsaWNLZXkiLCJzaWduIiwidmVyaWZ5IiwicmFuZG9tUHJpdmF0ZUtleSIsImlzb01hcCIsIm1hcCIsImkiLCJqIiwibWFwU1dVIiwiQSIsIkIiLCJaIiwiY3JlYXRlIiwic2VjcDI1NmsxX2hhc2hlciIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_blake.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_blake.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BSIGMA: () => (/* binding */ BSIGMA),\n/* harmony export */   G1s: () => (/* binding */ G1s),\n/* harmony export */   G2s: () => (/* binding */ G2s)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal helpers for blake hash.\n * @module\n */ \n/**\n * Internal blake variable.\n * For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n */ // prettier-ignore\nconst BSIGMA = /* @__PURE__ */ Uint8Array.from([\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    14,\n    10,\n    4,\n    8,\n    9,\n    15,\n    13,\n    6,\n    1,\n    12,\n    0,\n    2,\n    11,\n    7,\n    5,\n    3,\n    11,\n    8,\n    12,\n    0,\n    5,\n    2,\n    15,\n    13,\n    10,\n    14,\n    3,\n    6,\n    7,\n    1,\n    9,\n    4,\n    7,\n    9,\n    3,\n    1,\n    13,\n    12,\n    11,\n    14,\n    2,\n    6,\n    5,\n    10,\n    4,\n    0,\n    15,\n    8,\n    9,\n    0,\n    5,\n    7,\n    2,\n    4,\n    10,\n    15,\n    14,\n    1,\n    11,\n    12,\n    6,\n    8,\n    3,\n    13,\n    2,\n    12,\n    6,\n    10,\n    0,\n    11,\n    8,\n    3,\n    4,\n    13,\n    7,\n    5,\n    15,\n    14,\n    1,\n    9,\n    12,\n    5,\n    1,\n    15,\n    14,\n    13,\n    4,\n    10,\n    0,\n    7,\n    6,\n    3,\n    9,\n    2,\n    8,\n    11,\n    13,\n    11,\n    7,\n    14,\n    12,\n    1,\n    3,\n    9,\n    5,\n    0,\n    15,\n    4,\n    8,\n    6,\n    2,\n    10,\n    6,\n    15,\n    14,\n    9,\n    11,\n    3,\n    0,\n    8,\n    12,\n    2,\n    13,\n    7,\n    1,\n    4,\n    10,\n    5,\n    10,\n    2,\n    8,\n    4,\n    7,\n    6,\n    1,\n    5,\n    15,\n    11,\n    9,\n    14,\n    3,\n    12,\n    13,\n    0,\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    14,\n    10,\n    4,\n    8,\n    9,\n    15,\n    13,\n    6,\n    1,\n    12,\n    0,\n    2,\n    11,\n    7,\n    5,\n    3,\n    // Blake1, unused in others\n    11,\n    8,\n    12,\n    0,\n    5,\n    2,\n    15,\n    13,\n    10,\n    14,\n    3,\n    6,\n    7,\n    1,\n    9,\n    4,\n    7,\n    9,\n    3,\n    1,\n    13,\n    12,\n    11,\n    14,\n    2,\n    6,\n    5,\n    10,\n    4,\n    0,\n    15,\n    8,\n    9,\n    0,\n    5,\n    7,\n    2,\n    4,\n    10,\n    15,\n    14,\n    1,\n    11,\n    12,\n    6,\n    8,\n    3,\n    13,\n    2,\n    12,\n    6,\n    10,\n    0,\n    11,\n    8,\n    3,\n    4,\n    13,\n    7,\n    5,\n    15,\n    14,\n    1,\n    9\n]);\n// Mixing function G splitted in two halfs\nfunction G1s(a, b, c, d, x) {\n    a = a + b + x | 0;\n    d = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotr)(d ^ a, 16);\n    c = c + d | 0;\n    b = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotr)(b ^ c, 12);\n    return {\n        a,\n        b,\n        c,\n        d\n    };\n}\nfunction G2s(a, b, c, d, x) {\n    a = a + b + x | 0;\n    d = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotr)(d ^ a, 8);\n    c = c + d | 0;\n    b = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.rotr)(b ^ c, 7);\n    return {\n        a,\n        b,\n        c,\n        d\n    };\n} //# sourceMappingURL=_blake.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2JsYWtlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FDaUM7QUFDbEM7OztDQUdDLEdBQ0Qsa0JBQWtCO0FBQ1gsTUFBTUMsU0FBUyxhQUFhLEdBQUdDLFdBQVdDLElBQUksQ0FBQztJQUNsRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUNsRDtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUNuRDtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNuRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUNuRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUNsRDtJQUFHO0lBQUk7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBRztJQUNuRDtJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNsRDtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBRztJQUNsRDtJQUFHO0lBQUk7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUNuRDtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBSTtJQUNuRDtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUNsRDtJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUFJO0lBQUc7SUFBRztJQUNuRCwyQkFBMkI7SUFDM0I7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBSTtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFDbkQ7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFJO0lBQUk7SUFBSTtJQUFJO0lBQUc7SUFBRztJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUk7SUFDbkQ7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUk7SUFBRztJQUFJO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFDbEQ7SUFBRztJQUFJO0lBQUc7SUFBSTtJQUFHO0lBQUk7SUFBRztJQUFHO0lBQUc7SUFBSTtJQUFHO0lBQUc7SUFBSTtJQUFJO0lBQUc7Q0FDdEQsRUFBRTtBQUNILDBDQUEwQztBQUNuQyxTQUFTQyxJQUFJQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDN0JKLElBQUksSUFBS0MsSUFBSUcsSUFBSztJQUNsQkQsSUFBSVIsK0NBQUlBLENBQUNRLElBQUlILEdBQUc7SUFDaEJFLElBQUksSUFBS0MsSUFBSztJQUNkRixJQUFJTiwrQ0FBSUEsQ0FBQ00sSUFBSUMsR0FBRztJQUNoQixPQUFPO1FBQUVGO1FBQUdDO1FBQUdDO1FBQUdDO0lBQUU7QUFDeEI7QUFDTyxTQUFTRSxJQUFJTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDN0JKLElBQUksSUFBS0MsSUFBSUcsSUFBSztJQUNsQkQsSUFBSVIsK0NBQUlBLENBQUNRLElBQUlILEdBQUc7SUFDaEJFLElBQUksSUFBS0MsSUFBSztJQUNkRixJQUFJTiwrQ0FBSUEsQ0FBQ00sSUFBSUMsR0FBRztJQUNoQixPQUFPO1FBQUVGO1FBQUdDO1FBQUdDO1FBQUdDO0lBQUU7QUFDeEIsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21tdW5lLXBhZ2UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2JsYWtlLmpzP2VmODIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzIGZvciBibGFrZSBoYXNoLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyByb3RyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKlxuICogSW50ZXJuYWwgYmxha2UgdmFyaWFibGUuXG4gKiBGb3IgQkxBS0UyYiwgdGhlIHR3byBleHRyYSBwZXJtdXRhdGlvbnMgZm9yIHJvdW5kcyAxMCBhbmQgMTEgYXJlIFNJR01BWzEwLi4xMV0gPSBTSUdNQVswLi4xXS5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgY29uc3QgQlNJR01BID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSxcbiAgICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAgIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gICAgNywgOSwgMywgMSwgMTMsIDEyLCAxMSwgMTQsIDIsIDYsIDUsIDEwLCA0LCAwLCAxNSwgOCxcbiAgICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAgIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gICAgMTIsIDUsIDEsIDE1LCAxNCwgMTMsIDQsIDEwLCAwLCA3LCA2LCAzLCA5LCAyLCA4LCAxMSxcbiAgICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICAgIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gICAgMTAsIDIsIDgsIDQsIDcsIDYsIDEsIDUsIDE1LCAxMSwgOSwgMTQsIDMsIDEyLCAxMywgMCxcbiAgICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAgIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gICAgLy8gQmxha2UxLCB1bnVzZWQgaW4gb3RoZXJzXG4gICAgMTEsIDgsIDEyLCAwLCA1LCAyLCAxNSwgMTMsIDEwLCAxNCwgMywgNiwgNywgMSwgOSwgNCxcbiAgICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICAgIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gICAgMiwgMTIsIDYsIDEwLCAwLCAxMSwgOCwgMywgNCwgMTMsIDcsIDUsIDE1LCAxNCwgMSwgOSxcbl0pO1xuLy8gTWl4aW5nIGZ1bmN0aW9uIEcgc3BsaXR0ZWQgaW4gdHdvIGhhbGZzXG5leHBvcnQgZnVuY3Rpb24gRzFzKGEsIGIsIGMsIGQsIHgpIHtcbiAgICBhID0gKGEgKyBiICsgeCkgfCAwO1xuICAgIGQgPSByb3RyKGQgXiBhLCAxNik7XG4gICAgYyA9IChjICsgZCkgfCAwO1xuICAgIGIgPSByb3RyKGIgXiBjLCAxMik7XG4gICAgcmV0dXJuIHsgYSwgYiwgYywgZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEcycyhhLCBiLCBjLCBkLCB4KSB7XG4gICAgYSA9IChhICsgYiArIHgpIHwgMDtcbiAgICBkID0gcm90cihkIF4gYSwgOCk7XG4gICAgYyA9IChjICsgZCkgfCAwO1xuICAgIGIgPSByb3RyKGIgXiBjLCA3KTtcbiAgICByZXR1cm4geyBhLCBiLCBjLCBkIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYmxha2UuanMubWFwIl0sIm5hbWVzIjpbInJvdHIiLCJCU0lHTUEiLCJVaW50OEFycmF5IiwiZnJvbSIsIkcxcyIsImEiLCJiIiwiYyIsImQiLCJ4IiwiRzJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_blake.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_md.js":
/*!***********************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_md.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   SHA224_IV: () => (/* binding */ SHA224_IV),\n/* harmony export */   SHA256_IV: () => (/* binding */ SHA256_IV),\n/* harmony export */   SHA384_IV: () => (/* binding */ SHA384_IV),\n/* harmony export */   SHA512_IV: () => (/* binding */ SHA512_IV),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */ \n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === \"function\") return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number(value >> _32n & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */ function Chi(a, b, c) {\n    return a & b ^ ~a & c;\n}\n/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {\n    return a & b ^ a & c ^ b & c;\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */ class HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE){\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for(let pos = 0; pos < len;){\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 128;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for(let i = pos; i < blockLen; i++)buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen) to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ const SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667,\n    0xbb67ae85,\n    0x3c6ef372,\n    0xa54ff53a,\n    0x510e527f,\n    0x9b05688c,\n    0x1f83d9ab,\n    0x5be0cd19\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ const SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8,\n    0x367cd507,\n    0x3070dd17,\n    0xf70e5939,\n    0xffc00b31,\n    0x68581511,\n    0x64f98fa7,\n    0xbefa4fa4\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ const SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d,\n    0xc1059ed8,\n    0x629a292a,\n    0x367cd507,\n    0x9159015a,\n    0x3070dd17,\n    0x152fecd8,\n    0xf70e5939,\n    0x67332667,\n    0xffc00b31,\n    0x8eb44a87,\n    0x68581511,\n    0xdb0c2e0d,\n    0x64f98fa7,\n    0x47b5481d,\n    0xbefa4fa4\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ const SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667,\n    0xf3bcc908,\n    0xbb67ae85,\n    0x84caa73b,\n    0x3c6ef372,\n    0xfe94f82b,\n    0xa54ff53a,\n    0x5f1d36f1,\n    0x510e527f,\n    0xade682d1,\n    0x9b05688c,\n    0x2b3e6c1f,\n    0x1f83d9ab,\n    0xfb41bd6b,\n    0x5be0cd19,\n    0x137e2179\n]); //# sourceMappingURL=_md.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUN1RjtBQUN4Riw4RkFBOEYsR0FDdkYsU0FBU08sYUFBYUMsSUFBSSxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRUMsSUFBSTtJQUN0RCxJQUFJLE9BQU9ILEtBQUtELFlBQVksS0FBSyxZQUM3QixPQUFPQyxLQUFLRCxZQUFZLENBQUNFLFlBQVlDLE9BQU9DO0lBQ2hELE1BQU1DLE9BQU9DLE9BQU87SUFDcEIsTUFBTUMsV0FBV0QsT0FBTztJQUN4QixNQUFNRSxLQUFLQyxPQUFPLFNBQVVKLE9BQVFFO0lBQ3BDLE1BQU1HLEtBQUtELE9BQU9OLFFBQVFJO0lBQzFCLE1BQU1JLElBQUlQLE9BQU8sSUFBSTtJQUNyQixNQUFNUSxJQUFJUixPQUFPLElBQUk7SUFDckJILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVMsR0FBR0gsSUFBSUo7SUFDbkNILEtBQUtZLFNBQVMsQ0FBQ1gsYUFBYVUsR0FBR0YsSUFBSU47QUFDdkM7QUFDQSxzQkFBc0IsR0FDZixTQUFTVSxJQUFJQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUN2QixPQUFPLElBQUtELElBQU0sQ0FBQ0QsSUFBSUU7QUFDM0I7QUFDQSx1REFBdUQsR0FDaEQsU0FBU0MsSUFBSUgsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDdkIsT0FBTyxJQUFLRCxJQUFNRCxJQUFJRSxJQUFNRCxJQUFJQztBQUNwQztBQUNBOzs7Q0FHQyxHQUNNLE1BQU1FLGVBQWUxQiwyQ0FBSUE7SUFDNUIyQixZQUFZQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFbkIsSUFBSSxDQUFFO1FBQzlDLEtBQUs7UUFDTCxJQUFJLENBQUNvQixRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNDLEdBQUcsR0FBRztRQUNY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WTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGLEVBQUU7QUFDSCw0RUFBNEUsR0FDckUsTUFBTUMsWUFBWSxhQUFhLEdBQUdGLFlBQVlDLElBQUksQ0FBQztJQUN0RDtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGLEVBQUU7QUFDSCwyRUFBMkUsR0FDcEUsTUFBTUUsWUFBWSxhQUFhLEdBQUdILFlBQVlDLElBQUksQ0FBQztJQUN0RDtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7Q0FDdkYsRUFBRTtBQUNILDBFQUEwRSxHQUNuRSxNQUFNRyxZQUFZLGFBQWEsR0FBR0osWUFBWUMsSUFBSSxDQUFDO0lBQ3REO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RixFQUFFLENBQ0gsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tbXVuZS1wYWdlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcz9hMDg3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgTWVya2xlLURhbWdhcmQgaGFzaCB1dGlscy5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgSGFzaCwgYWJ5dGVzLCBhZXhpc3RzLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKiogUG9seWZpbGwgZm9yIFNhZmFyaSAxNC4gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19kYXRhdmlld19zZXRiaWd1aW50NjQgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLyoqIENob2ljZTogYSA/IGIgOiBjICovXG5leHBvcnQgZnVuY3Rpb24gQ2hpKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgJiBiKSBeICh+YSAmIGMpO1xufVxuLyoqIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXRzIGlzIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gTWFqKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xufVxuLyoqXG4gKiBNZXJrbGUtRGFtZ2FyZCBoYXNoIGNvbnN0cnVjdGlvbiBiYXNlIGNsYXNzLlxuICogQ291bGQgYmUgdXNlZCB0byBjcmVhdGUgTUQ1LCBSSVBFTUQsIFNIQTEsIFNIQTIuXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNoTUQgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKSk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG4vKipcbiAqIEluaXRpYWwgU0hBLTIgc3RhdGU6IGZyYWN0aW9uYWwgcGFydHMgb2Ygc3F1YXJlIHJvb3RzIG9mIGZpcnN0IDE2IHByaW1lcyAyLi41My5cbiAqIENoZWNrIG91dCBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYCBmb3IgcmVjb21wdXRhdGlvbiBndWlkZS5cbiAqL1xuLyoqIEluaXRpYWwgU0hBMjU2IHN0YXRlLiBCaXRzIDAuLjMyIG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEyMjQgc3RhdGUuIEJpdHMgMzIuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyMy4uNTMgKi9cbmV4cG9ydCBjb25zdCBTSEEyMjRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSwgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCxcbl0pO1xuLyoqIEluaXRpYWwgU0hBMzg0IHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyMy4uNTMgKi9cbmV4cG9ydCBjb25zdCBTSEEzODRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCwgMHg2MjlhMjkyYSwgMHgzNjdjZDUwNywgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNywgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLCAweDhlYjQ0YTg3LCAweDY4NTgxNTExLCAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LCAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEE1MTIgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBNTEyX0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG4gICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSwgMHg5YjA1Njg4YywgMHgyYjNlNmMxZiwgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiwgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSxcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6WyJIYXNoIiwiYWJ5dGVzIiwiYWV4aXN0cyIsImFvdXRwdXQiLCJjbGVhbiIsImNyZWF0ZVZpZXciLCJ0b0J5dGVzIiwic2V0QmlnVWludDY0IiwidmlldyIsImJ5dGVPZmZzZXQiLCJ2YWx1ZSIsImlzTEUiLCJfMzJuIiwiQmlnSW50IiwiX3UzMl9tYXgiLCJ3aCIsIk51bWJlciIsIndsIiwiaCIsImwiLCJzZXRVaW50MzIiLCJDaGkiLCJhIiwiYiIsImMiLCJNYWoiLCJIYXNoTUQiLCJjb25zdHJ1Y3RvciIsImJsb2NrTGVuIiwib3V0cHV0TGVuIiwicGFkT2Zmc2V0IiwiZmluaXNoZWQiLCJsZW5ndGgiLCJwb3MiLCJkZXN0cm95ZWQiLCJidWZmZXIiLCJVaW50OEFycmF5IiwidXBkYXRlIiwiZGF0YSIsImxlbiIsInRha2UiLCJNYXRoIiwibWluIiwiZGF0YVZpZXciLCJwcm9jZXNzIiwic2V0Iiwic3ViYXJyYXkiLCJyb3VuZENsZWFuIiwiZGlnZXN0SW50byIsIm91dCIsImkiLCJvdmlldyIsIkVycm9yIiwib3V0TGVuIiwic3RhdGUiLCJnZXQiLCJkaWdlc3QiLCJyZXMiLCJzbGljZSIsImRlc3Ryb3kiLCJfY2xvbmVJbnRvIiwidG8iLCJjbG9uZSIsIlNIQTI1Nl9JViIsIlVpbnQzMkFycmF5IiwiZnJvbSIsIlNIQTIyNF9JViIsIlNIQTM4NF9JViIsIlNIQTUxMl9JViJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le) return {\n        h: Number(n & U32_MASK64),\n        l: Number(n >> _32n & U32_MASK64)\n    };\n    return {\n        h: Number(n >> _32n & U32_MASK64) | 0,\n        l: Number(n & U32_MASK64) | 0\n    };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for(let i = 0; i < len; i++){\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [\n            h,\n            l\n        ];\n    }\n    return [\n        Ah,\n        Al\n    ];\n}\nconst toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s)=>h >>> s;\nconst shrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s)=>h >>> s | l << 32 - s;\nconst rotrSL = (h, l, s)=>h << 32 - s | l >>> s;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;\nconst rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l)=>l;\nconst rotr32L = (h, _l)=>h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s)=>h << s | l >>> 32 - s;\nconst rotlSL = (h, l, s)=>l << s | h >>> 32 - s;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;\nconst rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return {\n        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,\n        l: l | 0\n    };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\nconst add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig,\n    split,\n    toBig,\n    shrSH,\n    shrSL,\n    rotrSH,\n    rotrSL,\n    rotrBH,\n    rotrBL,\n    rotr32H,\n    rotr32L,\n    rotlSH,\n    rotlSL,\n    rotlBH,\n    rotlBL,\n    add,\n    add3L,\n    add3H,\n    add4L,\n    add4H,\n    add5H,\n    add5L\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64); //# sourceMappingURL=_u64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxNQUFNQSxhQUFhLGFBQWEsR0FBR0MsT0FBTyxLQUFLLEtBQUs7QUFDcEQsTUFBTUMsT0FBTyxhQUFhLEdBQUdELE9BQU87QUFDcEMsU0FBU0UsUUFBUUMsQ0FBQyxFQUFFQyxLQUFLLEtBQUs7SUFDMUIsSUFBSUEsSUFDQSxPQUFPO1FBQUVDLEdBQUdDLE9BQU9ILElBQUlKO1FBQWFRLEdBQUdELE9BQU8sS0FBTUwsT0FBUUY7SUFBWTtJQUM1RSxPQUFPO1FBQUVNLEdBQUdDLE9BQU8sS0FBTUwsT0FBUUYsY0FBYztRQUFHUSxHQUFHRCxPQUFPSCxJQUFJSixjQUFjO0lBQUU7QUFDcEY7QUFDQSxTQUFTUyxNQUFNQyxHQUFHLEVBQUVMLEtBQUssS0FBSztJQUMxQixNQUFNTSxNQUFNRCxJQUFJRSxNQUFNO0lBQ3RCLElBQUlDLEtBQUssSUFBSUMsWUFBWUg7SUFDekIsSUFBSUksS0FBSyxJQUFJRCxZQUFZSDtJQUN6QixJQUFLLElBQUlLLElBQUksR0FBR0EsSUFBSUwsS0FBS0ssSUFBSztRQUMxQixNQUFNLEVBQUVWLENBQUMsRUFBRUUsQ0FBQyxFQUFFLEdBQUdMLFFBQVFPLEdBQUcsQ0FBQ00sRUFBRSxFQUFFWDtRQUNqQyxDQUFDUSxFQUFFLENBQUNHLEVBQUUsRUFBRUQsRUFBRSxDQUFDQyxFQUFFLENBQUMsR0FBRztZQUFDVjtZQUFHRTtTQUFFO0lBQzNCO0lBQ0EsT0FBTztRQUFDSztRQUFJRTtLQUFHO0FBQ25CO0FBQ0EsTUFBTUUsUUFBUSxDQUFDWCxHQUFHRSxJQUFNLE9BQVFGLE1BQU0sTUFBTUosT0FBUUQsT0FBT08sTUFBTTtBQUNqRSx1QkFBdUI7QUFDdkIsTUFBTVUsUUFBUSxDQUFDWixHQUFHYSxJQUFJQyxJQUFNZCxNQUFNYztBQUNsQyxNQUFNQyxRQUFR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LCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21tdW5lLXBhZ2UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcz83ZGMwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgaGVscGVycyBmb3IgdTY0LiBCaWdVaW50NjRBcnJheSBpcyB0b28gc2xvdyBhcyBwZXIgMjAyNSwgc28gd2UgaW1wbGVtZW50IGl0IHVzaW5nIFVpbnQzMkFycmF5LlxuICogQHRvZG8gcmUtY2hlY2sgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MjIxMjU4OFxuICogQG1vZHVsZVxuICovXG5jb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0gbHN0Lmxlbmd0aDtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90ckJIID0gKGgsIGwsIHMpID0+IChoIDw8ICg2NCAtIHMpKSB8IChsID4+PiAocyAtIDMyKSk7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IHsgYWRkLCBhZGQzSCwgYWRkM0wsIGFkZDRILCBhZGQ0TCwgYWRkNUgsIGFkZDVMLCBmcm9tQmlnLCByb3RsQkgsIHJvdGxCTCwgcm90bFNILCByb3RsU0wsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdHJCSCwgcm90ckJMLCByb3RyU0gsIHJvdHJTTCwgc2hyU0gsIHNoclNMLCBzcGxpdCwgdG9CaWcgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6WyJVMzJfTUFTSzY0IiwiQmlnSW50IiwiXzMybiIsImZyb21CaWciLCJuIiwibGUiLCJoIiwiTnVtYmVyIiwibCIsInNwbGl0IiwibHN0IiwibGVuIiwibGVuZ3RoIiwiQWgiLCJVaW50MzJBcnJheSIsIkFsIiwiaSIsInRvQmlnIiwic2hyU0giLCJfbCIsInMiLCJzaHJTTCIsInJvdHJTSCIsInJvdHJTTCIsInJvdHJCSCIsInJvdHJCTCIsInJvdHIzMkgiLCJfaCIsInJvdHIzMkwiLCJyb3RsU0giLCJyb3RsU0wiLCJyb3RsQkgiLCJyb3RsQkwiLCJhZGQiLCJCaCIsIkJsIiwiYWRkM0wiLCJDbCIsImFkZDNIIiwibG93IiwiQ2giLCJhZGQ0TCIsIkRsIiwiYWRkNEgiLCJEaCIsImFkZDVMIiwiRWwiLCJhZGQ1SCIsIkVoIiwidTY0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/blake2.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/blake2.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLAKE2: () => (/* binding */ BLAKE2),\n/* harmony export */   BLAKE2b: () => (/* binding */ BLAKE2b),\n/* harmony export */   BLAKE2s: () => (/* binding */ BLAKE2s),\n/* harmony export */   blake2b: () => (/* binding */ blake2b),\n/* harmony export */   blake2s: () => (/* binding */ blake2s),\n/* harmony export */   compress: () => (/* binding */ compress)\n/* harmony export */ });\n/* harmony import */ var _blake_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_blake.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_blake.js\");\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * blake2b (64-bit) & blake2s (8 to 32-bit) hash functions.\n * b could have been faster, but there is no fast u64 in js, so s is 1.5x faster.\n * @module\n */ \n\n\n// prettier-ignore\n\n// Same as SHA512_IV, but swapped endianness: LE instead of BE. iv[1] is iv[0], etc.\nconst B2B_IV = /* @__PURE__ */ Uint32Array.from([\n    0xf3bcc908,\n    0x6a09e667,\n    0x84caa73b,\n    0xbb67ae85,\n    0xfe94f82b,\n    0x3c6ef372,\n    0x5f1d36f1,\n    0xa54ff53a,\n    0xade682d1,\n    0x510e527f,\n    0x2b3e6c1f,\n    0x9b05688c,\n    0xfb41bd6b,\n    0x1f83d9ab,\n    0x137e2179,\n    0x5be0cd19\n]);\n// Temporary buffer\nconst BBUF = /* @__PURE__ */ new Uint32Array(32);\n// Mixing function G splitted in two halfs\nfunction G1b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add3L(Al, Bl, Xl);\n    Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 32)\n    ({ Dh, Dl } = {\n        Dh: Dh ^ Ah,\n        Dl: Dl ^ Al\n    });\n    ({ Dh, Dl } = {\n        Dh: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotr32H(Dh, Dl),\n        Dl: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotr32L(Dh, Dl)\n    });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 24)\n    ({ Bh, Bl } = {\n        Bh: Bh ^ Ch,\n        Bl: Bl ^ Cl\n    });\n    ({ Bh, Bl } = {\n        Bh: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrSH(Bh, Bl, 24),\n        Bl: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrSL(Bh, Bl, 24)\n    });\n    BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;\n    BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;\n    BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;\n    BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;\n}\nfunction G2b(a, b, c, d, msg, x) {\n    // NOTE: V is LE here\n    const Xl = msg[x], Xh = msg[x + 1]; // prettier-ignore\n    let Al = BBUF[2 * a], Ah = BBUF[2 * a + 1]; // prettier-ignore\n    let Bl = BBUF[2 * b], Bh = BBUF[2 * b + 1]; // prettier-ignore\n    let Cl = BBUF[2 * c], Ch = BBUF[2 * c + 1]; // prettier-ignore\n    let Dl = BBUF[2 * d], Dh = BBUF[2 * d + 1]; // prettier-ignore\n    // v[a] = (v[a] + v[b] + x) | 0;\n    let ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add3L(Al, Bl, Xl);\n    Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add3H(ll, Ah, Bh, Xh);\n    Al = ll | 0;\n    // v[d] = rotr(v[d] ^ v[a], 16)\n    ({ Dh, Dl } = {\n        Dh: Dh ^ Ah,\n        Dl: Dl ^ Al\n    });\n    ({ Dh, Dl } = {\n        Dh: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrSH(Dh, Dl, 16),\n        Dl: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrSL(Dh, Dl, 16)\n    });\n    // v[c] = (v[c] + v[d]) | 0;\n    ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__.add(Ch, Cl, Dh, Dl));\n    // v[b] = rotr(v[b] ^ v[c], 63)\n    ({ Bh, Bl } = {\n        Bh: Bh ^ Ch,\n        Bl: Bl ^ Cl\n    });\n    ({ Bh, Bl } = {\n        Bh: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrBH(Bh, Bl, 63),\n        Bl: _u64_js__WEBPACK_IMPORTED_MODULE_0__.rotrBL(Bh, Bl, 63)\n    });\n    BBUF[2 * a] = Al, BBUF[2 * a + 1] = Ah;\n    BBUF[2 * b] = Bl, BBUF[2 * b + 1] = Bh;\n    BBUF[2 * c] = Cl, BBUF[2 * c + 1] = Ch;\n    BBUF[2 * d] = Dl, BBUF[2 * d + 1] = Dh;\n}\nfunction checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error(\"outputLen bigger than keyLen\");\n    const { key, salt, personalization } = opts;\n    if (key !== undefined && (key.length < 1 || key.length > keyLen)) throw new Error(\"key length must be undefined or 1..\" + keyLen);\n    if (salt !== undefined && salt.length !== saltLen) throw new Error(\"salt must be undefined or \" + saltLen);\n    if (personalization !== undefined && personalization.length !== persLen) throw new Error(\"personalization must be undefined or \" + persLen);\n}\n/** Class, from which others are subclassed. */ class BLAKE2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        this.length = 0;\n        this.pos = 0;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(blockLen);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(outputLen);\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.buffer = new Uint8Array(blockLen);\n        this.buffer32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(data);\n        // Main difference with other hashes: there is flag for last block,\n        // so we cannot process current block before we know that there\n        // is the next one. This significantly complicates logic and reduces ability\n        // to do zero-copy processing\n        const { blockLen, buffer, buffer32 } = this;\n        const len = data.length;\n        const offset = data.byteOffset;\n        const buf = data.buffer;\n        for(let pos = 0; pos < len;){\n            // If buffer is full and we still have input (don't process last block, same as blake2s)\n            if (this.pos === blockLen) {\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(buffer32);\n                this.compress(buffer32, 0, false);\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(buffer32);\n                this.pos = 0;\n            }\n            const take = Math.min(blockLen - this.pos, len - pos);\n            const dataOffset = offset + pos;\n            // full block && aligned to 4 bytes && not last in input\n            if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n                const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(data32);\n                for(let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen){\n                    this.length += blockLen;\n                    this.compress(data32, pos32, false);\n                }\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(data32);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            this.length += take;\n            pos += take;\n        }\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        const { pos, buffer32 } = this;\n        this.finished = true;\n        // Padding\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer.subarray(pos));\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(buffer32);\n        this.compress(buffer32, 0, true);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(buffer32);\n        const out32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(out);\n        this.get().forEach((v, i)=>out32[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(v));\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        const { buffer, length, finished, destroyed, outputLen, pos } = this;\n        to || (to = new this.constructor({\n            dkLen: outputLen\n        }));\n        to.set(...this.get());\n        to.buffer.set(buffer);\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        // @ts-ignore\n        to.outputLen = outputLen;\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nclass BLAKE2b extends BLAKE2 {\n    constructor(opts = {}){\n        const olen = opts.dkLen === undefined ? 64 : opts.dkLen;\n        super(128, olen);\n        // Same as SHA-512, but LE\n        this.v0l = B2B_IV[0] | 0;\n        this.v0h = B2B_IV[1] | 0;\n        this.v1l = B2B_IV[2] | 0;\n        this.v1h = B2B_IV[3] | 0;\n        this.v2l = B2B_IV[4] | 0;\n        this.v2h = B2B_IV[5] | 0;\n        this.v3l = B2B_IV[6] | 0;\n        this.v3h = B2B_IV[7] | 0;\n        this.v4l = B2B_IV[8] | 0;\n        this.v4h = B2B_IV[9] | 0;\n        this.v5l = B2B_IV[10] | 0;\n        this.v5h = B2B_IV[11] | 0;\n        this.v6l = B2B_IV[12] | 0;\n        this.v6h = B2B_IV[13] | 0;\n        this.v7l = B2B_IV[14] | 0;\n        this.v7h = B2B_IV[15] | 0;\n        checkBlake2Opts(olen, opts, 64, 16, 16);\n        let { key, personalization, salt } = opts;\n        let keyLength = 0;\n        if (key !== undefined) {\n            key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(key);\n            keyLength = key.length;\n        }\n        this.v0l ^= this.outputLen | keyLength << 8 | 0x01 << 16 | 0x01 << 24;\n        if (salt !== undefined) {\n            salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt);\n            const slt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(salt);\n            this.v4l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[0]);\n            this.v4h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[1]);\n            this.v5l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[2]);\n            this.v5h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[3]);\n        }\n        if (personalization !== undefined) {\n            personalization = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(personalization);\n            const pers = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(personalization);\n            this.v6l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[0]);\n            this.v6h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[1]);\n            this.v7l ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[2]);\n            this.v7h ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[3]);\n        }\n        if (key !== undefined) {\n            // Pad to blockLen and update\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(key);\n            this.update(tmp);\n        }\n    }\n    // prettier-ignore\n    get() {\n        let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;\n        return [\n            v0l,\n            v0h,\n            v1l,\n            v1h,\n            v2l,\n            v2h,\n            v3l,\n            v3h,\n            v4l,\n            v4h,\n            v5l,\n            v5h,\n            v6l,\n            v6h,\n            v7l,\n            v7h\n        ];\n    }\n    // prettier-ignore\n    set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {\n        this.v0l = v0l | 0;\n        this.v0h = v0h | 0;\n        this.v1l = v1l | 0;\n        this.v1h = v1h | 0;\n        this.v2l = v2l | 0;\n        this.v2h = v2h | 0;\n        this.v3l = v3l | 0;\n        this.v3h = v3h | 0;\n        this.v4l = v4l | 0;\n        this.v4h = v4h | 0;\n        this.v5l = v5l | 0;\n        this.v5h = v5h | 0;\n        this.v6l = v6l | 0;\n        this.v6h = v6h | 0;\n        this.v7l = v7l | 0;\n        this.v7h = v7h | 0;\n    }\n    compress(msg, offset, isLast) {\n        this.get().forEach((v, i)=>BBUF[i] = v); // First half from state.\n        BBUF.set(B2B_IV, 16); // Second half from IV.\n        let { h, l } = _u64_js__WEBPACK_IMPORTED_MODULE_0__.fromBig(BigInt(this.length));\n        BBUF[24] = B2B_IV[8] ^ l; // Low word of the offset.\n        BBUF[25] = B2B_IV[9] ^ h; // High word.\n        // Invert all bits for last block\n        if (isLast) {\n            BBUF[28] = ~BBUF[28];\n            BBUF[29] = ~BBUF[29];\n        }\n        let j = 0;\n        const s = _blake_js__WEBPACK_IMPORTED_MODULE_2__.BSIGMA;\n        for(let i = 0; i < 12; i++){\n            G1b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G2b(0, 4, 8, 12, msg, offset + 2 * s[j++]);\n            G1b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G2b(1, 5, 9, 13, msg, offset + 2 * s[j++]);\n            G1b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G2b(2, 6, 10, 14, msg, offset + 2 * s[j++]);\n            G1b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G2b(3, 7, 11, 15, msg, offset + 2 * s[j++]);\n            G1b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G2b(0, 5, 10, 15, msg, offset + 2 * s[j++]);\n            G1b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G2b(1, 6, 11, 12, msg, offset + 2 * s[j++]);\n            G1b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G2b(2, 7, 8, 13, msg, offset + 2 * s[j++]);\n            G1b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n            G2b(3, 4, 9, 14, msg, offset + 2 * s[j++]);\n        }\n        this.v0l ^= BBUF[0] ^ BBUF[16];\n        this.v0h ^= BBUF[1] ^ BBUF[17];\n        this.v1l ^= BBUF[2] ^ BBUF[18];\n        this.v1h ^= BBUF[3] ^ BBUF[19];\n        this.v2l ^= BBUF[4] ^ BBUF[20];\n        this.v2h ^= BBUF[5] ^ BBUF[21];\n        this.v3l ^= BBUF[6] ^ BBUF[22];\n        this.v3h ^= BBUF[7] ^ BBUF[23];\n        this.v4l ^= BBUF[8] ^ BBUF[24];\n        this.v4h ^= BBUF[9] ^ BBUF[25];\n        this.v5l ^= BBUF[10] ^ BBUF[26];\n        this.v5h ^= BBUF[11] ^ BBUF[27];\n        this.v6l ^= BBUF[12] ^ BBUF[28];\n        this.v6h ^= BBUF[13] ^ BBUF[29];\n        this.v7l ^= BBUF[14] ^ BBUF[30];\n        this.v7h ^= BBUF[15] ^ BBUF[31];\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(BBUF);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer32);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * Blake2b hash function. 64-bit. 1.5x slower than blake2s in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */ const blake2b = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createOptHasher)((opts)=>new BLAKE2b(opts));\n// prettier-ignore\nfunction compress(s, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {\n    let j = 0;\n    for(let i = 0; i < rounds; i++){\n        ({ a: v0, b: v4, c: v8, d: v12 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v0, b: v4, c: v8, d: v12 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v0, v4, v8, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v1, b: v5, c: v9, d: v13 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v1, v5, v9, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v2, b: v6, c: v10, d: v14 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v2, v6, v10, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v3, b: v7, c: v11, d: v15 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v3, v7, v11, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v0, b: v5, c: v10, d: v15 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v0, v5, v10, v15, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v1, b: v6, c: v11, d: v12 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v1, v6, v11, v12, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v2, b: v7, c: v8, d: v13 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v2, v7, v8, v13, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G1s)(v3, v4, v9, v14, msg[offset + s[j++]]));\n        ({ a: v3, b: v4, c: v9, d: v14 } = (0,_blake_js__WEBPACK_IMPORTED_MODULE_2__.G2s)(v3, v4, v9, v14, msg[offset + s[j++]]));\n    }\n    return {\n        v0,\n        v1,\n        v2,\n        v3,\n        v4,\n        v5,\n        v6,\n        v7,\n        v8,\n        v9,\n        v10,\n        v11,\n        v12,\n        v13,\n        v14,\n        v15\n    };\n}\nconst B2S_IV = _md_js__WEBPACK_IMPORTED_MODULE_3__.SHA256_IV;\nclass BLAKE2s extends BLAKE2 {\n    constructor(opts = {}){\n        const olen = opts.dkLen === undefined ? 32 : opts.dkLen;\n        super(64, olen);\n        // Internal state, same as SHA-256\n        this.v0 = B2S_IV[0] | 0;\n        this.v1 = B2S_IV[1] | 0;\n        this.v2 = B2S_IV[2] | 0;\n        this.v3 = B2S_IV[3] | 0;\n        this.v4 = B2S_IV[4] | 0;\n        this.v5 = B2S_IV[5] | 0;\n        this.v6 = B2S_IV[6] | 0;\n        this.v7 = B2S_IV[7] | 0;\n        checkBlake2Opts(olen, opts, 32, 8, 8);\n        let { key, personalization, salt } = opts;\n        let keyLength = 0;\n        if (key !== undefined) {\n            key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(key);\n            keyLength = key.length;\n        }\n        this.v0 ^= this.outputLen | keyLength << 8 | 0x01 << 16 | 0x01 << 24;\n        if (salt !== undefined) {\n            salt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(salt);\n            const slt = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(salt);\n            this.v4 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[0]);\n            this.v5 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(slt[1]);\n        }\n        if (personalization !== undefined) {\n            personalization = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(personalization);\n            const pers = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(personalization);\n            this.v6 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[0]);\n            this.v7 ^= (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap8IfBE)(pers[1]);\n        }\n        if (key !== undefined) {\n            // Pad to blockLen and update\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(key);\n            const tmp = new Uint8Array(this.blockLen);\n            tmp.set(key);\n            this.update(tmp);\n        }\n    }\n    get() {\n        const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;\n        return [\n            v0,\n            v1,\n            v2,\n            v3,\n            v4,\n            v5,\n            v6,\n            v7\n        ];\n    }\n    // prettier-ignore\n    set(v0, v1, v2, v3, v4, v5, v6, v7) {\n        this.v0 = v0 | 0;\n        this.v1 = v1 | 0;\n        this.v2 = v2 | 0;\n        this.v3 = v3 | 0;\n        this.v4 = v4 | 0;\n        this.v5 = v5 | 0;\n        this.v6 = v6 | 0;\n        this.v7 = v7 | 0;\n    }\n    compress(msg, offset, isLast) {\n        const { h, l } = _u64_js__WEBPACK_IMPORTED_MODULE_0__.fromBig(BigInt(this.length));\n        // prettier-ignore\n        const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress(_blake_js__WEBPACK_IMPORTED_MODULE_2__.BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);\n        this.v0 ^= v0 ^ v8;\n        this.v1 ^= v1 ^ v9;\n        this.v2 ^= v2 ^ v10;\n        this.v3 ^= v3 ^ v11;\n        this.v4 ^= v4 ^ v12;\n        this.v5 ^= v5 ^ v13;\n        this.v6 ^= v6 ^ v14;\n        this.v7 ^= v7 ^ v15;\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer32);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\n/**\n * Blake2s hash function. Focuses on 8-bit to 32-bit platforms. 1.5x faster than blake2b in JS.\n * @param msg - message that would be hashed\n * @param opts - dkLen output length, key for MAC mode, salt, personalization\n */ const blake2s = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createOptHasher)((opts)=>new BLAKE2s(opts)); //# sourceMappingURL=blake2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vYmxha2UyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQzhDO0FBQ1Y7QUFDSjtBQUNqQyxrQkFBa0I7QUFDZ0g7QUFDbEksb0ZBQW9GO0FBQ3BGLE1BQU1nQixTQUFTLGFBQWEsR0FBR0MsWUFBWUMsSUFBSSxDQUFDO0lBQzVDO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtDQUN2RjtBQUNELG1CQUFtQjtBQUNuQixNQUFNQyxPQUFPLGFBQWEsR0FBRyxJQUFJRixZQUFZO0FBQzdDLDBDQUEwQztBQUMxQyxTQUFTRyxJQUFJQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEdBQUcsRUFBRUMsQ0FBQztJQUMzQixxQkFBcUI7SUFDckIsTUFBTUMsS0FBS0YsR0FBRyxDQUFDQyxFQUFFLEVBQUVFLEtBQUtILEdBQUcsQ0FBQ0MsSUFBSSxFQUFFLEVBQUUsa0JBQWtCO0lBQ3RELElBQUlHLEtBQUtWLElBQUksQ0FBQyxJQUFJRSxFQUFFLEVBQUVTLEtBQUtYLElBQUksQ0FBQyxJQUFJRSxJQUFJLEVBQUUsRUFBRSxrQkFBa0I7SUFDOUQsSUFBSVUsS0FBS1osSUFBSSxDQUFDLElBQUlHLEVBQUUsRUFBRVUsS0FBS2IsSUFBSSxDQUFDLElBQUlHLElBQUksRUFBRSxFQUFFLGtCQUFrQjtJQUM5RCxJQUFJVyxLQUFLZCxJQUFJLENBQUMsSUFBSUksRUFBRSxFQUFFVyxLQUFLZixJQUFJLENBQUMsSUFBSUksSUFBSSxFQUFFLEVBQUUsa0JBQWtCO0lBQzlELElBQUlZLEtBQUtoQixJQUFJLENBQUMsSUFBSUssRUFBRSxFQUFFWSxLQUFLakIsSUFBSSxDQUFDLElBQUlLLElBQUksRUFBRSxFQUFFLGtCQUFrQjtJQUM5RCxnQ0FBZ0M7SUFDaEMsSUFBSWEsS0FBS2pDLDBDQUFTLENBQUN5QixJQUFJRSxJQUFJSjtJQUMzQkcsS0FBSzFCLDBDQUFTLENBQUNpQyxJQUFJUCxJQUFJRSxJQUFJSjtJQUMzQkMsS0FBS1EsS0FBSztJQUNWLCtCQUErQjtJQUM5QixHQUFFRCxFQUFFLEVBQUVELEVBQUUsRUFBRSxHQUFHO1FBQUVDLElBQUlBLEtBQUtOO1FBQUlLLElBQUlBLEtBQUtOO0lBQUc7SUFDeEMsR0FBRU8sRUFBRSxFQUFFRCxFQUFFLEVBQUUsR0FBRztRQUFFQyxJQUFJaEMsNENBQVcsQ0FBQ2dDLElBQUlEO1FBQUtBLElBQUkvQiw0Q0FBVyxDQUFDZ0MsSUFBSUQ7SUFBSTtJQUNqRSw0QkFBNEI7SUFDM0IsR0FBRU8sR0FBR1IsRUFBRSxFQUFFUyxHQUFHVixFQUFFLEVBQUUsR0FBRzdCLHdDQUFPLENBQUM4QixJQUFJRCxJQUFJRyxJQUFJRCxHQUFFO0lBQzFDLCtCQUErQjtJQUM5QixHQUFFSCxFQUFFLEVBQUVELEVBQUUsRUFBRSxHQUFHO1FBQUVDLElBQUlBLEtBQUtFO1FBQUlILElBQUlBLEtBQUtFO0lBQUc7SUFDeEMsR0FBRUQsRUFBRSxFQUFFRCxFQUFFLEVBQUUsR0FBRztRQUFFQyxJQUFJNUIsMkNBQVUsQ0FBQzRCLElBQUlELElBQUk7UUFBS0EsSUFBSTNCLDJDQUFVLENBQUM0QixJQUFJRCxJQUFJO0lBQUk7SUFDdEVaLElBQUksQ0FBQyxJQUFJRSxFQUFFLEdBQUdRLElBQU1WLElBQUksQ0FBQyxJQUFJRSxJQUFJLEVBQUUsR0FBR1M7SUFDdENYLElBQUksQ0FBQyxJQUFJRyxFQUFFLEdBQUdTLElBQU1aLElBQUksQ0FBQyxJQUFJRyxJQUFJLEVBQUUsR0FBR1U7SUFDdENiLElBQUksQ0FBQyxJQUFJSSxFQUFFLEdBQUdVLElBQU1kLElBQUksQ0FBQyxJQUFJSSxJQUFJLEVBQUUsR0FBR1c7SUFDdENmLElBQUksQ0FBQyxJQUFJSyxFQUFFLEdBQUdXLElBQU1oQixJQUFJLENBQUMsSUFBSUssSUFBSSxFQUFFLEdBQUdZO0FBQzNDO0FBQ0EsU0FBU1csSUFBSTFCLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsR0FBRyxFQUFFQyxDQUFDO0lBQzNCLHFCQUFxQjtJQUNyQixNQUFNQyxLQUFLRixHQUFHLENBQUNDLEVBQUUsRUFBRUUsS0FBS0gsR0FBRyxDQUFDQyxJQUFJLEVBQUUsRUFBRSxrQkFBa0I7SUFDdEQsSUFBSUcsS0FBS1YsSUFBSSxDQUFDLElBQUlFLEVBQUUsRUFBRVMsS0FBS1gsSUFBSSxDQUFDLElBQUlFLElBQUksRUFBRSxFQUFFLGtCQUFrQjtJQUM5RCxJQUFJVSxLQUFLWixJQUFJLENBQUMsSUFBSUcsRUFBRSxFQUFFVSxLQUFLYixJQUFJLENBQUMsSUFBSUcsSUFBSSxFQUFFLEVBQUUsa0JBQWtCO0lBQzlELElBQUlXLEtBQUtkLElBQUksQ0FBQyxJQUFJSSxFQUFFLEVBQUVXLEtBQUtmLElBQUksQ0FBQyxJQUFJSSxJQUFJLEVBQUUsRUFBRSxrQkFBa0I7SUFDOUQsSUFBSVksS0FBS2hCLElBQUksQ0FBQyxJQUFJSyxFQUFFLEVBQUVZLEtBQUtqQixJQUFJLENBQUMsSUFBSUssSUFBSSxFQUFFLEVBQUUsa0JBQWtCO0lBQzlELGdDQUFnQztJQUNoQyxJQUFJYSxLQUFLakMsMENBQVMsQ0FBQ3lCLElBQUlFLElBQUlKO0lBQzNCRyxLQUFLMUIsMENBQVMsQ0FBQ2lDLElBQUlQLElBQUlFLElBQUlKO0lBQzNCQyxLQUFLUSxLQUFLO0lBQ1YsK0JBQStCO0lBQzlCLEdBQUVELEVBQUUsRUFBRUQsRUFBRSxFQUFFLEdBQUc7UUFBRUMsSUFBSUEsS0FBS047UUFBSUssSUFBSUEsS0FBS047SUFBRztJQUN4QyxHQUFFTyxFQUFFLEVBQUVELEVBQUUsRUFBRSxHQUFHO1FBQUVDLElBQUloQywyQ0FBVSxDQUFDZ0MsSUFBSUQsSUFBSTtRQUFLQSxJQUFJL0IsMkNBQVUsQ0FBQ2dDLElBQUlELElBQUk7SUFBSTtJQUN2RSw0QkFBNEI7SUFDM0IsR0FBRU8sR0FBR1IsRUFBRSxFQUFFUyxHQUFHVixFQUFFLEVBQUUsR0FBRzdCLHdDQUFPLENBQUM4QixJQUFJRCxJQUFJRyxJQUFJRCxHQUFFO0lBQzFDLCtCQUErQjtJQUM5QixHQUFFSCxFQUFFLEVBQUVELEVBQUUsRUFBRSxHQUFHO1FBQUVDLElBQUlBLEtBQUtFO1FBQUlILElBQUlBLEtBQUtFO0lBQUc7SUFDeEMsR0FBRUQsRUFBRSxFQUFFRCxFQUFFLEVBQUUsR0FBRztRQUFFQyxJQUFJNUIsMkNBQVUsQ0FBQzRCLElBQUlELElBQUk7UUFBS0EsSUFBSTNCLDJDQUFVLENBQUM0QixJQUFJRCxJQUFJO0lBQUk7SUFDdEVaLElBQUksQ0FBQyxJQUFJRSxFQUFFLEdBQUdRLElBQU1WLElBQUksQ0FBQyxJQUFJRSxJQUFJLEVBQUUsR0FBR1M7SUFDdENYLElBQUksQ0FBQyxJQUFJRyxFQUFFLEdBQUdTLElBQU1aLElBQUksQ0FBQyxJQUFJRyxJQUFJLEVBQUUsR0FBR1U7SUFDdENiLElBQUksQ0FBQyxJQUFJSSxFQUFFLEdBQUdVLElBQU1kLElBQUksQ0FBQyxJQUFJSSxJQUFJLEVBQUUsR0FBR1c7SUFDdENmLElBQUksQ0FBQyxJQUFJSyxFQUFFLEdBQUdXLElBQU1oQixJQUFJLENBQUMsSUFBSUssSUFBSSxFQUFFLEdBQUdZO0FBQzNDO0FBQ0EsU0FBU2MsZ0JBQWdCQyxTQUFTLEVBQUVDLE9BQU8sQ0FBQyxDQUFDLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBQ25FaEQsa0RBQU9BLENBQUM4QztJQUNSLElBQUlGLFlBQVksS0FBS0EsWUFBWUUsUUFDN0IsTUFBTSxJQUFJRyxNQUFNO0lBQ3BCLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLGVBQWUsRUFBRSxHQUFHUDtJQUN2QyxJQUFJSyxRQUFRRyxhQUFjSCxDQUFBQSxJQUFJSSxNQUFNLEdBQUcsS0FBS0osSUFBSUksTUFBTSxHQUFHUixNQUFLLEdBQzFELE1BQU0sSUFBSUcsTUFBTSx3Q0FBd0NIO0lBQzVELElBQUlLLFNBQVNFLGFBQWFGLEtBQUtHLE1BQU0sS0FBS1AsU0FDdEMsTUFBTSxJQUFJRSxNQUFNLCtCQUErQkY7SUFDbkQsSUFBSUssb0JBQW9CQyxhQUFhRCxnQkFBZ0JFLE1BQU0sS0FBS04sU0FDNUQsTUFBTSxJQUFJQyxNQUFNLDBDQUEwQ0Q7QUFDbEU7QUFDQSw2Q0FBNkMsR0FDdEMsTUFBTU8sZUFBZW5ELDJDQUFJQTtJQUM1Qm9ELFlBQVlDLFFBQVEsRUFBRWIsU0FBUyxDQUFFO1FBQzdCLEtBQUs7UUFDTCxJQUFJLENBQUNjLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNMLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ00sR0FBRyxHQUFHO1FBQ1g1RCxrREFBT0EsQ0FBQ3lEO1FBQ1J6RCxrREFBT0EsQ0FBQzRDO1FBQ1IsSUFBSSxDQUFDYSxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ2IsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNpQixNQUFNLEdBQUcsSUFBSUMsV0FBV0w7UUFDN0IsSUFBSSxDQUFDTSxRQUFRLEdBQUd2RCw4Q0FBR0EsQ0FBQyxJQUFJLENBQUNxRCxNQUFNO0lBQ25DO0lBQ0FHLE9BQU9DLElBQUksRUFBRTtRQUNUbEUsa0RBQU9BLENBQUMsSUFBSTtRQUNaa0UsT0FBTzFELGtEQUFPQSxDQUFDMEQ7UUFDZm5FLGlEQUFNQSxDQUFDbUU7UUFDUCxtRUFBbUU7UUFDbkUsK0RBQStEO1FBQy9ELDRFQUE0RTtRQUM1RSw2QkFBNkI7UUFDN0IsTUFBTSxFQUFFUixRQUFRLEVBQUVJLE1BQU0sRUFBRUUsUUFBUSxFQUFFLEdBQUcsSUFBSTtRQUMzQyxNQUFNRyxNQUFNRCxLQUFLWCxNQUFNO1FBQ3ZCLE1BQU1hLFNBQVNGLEtBQUtHLFVBQVU7UUFDOUIsTUFBTUMsTUFBTUosS0FBS0osTUFBTTtRQUN2QixJQUFLLElBQUlELE1BQU0sR0FBR0EsTUFBTU0sS0FBTTtZQUMxQix3RkFBd0Y7WUFDeEYsSUFBSSxJQUFJLENBQUNOLEdBQUcsS0FBS0gsVUFBVTtnQkFDdkJwRCxxREFBVUEsQ0FBQzBEO2dCQUNYLElBQUksQ0FBQ08sUUFBUSxDQUFDUCxVQUFVLEdBQUc7Z0JBQzNCMUQscURBQVVBLENBQUMwRDtnQkFDWCxJQUFJLENBQUNILEdBQUcsR0FBRztZQUNmO1lBQ0EsTUFBTVcsT0FBT0MsS0FBS0MsR0FBRyxDQUFDaEIsV0FBVyxJQUFJLENBQUNHLEdBQUcsRUFBRU0sTUFBTU47WUFDakQsTUFBTWMsYUFBYVAsU0FBU1A7WUFDNUIsd0RBQXdEO1lBQ3hELElBQUlXLFNBQVNkLFlBQVksQ0FBRWlCLENBQUFBLGFBQWEsTUFBTWQsTUFBTVcsT0FBT0wsS0FBSztnQkFDNUQsTUFBTVMsU0FBUyxJQUFJakUsWUFBWTJELEtBQUtLLFlBQVlGLEtBQUtJLEtBQUssQ0FBQyxDQUFDVixNQUFNTixHQUFFLElBQUs7Z0JBQ3pFdkQscURBQVVBLENBQUNzRTtnQkFDWCxJQUFLLElBQUlFLFFBQVEsR0FBR2pCLE1BQU1ILFdBQVdTLEtBQUtXLFNBQVNkLFNBQVNULE1BQU0sRUFBRU0sT0FBT0gsU0FBVTtvQkFDakYsSUFBSSxDQUFDSCxNQUFNLElBQUlHO29CQUNmLElBQUksQ0FBQ2EsUUFBUSxDQUFDSyxRQUFRRSxPQUFPO2dCQUNqQztnQkFDQXhFLHFEQUFVQSxDQUFDc0U7Z0JBQ1g7WUFDSjtZQUNBZCxPQUFPaUIsR0FBRyxDQUFDYixLQUFLYyxRQUFRLENBQUNuQixLQUFLQSxNQUFNVyxPQUFPLElBQUksQ0FBQ1gsR0FBRztZQUNuRCxJQUFJLENBQUNBLEdBQUcsSUFBSVc7WUFDWixJQUFJLENBQUNqQixNQUFNLElBQUlpQjtZQUNmWCxPQUFPVztRQUNYO1FBQ0EsT0FBTyxJQUFJO0lBQ2Y7SUFDQVMsV0FBV0MsR0FBRyxFQUFFO1FBQ1psRixrREFBT0EsQ0FBQyxJQUFJO1FBQ1pFLGtEQUFPQSxDQUFDZ0YsS0FBSyxJQUFJO1FBQ2pCLE1BQU0sRUFBRXJCLEdBQUcsRUFBRUcsUUFBUSxFQUFFLEdBQUcsSUFBSTtRQUM5QixJQUFJLENBQUNMLFFBQVEsR0FBRztRQUNoQixVQUFVO1FBQ1Z4RCxnREFBS0EsQ0FBQyxJQUFJLENBQUMyRCxNQUFNLENBQUNrQixRQUFRLENBQUNuQjtRQUMzQnZELHFEQUFVQSxDQUFDMEQ7UUFDWCxJQUFJLENBQUNPLFFBQVEsQ0FBQ1AsVUFBVSxHQUFHO1FBQzNCMUQscURBQVVBLENBQUMwRDtRQUNYLE1BQU1tQixRQUFRMUUsOENBQUdBLENBQUN5RTtRQUNsQixJQUFJLENBQUNFLEdBQUcsR0FBR0MsT0FBTyxDQUFDLENBQUNDLEdBQUdDLElBQU9KLEtBQUssQ0FBQ0ksRUFBRSxHQUFHaEYsb0RBQVNBLENBQUMrRTtJQUN2RDtJQUNBRSxTQUFTO1FBQ0wsTUFBTSxFQUFFMUIsTUFBTSxFQUFFakIsU0FBUyxFQUFFLEdBQUcsSUFBSTtRQUNsQyxJQUFJLENBQUNvQyxVQUFVLENBQUNuQjtRQUNoQixNQUFNMkIsTUFBTTNCLE9BQU80QixLQUFLLENBQUMsR0FBRzdDO1FBQzVCLElBQUksQ0FBQzhDLE9BQU87UUFDWixPQUFPRjtJQUNYO0lBQ0FHLFdBQVdDLEVBQUUsRUFBRTtRQUNYLE1BQU0sRUFBRS9CLE1BQU0sRUFBRVAsTUFBTSxFQUFFSSxRQUFRLEVBQUVDLFNBQVMsRUFBRWYsU0FBUyxFQUFFZ0IsR0FBRyxFQUFFLEdBQUcsSUFBSTtRQUNwRWdDLE1BQU9BLENBQUFBLEtBQUssSUFBSSxJQUFJLENBQUNwQyxXQUFXLENBQUM7WUFBRXFDLE9BQU9qRDtRQUFVLEVBQUM7UUFDckRnRCxHQUFHZCxHQUFHLElBQUksSUFBSSxDQUFDSyxHQUFHO1FBQ2xCUyxHQUFHL0IsTUFBTSxDQUFDaUIsR0FBRyxDQUFDakI7UUFDZCtCLEdBQUdqQyxTQUFTLEdBQUdBO1FBQ2ZpQyxHQUFHbEMsUUFBUSxHQUFHQTtRQUNka0MsR0FBR3RDLE1BQU0sR0FBR0E7UUFDWnNDLEdBQUdoQyxHQUFHLEdBQUdBO1FBQ1QsYUFBYTtRQUNiZ0MsR0FBR2hELFNBQVMsR0FBR0E7UUFDZixPQUFPZ0Q7SUFDWDtJQUNBRSxRQUFRO1FBQ0osT0FBTyxJQUFJLENBQUNILFVBQVU7SUFDMUI7QUFDSjtBQUNPLE1BQU1JLGdCQUFnQnhDO0lBQ3pCQyxZQUFZWCxPQUFPLENBQUMsQ0FBQyxDQUFFO1FBQ25CLE1BQU1tRCxPQUFPbkQsS0FBS2dELEtBQUssS0FBS3hDLFlBQVksS0FBS1IsS0FBS2dELEtBQUs7UUFDdkQsS0FBSyxDQUFDLEtBQUtHO1FBQ1gsMEJBQTBCO1FBQzFCLElBQUksQ0FBQ0MsR0FBRyxHQUFHeEYsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUN5RixHQUFHLEdBQUd6RixNQUFNLENBQUMsRUFBRSxHQUFHO1FBQ3ZCLElBQUksQ0FBQzBGLEdBQUcsR0FBRzFGLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDMkYsR0FBRyxHQUFHM0YsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUM0RixHQUFHLEdBQUc1RixNQUFNLENBQUMsRUFBRSxHQUFHO1FBQ3ZCLElBQUksQ0FBQzZGLEdBQUcsR0FBRzdGLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDOEYsR0FBRyxHQUFHOUYsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUMrRixHQUFHLEdBQUcvRixNQUFNLENBQUMsRUFBRSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ2dHLEdBQUcsR0FBR2hHLE1BQU0sQ0FBQyxFQUFFLEdBQUc7UUFDdkIsSUFBSSxDQUFDaUcsR0FBRyxHQUFHakcsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN2QixJQUFJLENBQUNrRyxHQUFHLEdBQUdsRyxNQUFNLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQ21HLEdBQUcsR0FBR25HLE1BQU0sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDb0csR0FBRyxHQUFHcEcsTUFBTSxDQUFDLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUNxRyxHQUFHLEdBQUdyRyxNQUFNLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQ3NHLEdBQUcsR0FBR3RHLE1BQU0sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDdUcsR0FBRyxHQUFHdkcsTUFBTSxDQUFDLEdBQUcsR0FBRztRQUN4QmtDLGdCQUFnQnFELE1BQU1uRCxNQUFNLElBQUksSUFBSTtRQUNwQyxJQUFJLEVBQUVLLEdBQUcsRUFBRUUsZUFBZSxFQUFFRCxJQUFJLEVBQUUsR0FBR047UUFDckMsSUFBSW9FLFlBQVk7UUFDaEIsSUFBSS9ELFFBQVFHLFdBQVc7WUFDbkJILE1BQU0zQyxrREFBT0EsQ0FBQzJDO1lBQ2QrRCxZQUFZL0QsSUFBSUksTUFBTTtRQUMxQjtRQUNBLElBQUksQ0FBQzJDLEdBQUcsSUFBSSxJQUFJLENBQUNyRCxTQUFTLEdBQUlxRSxhQUFhLElBQU0sUUFBUSxLQUFPLFFBQVE7UUFDeEUsSUFBSTlELFNBQVNFLFdBQVc7WUFDcEJGLE9BQU81QyxrREFBT0EsQ0FBQzRDO1lBQ2YsTUFBTStELE1BQU0xRyw4Q0FBR0EsQ0FBQzJDO1lBQ2hCLElBQUksQ0FBQ3NELEdBQUcsSUFBSW5HLG9EQUFTQSxDQUFDNEcsR0FBRyxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDUixHQUFHLElBQUlwRyxvREFBU0EsQ0FBQzRHLEdBQUcsQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQ1AsR0FBRyxJQUFJckcsb0RBQVNBLENBQUM0RyxHQUFHLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUNOLEdBQUcsSUFBSXRHLG9EQUFTQSxDQUFDNEcsR0FBRyxDQUFDLEVBQUU7UUFDaEM7UUFDQSxJQUFJOUQsb0JBQW9CQyxXQUFXO1lBQy9CRCxrQkFBa0I3QyxrREFBT0EsQ0FBQzZDO1lBQzFCLE1BQU0rRCxPQUFPM0csOENBQUdBLENBQUM0QztZQUNqQixJQUFJLENBQUN5RCxHQUFHLElBQUl2RyxvREFBU0EsQ0FBQzZHLElBQUksQ0FBQyxFQUFFO1lBQzdCLElBQUksQ0FBQ0wsR0FBRyxJQUFJeEcsb0RBQVNBLENBQUM2RyxJQUFJLENBQUMsRUFBRTtZQUM3QixJQUFJLENBQUNKLEdBQUcsSUFBSXpHLG9EQUFTQSxDQUFDNkcsSUFBSSxDQUFDLEVBQUU7WUFDN0IsSUFBSSxDQUFDSCxHQUFHLElBQUkxRyxvREFBU0EsQ0FBQzZHLElBQUksQ0FBQyxFQUFFO1FBQ2pDO1FBQ0EsSUFBSWpFLFFBQVFHLFdBQVc7WUFDbkIsNkJBQTZCO1lBQzdCLE1BQU0rRCxNQUFNLElBQUl0RCxXQUFXLElBQUksQ0FBQ0wsUUFBUTtZQUN4QzJELElBQUl0QyxHQUFHLENBQUM1QjtZQUNSLElBQUksQ0FBQ2MsTUFBTSxDQUFDb0Q7UUFDaEI7SUFDSjtJQUNBLGtCQUFrQjtJQUNsQmpDLE1BQU07UUFDRixJQUFJLEVBQUVjLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRSxHQUFHLElBQUk7UUFDN0YsT0FBTztZQUFDZjtZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztZQUFLQztTQUFJO0lBQzNGO0lBQ0Esa0JBQWtCO0lBQ2xCbEMsSUFBSW1CLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUNoRixJQUFJLENBQUNmLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtRQUNqQixJQUFJLENBQUNDLEdBQUcsR0FBR0EsTUFBTTtJQUNyQjtJQUNBMUMsU0FBU3BELEdBQUcsRUFBRWlELE1BQU0sRUFBRWtELE1BQU0sRUFBRTtRQUMxQixJQUFJLENBQUNsQyxHQUFHLEdBQUdDLE9BQU8sQ0FBQyxDQUFDQyxHQUFHQyxJQUFPMUUsSUFBSSxDQUFDMEUsRUFBRSxHQUFHRCxJQUFLLHlCQUF5QjtRQUN0RXpFLEtBQUtrRSxHQUFHLENBQUNyRSxRQUFRLEtBQUssdUJBQXVCO1FBQzdDLElBQUksRUFBRTBCLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUd2Qyw0Q0FBVyxDQUFDMEgsT0FBTyxJQUFJLENBQUNqRSxNQUFNO1FBQzdDMUMsSUFBSSxDQUFDLEdBQUcsR0FBR0gsTUFBTSxDQUFDLEVBQUUsR0FBRzJCLEdBQUcsMEJBQTBCO1FBQ3BEeEIsSUFBSSxDQUFDLEdBQUcsR0FBR0gsTUFBTSxDQUFDLEVBQUUsR0FBRzBCLEdBQUcsYUFBYTtRQUN2QyxpQ0FBaUM7UUFDakMsSUFBSWtGLFFBQVE7WUFDUnpHLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQ0EsSUFBSSxDQUFDLEdBQUc7WUFDcEJBLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQ0EsSUFBSSxDQUFDLEdBQUc7UUFDeEI7UUFDQSxJQUFJNEcsSUFBSTtRQUNSLE1BQU1DLElBQUloSSw2Q0FBTUE7UUFDaEIsSUFBSyxJQUFJNkYsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7WUFDekJ6RSxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUlLLEtBQUtpRCxTQUFTLElBQUlzRCxDQUFDLENBQUNELElBQUk7WUFDekNoRixJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUl0QixLQUFLaUQsU0FBUyxJQUFJc0QsQ0FBQyxDQUFDRCxJQUFJO1lBQ3pDM0csSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJSyxLQUFLaUQsU0FBUyxJQUFJc0QsQ0FBQyxDQUFDRCxJQUFJO1lBQ3pDaEYsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJdEIsS0FBS2lELFNBQVMsSUFBSXNELENBQUMsQ0FBQ0QsSUFBSTtZQUN6QzNHLElBQUksR0FBRyxHQUFHLElBQUksSUFBSUssS0FBS2lELFNBQVMsSUFBSXNELENBQUMsQ0FBQ0QsSUFBSTtZQUMxQ2hGLElBQUksR0FBRyxHQUFHLElBQUksSUFBSXRCLEtBQUtpRCxTQUFTLElBQUlzRCxDQUFDLENBQUNELElBQUk7WUFDMUMzRyxJQUFJLEdBQUcsR0FBRyxJQUFJLElBQUlLLEtBQUtpRCxTQUFTLElBQUlzRCxDQUFDLENBQUNELElBQUk7WUFDMUNoRixJQUFJLEdBQUcsR0FBRyxJQUFJLElBQUl0QixLQUFLaUQsU0FBUyxJQUFJc0QsQ0FBQyxDQUFDRCxJQUFJO1lBQzFDM0csSUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJSyxLQUFLaUQsU0FBUyxJQUFJc0QsQ0FBQyxDQUFDRCxJQUFJO1lBQzFDaEYsSUFBSSxHQUFHLEdBQUcsSUFBSSxJQUFJdEIsS0FBS2lELFNBQVMsSUFBSXNELENBQUMsQ0FBQ0QsSUFBSTtZQUMxQzNHLElBQUksR0FBRyxHQUFHLElBQUksSUFBSUssS0FBS2lELFNBQVMsSUFBSXNELENBQUMsQ0FBQ0QsSUFBSTtZQUMxQ2hGLElBQUksR0FBRyxHQUFHLElBQUksSUFBSXRCLEtBQUtpRCxTQUFTLElBQUlzRCxDQUFDLENBQUNELElBQUk7WUFDMUMzRyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUlLLEtBQUtpRCxTQUFTLElBQUlzRCxDQUFDLENBQUNELElBQUk7WUFDekNoRixJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUl0QixLQUFLaUQsU0FBUyxJQUFJc0QsQ0FBQyxDQUFDRCxJQUFJO1lBQ3pDM0csSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJSyxLQUFLaUQsU0FBUyxJQUFJc0QsQ0FBQyxDQUFDRCxJQUFJO1lBQ3pDaEYsSUFBSSxHQUFHLEdBQUcsR0FBRyxJQUFJdEIsS0FBS2lELFNBQVMsSUFBSXNELENBQUMsQ0FBQ0QsSUFBSTtRQUM3QztRQUNBLElBQUksQ0FBQ3ZCLEdBQUcsSUFBSXJGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQ3NGLEdBQUcsSUFBSXRGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQ3VGLEdBQUcsSUFBSXZGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQ3dGLEdBQUcsSUFBSXhGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQ3lGLEdBQUcsSUFBSXpGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQzBGLEdBQUcsSUFBSTFGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQzJGLEdBQUcsSUFBSTNGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQzRGLEdBQUcsSUFBSTVGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQzZGLEdBQUcsSUFBSTdGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQzhGLEdBQUcsSUFBSTlGLElBQUksQ0FBQyxFQUFFLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQzlCLElBQUksQ0FBQytGLEdBQUcsSUFBSS9GLElBQUksQ0FBQyxHQUFHLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQy9CLElBQUksQ0FBQ2dHLEdBQUcsSUFBSWhHLElBQUksQ0FBQyxHQUFHLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQy9CLElBQUksQ0FBQ2lHLEdBQUcsSUFBSWpHLElBQUksQ0FBQyxHQUFHLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQy9CLElBQUksQ0FBQ2tHLEdBQUcsSUFBSWxHLElBQUksQ0FBQyxHQUFHLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQy9CLElBQUksQ0FBQ21HLEdBQUcsSUFBSW5HLElBQUksQ0FBQyxHQUFHLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQy9CLElBQUksQ0FBQ29HLEdBQUcsSUFBSXBHLElBQUksQ0FBQyxHQUFHLEdBQUdBLElBQUksQ0FBQyxHQUFHO1FBQy9CVixnREFBS0EsQ0FBQ1U7SUFDVjtJQUNBOEUsVUFBVTtRQUNOLElBQUksQ0FBQy9CLFNBQVMsR0FBRztRQUNqQnpELGdEQUFLQSxDQUFDLElBQUksQ0FBQzZELFFBQVE7UUFDbkIsSUFBSSxDQUFDZSxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7SUFDMUQ7QUFDSjtBQUNBOzs7O0NBSUMsR0FDTSxNQUFNNEMsVUFBVSxhQUFhLEdBQUd2SCwwREFBZUEsQ0FBQyxDQUFDMEMsT0FBUyxJQUFJa0QsUUFBUWxELE9BQU87QUFDcEYsa0JBQWtCO0FBQ1gsU0FBU3lCLFNBQVNtRCxDQUFDLEVBQUV0RCxNQUFNLEVBQUVqRCxHQUFHLEVBQUV5RyxNQUFNLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFDakgsSUFBSW5CLElBQUk7SUFDUixJQUFLLElBQUlsQyxJQUFJLEdBQUdBLElBQUlxQyxRQUFRckMsSUFBSztRQUM1QixHQUFFeEUsR0FBRzhHLEVBQUUsRUFBRTdHLEdBQUdpSCxFQUFFLEVBQUVoSCxHQUFHb0gsRUFBRSxFQUFFbkgsR0FBR3VILEdBQUcsRUFBRSxHQUFHOUksOENBQUdBLENBQUNrSSxJQUFJSSxJQUFJSSxJQUFJSSxLQUFLdEgsR0FBRyxDQUFDaUQsU0FBU3NELENBQUMsQ0FBQ0QsSUFBSSxDQUFDO1FBQzNFLEdBQUUxRyxHQUFHOEcsRUFBRSxFQUFFN0csR0FBR2lILEVBQUUsRUFBRWhILEdBQUdvSCxFQUFFLEVBQUVuSCxHQUFHdUgsR0FBRyxFQUFFLEdBQUc3SSw4Q0FBR0EsQ0FBQ2lJLElBQUlJLElBQUlJLElBQUlJLEtBQUt0SCxHQUFHLENBQUNpRCxTQUFTc0QsQ0FBQyxDQUFDRCxJQUFJLENBQUM7UUFDM0UsR0FBRTFHLEdBQUcrRyxFQUFFLEVBQUU5RyxHQUFHa0gsRUFBRSxFQUFFakgsR0FBR3FILEVBQUUsRUFBRXBILEdBQUd3SCxHQUFHLEVBQUUsR0FBRy9JLDhDQUFHQSxDQUFDbUksSUFBSUksSUFBSUksSUFBSUksS0FBS3ZILEdBQUcsQ0FBQ2lELFNBQVNzRCxDQUFDLENBQUNELElBQUksQ0FBQztRQUMzRSxHQUFFMUcsR0FBRytHLEVBQUUsRUFBRTlHLEdBQUdrSCxFQUFFLEVBQUVqSCxHQUFHcUgsRUFBRSxFQUFFcEgsR0FBR3dILEdBQUcsRUFBRSxHQUFHOUksOENBQUdBLENBQUNrSSxJQUFJSSxJQUFJSSxJQUFJSSxLQUFLdkgsR0FBRyxDQUFDaUQsU0FBU3NELENBQUMsQ0FBQ0QsSUFBSSxDQUFDO1FBQzNFLEdBQUUxRyxHQUFHZ0gsRUFBRSxFQUFFL0csR0FBR21ILEVBQUUsRUFBRWxILEdBQUdzSCxHQUFHLEVBQUVySCxHQUFHeUgsR0FBRyxFQUFFLEdBQUdoSiw4Q0FBR0EsQ0FBQ29JLElBQUlJLElBQUlJLEtBQUtJLEtBQUt4SCxHQUFHLENBQUNpRCxTQUFTc0QsQ0FBQyxDQUFDRCxJQUFJLENBQUM7UUFDN0UsR0FBRTFHLEdBQUdnSCxFQUFFLEVBQUUvRyxHQUFHbUgsRUFBRSxFQUFFbEgsR0FBR3NILEdBQUcsRUFBRXJILEdBQUd5SCxHQUFHLEVBQUUsR0FBRy9JLDhDQUFHQSxDQUFDbUksSUFBSUksSUFBSUksS0FBS0ksS0FBS3hILEdBQUcsQ0FBQ2lELFNBQVNzRCxDQUFDLENBQUNELElBQUksQ0FBQztRQUM3RSxHQUFFMUcsR0FBR2lILEVBQUUsRUFBRWhILEdBQUdvSCxFQUFFLEVBQUVuSCxHQUFHdUgsR0FBRyxFQUFFdEgsR0FBRzBILEdBQUcsRUFBRSxHQUFHakosOENBQUdBLENBQUNxSSxJQUFJSSxJQUFJSSxLQUFLSSxLQUFLekgsR0FBRyxDQUFDaUQsU0FBU3NELENBQUMsQ0FBQ0QsSUFBSSxDQUFDO1FBQzdFLEdBQUUxRyxHQUFHaUgsRUFBRSxFQUFFaEgsR0FBR29ILEVBQUUsRUFBRW5ILEdBQUd1SCxHQUFHLEVBQUV0SCxHQUFHMEgsR0FBRyxFQUFFLEdBQUdoSiw4Q0FBR0EsQ0FBQ29JLElBQUlJLElBQUlJLEtBQUtJLEtBQUt6SCxHQUFHLENBQUNpRCxTQUFTc0QsQ0FBQyxDQUFDRCxJQUFJLENBQUM7UUFDN0UsR0FBRTFHLEdBQUc4RyxFQUFFLEVBQUU3RyxHQUFHa0gsRUFBRSxFQUFFakgsR0FBR3NILEdBQUcsRUFBRXJILEdBQUcwSCxHQUFHLEVBQUUsR0FBR2pKLDhDQUFHQSxDQUFDa0ksSUFBSUssSUFBSUssS0FBS0ssS0FBS3pILEdBQUcsQ0FBQ2lELFNBQVNzRCxDQUFDLENBQUNELElBQUksQ0FBQztRQUM3RSxHQUFFMUcsR0FBRzhHLEVBQUUsRUFBRTdHLEdBQUdrSCxFQUFFLEVBQUVqSCxHQUFHc0gsR0FBRyxFQUFFckgsR0FBRzBILEdBQUcsRUFBRSxHQUFHaEosOENBQUdBLENBQUNpSSxJQUFJSyxJQUFJSyxLQUFLSyxLQUFLekgsR0FBRyxDQUFDaUQsU0FBU3NELENBQUMsQ0FBQ0QsSUFBSSxDQUFDO1FBQzdFLEdBQUUxRyxHQUFHK0csRUFBRSxFQUFFOUcsR0FBR21ILEVBQUUsRUFBRWxILEdBQUd1SCxHQUFHLEVBQUV0SCxHQUFHdUgsR0FBRyxFQUFFLEdBQUc5SSw4Q0FBR0EsQ0FBQ21JLElBQUlLLElBQUlLLEtBQUtDLEtBQUt0SCxHQUFHLENBQUNpRCxTQUFTc0QsQ0FBQyxDQUFDRCxJQUFJLENBQUM7UUFDN0UsR0FBRTFHLEdBQUcrRyxFQUFFLEVBQUU5RyxHQUFHbUgsRUFBRSxFQUFFbEgsR0FBR3VILEdBQUcsRUFBRXRILEdBQUd1SCxHQUFHLEVBQUUsR0FBRzdJLDhDQUFHQSxDQUFDa0ksSUFBSUssSUFBSUssS0FBS0MsS0FBS3RILEdBQUcsQ0FBQ2lELFNBQVNzRCxDQUFDLENBQUNELElBQUksQ0FBQztRQUM3RSxHQUFFMUcsR0FBR2dILEVBQUUsRUFBRS9HLEdBQUdvSCxFQUFFLEVBQUVuSCxHQUFHb0gsRUFBRSxFQUFFbkgsR0FBR3dILEdBQUcsRUFBRSxHQUFHL0ksOENBQUdBLENBQUNvSSxJQUFJSyxJQUFJQyxJQUFJSyxLQUFLdkgsR0FBRyxDQUFDaUQsU0FBU3NELENBQUMsQ0FBQ0QsSUFBSSxDQUFDO1FBQzNFLEdBQUUxRyxHQUFHZ0gsRUFBRSxFQUFFL0csR0FBR29ILEVBQUUsRUFBRW5ILEdBQUdvSCxFQUFFLEVBQUVuSCxHQUFHd0gsR0FBRyxFQUFFLEdBQUc5SSw4Q0FBR0EsQ0FBQ21JLElBQUlLLElBQUlDLElBQUlLLEtBQUt2SCxHQUFHLENBQUNpRCxTQUFTc0QsQ0FBQyxDQUFDRCxJQUFJLENBQUM7UUFDM0UsR0FBRTFHLEdBQUdpSCxFQUFFLEVBQUVoSCxHQUFHaUgsRUFBRSxFQUFFaEgsR0FBR3FILEVBQUUsRUFBRXBILEdBQUd5SCxHQUFHLEVBQUUsR0FBR2hKLDhDQUFHQSxDQUFDcUksSUFBSUMsSUFBSUssSUFBSUssS0FBS3hILEdBQUcsQ0FBQ2lELFNBQVNzRCxDQUFDLENBQUNELElBQUksQ0FBQztRQUMzRSxHQUFFMUcsR0FBR2lILEVBQUUsRUFBRWhILEdBQUdpSCxFQUFFLEVBQUVoSCxHQUFHcUgsRUFBRSxFQUFFcEgsR0FBR3lILEdBQUcsRUFBRSxHQUFHL0ksOENBQUdBLENBQUNvSSxJQUFJQyxJQUFJSyxJQUFJSyxLQUFLeEgsR0FBRyxDQUFDaUQsU0FBU3NELENBQUMsQ0FBQ0QsSUFBSSxDQUFDO0lBQ2hGO0lBQ0EsT0FBTztRQUFFSTtRQUFJQztRQUFJQztRQUFJQztRQUFJQztRQUFJQztRQUFJQztRQUFJQztRQUFJQztRQUFJQztRQUFJQztRQUFLQztRQUFLQztRQUFLQztRQUFLQztRQUFLQztJQUFJO0FBQ2xGO0FBQ0EsTUFBTUMsU0FBU2hKLDZDQUFTQTtBQUNqQixNQUFNaUosZ0JBQWdCdEY7SUFDekJDLFlBQVlYLE9BQU8sQ0FBQyxDQUFDLENBQUU7UUFDbkIsTUFBTW1ELE9BQU9uRCxLQUFLZ0QsS0FBSyxLQUFLeEMsWUFBWSxLQUFLUixLQUFLZ0QsS0FBSztRQUN2RCxLQUFLLENBQUMsSUFBSUc7UUFDVixrQ0FBa0M7UUFDbEMsSUFBSSxDQUFDNEIsRUFBRSxHQUFHZ0IsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNmLEVBQUUsR0FBR2UsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNkLEVBQUUsR0FBR2MsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNiLEVBQUUsR0FBR2EsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNaLEVBQUUsR0FBR1ksTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNYLEVBQUUsR0FBR1csTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNWLEVBQUUsR0FBR1UsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN0QixJQUFJLENBQUNULEVBQUUsR0FBR1MsTUFBTSxDQUFDLEVBQUUsR0FBRztRQUN0QmpHLGdCQUFnQnFELE1BQU1uRCxNQUFNLElBQUksR0FBRztRQUNuQyxJQUFJLEVBQUVLLEdBQUcsRUFBRUUsZUFBZSxFQUFFRCxJQUFJLEVBQUUsR0FBR047UUFDckMsSUFBSW9FLFlBQVk7UUFDaEIsSUFBSS9ELFFBQVFHLFdBQVc7WUFDbkJILE1BQU0zQyxrREFBT0EsQ0FBQzJDO1lBQ2QrRCxZQUFZL0QsSUFBSUksTUFBTTtRQUMxQjtRQUNBLElBQUksQ0FBQ3NFLEVBQUUsSUFBSSxJQUFJLENBQUNoRixTQUFTLEdBQUlxRSxhQUFhLElBQU0sUUFBUSxLQUFPLFFBQVE7UUFDdkUsSUFBSTlELFNBQVNFLFdBQVc7WUFDcEJGLE9BQU81QyxrREFBT0EsQ0FBQzRDO1lBQ2YsTUFBTStELE1BQU0xRyw4Q0FBR0EsQ0FBQzJDO1lBQ2hCLElBQUksQ0FBQzZFLEVBQUUsSUFBSTFILG9EQUFTQSxDQUFDNEcsR0FBRyxDQUFDLEVBQUU7WUFDM0IsSUFBSSxDQUFDZSxFQUFFLElBQUkzSCxvREFBU0EsQ0FBQzRHLEdBQUcsQ0FBQyxFQUFFO1FBQy9CO1FBQ0EsSUFBSTlELG9CQUFvQkMsV0FBVztZQUMvQkQsa0JBQWtCN0Msa0RBQU9BLENBQUM2QztZQUMxQixNQUFNK0QsT0FBTzNHLDhDQUFHQSxDQUFDNEM7WUFDakIsSUFBSSxDQUFDOEUsRUFBRSxJQUFJNUgsb0RBQVNBLENBQUM2RyxJQUFJLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUNnQixFQUFFLElBQUk3SCxvREFBU0EsQ0FBQzZHLElBQUksQ0FBQyxFQUFFO1FBQ2hDO1FBQ0EsSUFBSWpFLFFBQVFHLFdBQVc7WUFDbkIsNkJBQTZCO1lBQzdCdkQsaURBQU1BLENBQUNvRDtZQUNQLE1BQU1rRSxNQUFNLElBQUl0RCxXQUFXLElBQUksQ0FBQ0wsUUFBUTtZQUN4QzJELElBQUl0QyxHQUFHLENBQUM1QjtZQUNSLElBQUksQ0FBQ2MsTUFBTSxDQUFDb0Q7UUFDaEI7SUFDSjtJQUNBakMsTUFBTTtRQUNGLE1BQU0sRUFBRXlDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFLEdBQUcsSUFBSTtRQUMvQyxPQUFPO1lBQUNQO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1lBQUlDO1NBQUc7SUFDM0M7SUFDQSxrQkFBa0I7SUFDbEJyRCxJQUFJOEMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUU7UUFDaEMsSUFBSSxDQUFDUCxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHQSxLQUFLO1FBQ2YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEtBQUs7UUFDZixJQUFJLENBQUNDLEVBQUUsR0FBR0EsS0FBSztJQUNuQjtJQUNBN0QsU0FBU3BELEdBQUcsRUFBRWlELE1BQU0sRUFBRWtELE1BQU0sRUFBRTtRQUMxQixNQUFNLEVBQUVsRixDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHdkMsNENBQVcsQ0FBQzBILE9BQU8sSUFBSSxDQUFDakUsTUFBTTtRQUMvQyxrQkFBa0I7UUFDbEIsTUFBTSxFQUFFc0UsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFLEdBQUdyRSxTQUFTN0UsNkNBQU1BLEVBQUUwRSxRQUFRakQsS0FBSyxJQUFJLElBQUksQ0FBQzBHLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUUsRUFBRSxJQUFJLENBQUNDLEVBQUUsRUFBRVMsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRXhHLElBQUl3RyxNQUFNLENBQUMsRUFBRSxFQUFFekcsSUFBSXlHLE1BQU0sQ0FBQyxFQUFFLEVBQUV2QixTQUFTLENBQUN1QixNQUFNLENBQUMsRUFBRSxHQUFHQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRTtRQUMvUyxJQUFJLENBQUNoQixFQUFFLElBQUlBLEtBQUtRO1FBQ2hCLElBQUksQ0FBQ1AsRUFBRSxJQUFJQSxLQUFLUTtRQUNoQixJQUFJLENBQUNQLEVBQUUsSUFBSUEsS0FBS1E7UUFDaEIsSUFBSSxDQUFDUCxFQUFFLElBQUlBLEtBQUtRO1FBQ2hCLElBQUksQ0FBQ1AsRUFBRSxJQUFJQSxLQUFLUTtRQUNoQixJQUFJLENBQUNQLEVBQUUsSUFBSUEsS0FBS1E7UUFDaEIsSUFBSSxDQUFDUCxFQUFFLElBQUlBLEtBQUtRO1FBQ2hCLElBQUksQ0FBQ1AsRUFBRSxJQUFJQSxLQUFLUTtJQUNwQjtJQUNBakQsVUFBVTtRQUNOLElBQUksQ0FBQy9CLFNBQVMsR0FBRztRQUNqQnpELGdEQUFLQSxDQUFDLElBQUksQ0FBQzZELFFBQVE7UUFDbkIsSUFBSSxDQUFDZSxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztJQUNsQztBQUNKO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1nRSxVQUFVLGFBQWEsR0FBRzNJLDBEQUFlQSxDQUFDLENBQUMwQyxPQUFTLElBQUlnRyxRQUFRaEcsT0FBTyxDQUNwRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21tdW5lLXBhZ2UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vYmxha2UyLmpzPzRhYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBibGFrZTJiICg2NC1iaXQpICYgYmxha2UycyAoOCB0byAzMi1iaXQpIGhhc2ggZnVuY3Rpb25zLlxuICogYiBjb3VsZCBoYXZlIGJlZW4gZmFzdGVyLCBidXQgdGhlcmUgaXMgbm8gZmFzdCB1NjQgaW4ganMsIHNvIHMgaXMgMS41eCBmYXN0ZXIuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IEJTSUdNQSwgRzFzLCBHMnMgfSBmcm9tIFwiLi9fYmxha2UuanNcIjtcbmltcG9ydCB7IFNIQTI1Nl9JViB9IGZyb20gXCIuL19tZC5qc1wiO1xuaW1wb3J0ICogYXMgdTY0IGZyb20gXCIuL191NjQuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhbnVtYmVyLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlT3B0SGFzaGVyLCBIYXNoLCBzd2FwMzJJZkJFLCBzd2FwOElmQkUsIHRvQnl0ZXMsIHUzMiB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBTYW1lIGFzIFNIQTUxMl9JViwgYnV0IHN3YXBwZWQgZW5kaWFubmVzczogTEUgaW5zdGVhZCBvZiBCRS4gaXZbMV0gaXMgaXZbMF0sIGV0Yy5cbmNvbnN0IEIyQl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGYzYmNjOTA4LCAweDZhMDllNjY3LCAweDg0Y2FhNzNiLCAweGJiNjdhZTg1LCAweGZlOTRmODJiLCAweDNjNmVmMzcyLCAweDVmMWQzNmYxLCAweGE1NGZmNTNhLFxuICAgIDB4YWRlNjgyZDEsIDB4NTEwZTUyN2YsIDB4MmIzZTZjMWYsIDB4OWIwNTY4OGMsIDB4ZmI0MWJkNmIsIDB4MWY4M2Q5YWIsIDB4MTM3ZTIxNzksIDB4NWJlMGNkMTksXG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IEJCVUYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDMyKTtcbi8vIE1peGluZyBmdW5jdGlvbiBHIHNwbGl0dGVkIGluIHR3byBoYWxmc1xuZnVuY3Rpb24gRzFiKGEsIGIsIGMsIGQsIG1zZywgeCkge1xuICAgIC8vIE5PVEU6IFYgaXMgTEUgaGVyZVxuICAgIGNvbnN0IFhsID0gbXNnW3hdLCBYaCA9IG1zZ1t4ICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBBbCA9IEJCVUZbMiAqIGFdLCBBaCA9IEJCVUZbMiAqIGEgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEJsID0gQkJVRlsyICogYl0sIEJoID0gQkJVRlsyICogYiArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQ2wgPSBCQlVGWzIgKiBjXSwgQ2ggPSBCQlVGWzIgKiBjICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBEbCA9IEJCVUZbMiAqIGRdLCBEaCA9IEJCVUZbMiAqIGQgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgLy8gdlthXSA9ICh2W2FdICsgdltiXSArIHgpIHwgMDtcbiAgICBsZXQgbGwgPSB1NjQuYWRkM0woQWwsIEJsLCBYbCk7XG4gICAgQWggPSB1NjQuYWRkM0gobGwsIEFoLCBCaCwgWGgpO1xuICAgIEFsID0gbGwgfCAwO1xuICAgIC8vIHZbZF0gPSByb3RyKHZbZF0gXiB2W2FdLCAzMilcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IERoIF4gQWgsIERsOiBEbCBeIEFsIH0pO1xuICAgICh7IERoLCBEbCB9ID0geyBEaDogdTY0LnJvdHIzMkgoRGgsIERsKSwgRGw6IHU2NC5yb3RyMzJMKERoLCBEbCkgfSk7XG4gICAgLy8gdltjXSA9ICh2W2NdICsgdltkXSkgfCAwO1xuICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZChDaCwgQ2wsIERoLCBEbCkpO1xuICAgIC8vIHZbYl0gPSByb3RyKHZbYl0gXiB2W2NdLCAyNClcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IEJoIF4gQ2gsIEJsOiBCbCBeIENsIH0pO1xuICAgICh7IEJoLCBCbCB9ID0geyBCaDogdTY0LnJvdHJTSChCaCwgQmwsIDI0KSwgQmw6IHU2NC5yb3RyU0woQmgsIEJsLCAyNCkgfSk7XG4gICAgKEJCVUZbMiAqIGFdID0gQWwpLCAoQkJVRlsyICogYSArIDFdID0gQWgpO1xuICAgIChCQlVGWzIgKiBiXSA9IEJsKSwgKEJCVUZbMiAqIGIgKyAxXSA9IEJoKTtcbiAgICAoQkJVRlsyICogY10gPSBDbCksIChCQlVGWzIgKiBjICsgMV0gPSBDaCk7XG4gICAgKEJCVUZbMiAqIGRdID0gRGwpLCAoQkJVRlsyICogZCArIDFdID0gRGgpO1xufVxuZnVuY3Rpb24gRzJiKGEsIGIsIGMsIGQsIG1zZywgeCkge1xuICAgIC8vIE5PVEU6IFYgaXMgTEUgaGVyZVxuICAgIGNvbnN0IFhsID0gbXNnW3hdLCBYaCA9IG1zZ1t4ICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBBbCA9IEJCVUZbMiAqIGFdLCBBaCA9IEJCVUZbMiAqIGEgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IEJsID0gQkJVRlsyICogYl0sIEJoID0gQkJVRlsyICogYiArIDFdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBsZXQgQ2wgPSBCQlVGWzIgKiBjXSwgQ2ggPSBCQlVGWzIgKiBjICsgMV07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCBEbCA9IEJCVUZbMiAqIGRdLCBEaCA9IEJCVUZbMiAqIGQgKyAxXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgLy8gdlthXSA9ICh2W2FdICsgdltiXSArIHgpIHwgMDtcbiAgICBsZXQgbGwgPSB1NjQuYWRkM0woQWwsIEJsLCBYbCk7XG4gICAgQWggPSB1NjQuYWRkM0gobGwsIEFoLCBCaCwgWGgpO1xuICAgIEFsID0gbGwgfCAwO1xuICAgIC8vIHZbZF0gPSByb3RyKHZbZF0gXiB2W2FdLCAxNilcbiAgICAoeyBEaCwgRGwgfSA9IHsgRGg6IERoIF4gQWgsIERsOiBEbCBeIEFsIH0pO1xuICAgICh7IERoLCBEbCB9ID0geyBEaDogdTY0LnJvdHJTSChEaCwgRGwsIDE2KSwgRGw6IHU2NC5yb3RyU0woRGgsIERsLCAxNikgfSk7XG4gICAgLy8gdltjXSA9ICh2W2NdICsgdltkXSkgfCAwO1xuICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZChDaCwgQ2wsIERoLCBEbCkpO1xuICAgIC8vIHZbYl0gPSByb3RyKHZbYl0gXiB2W2NdLCA2MylcbiAgICAoeyBCaCwgQmwgfSA9IHsgQmg6IEJoIF4gQ2gsIEJsOiBCbCBeIENsIH0pO1xuICAgICh7IEJoLCBCbCB9ID0geyBCaDogdTY0LnJvdHJCSChCaCwgQmwsIDYzKSwgQmw6IHU2NC5yb3RyQkwoQmgsIEJsLCA2MykgfSk7XG4gICAgKEJCVUZbMiAqIGFdID0gQWwpLCAoQkJVRlsyICogYSArIDFdID0gQWgpO1xuICAgIChCQlVGWzIgKiBiXSA9IEJsKSwgKEJCVUZbMiAqIGIgKyAxXSA9IEJoKTtcbiAgICAoQkJVRlsyICogY10gPSBDbCksIChCQlVGWzIgKiBjICsgMV0gPSBDaCk7XG4gICAgKEJCVUZbMiAqIGRdID0gRGwpLCAoQkJVRlsyICogZCArIDFdID0gRGgpO1xufVxuZnVuY3Rpb24gY2hlY2tCbGFrZTJPcHRzKG91dHB1dExlbiwgb3B0cyA9IHt9LCBrZXlMZW4sIHNhbHRMZW4sIHBlcnNMZW4pIHtcbiAgICBhbnVtYmVyKGtleUxlbik7XG4gICAgaWYgKG91dHB1dExlbiA8IDAgfHwgb3V0cHV0TGVuID4ga2V5TGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dHB1dExlbiBiaWdnZXIgdGhhbiBrZXlMZW4nKTtcbiAgICBjb25zdCB7IGtleSwgc2FsdCwgcGVyc29uYWxpemF0aW9uIH0gPSBvcHRzO1xuICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCAmJiAoa2V5Lmxlbmd0aCA8IDEgfHwga2V5Lmxlbmd0aCA+IGtleUxlbikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigna2V5IGxlbmd0aCBtdXN0IGJlIHVuZGVmaW5lZCBvciAxLi4nICsga2V5TGVuKTtcbiAgICBpZiAoc2FsdCAhPT0gdW5kZWZpbmVkICYmIHNhbHQubGVuZ3RoICE9PSBzYWx0TGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NhbHQgbXVzdCBiZSB1bmRlZmluZWQgb3IgJyArIHNhbHRMZW4pO1xuICAgIGlmIChwZXJzb25hbGl6YXRpb24gIT09IHVuZGVmaW5lZCAmJiBwZXJzb25hbGl6YXRpb24ubGVuZ3RoICE9PSBwZXJzTGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BlcnNvbmFsaXphdGlvbiBtdXN0IGJlIHVuZGVmaW5lZCBvciAnICsgcGVyc0xlbik7XG59XG4vKiogQ2xhc3MsIGZyb20gd2hpY2ggb3RoZXJzIGFyZSBzdWJjbGFzc2VkLiAqL1xuZXhwb3J0IGNsYXNzIEJMQUtFMiBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgYW51bWJlcihibG9ja0xlbik7XG4gICAgICAgIGFudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMuYnVmZmVyMzIgPSB1MzIodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICAvLyBNYWluIGRpZmZlcmVuY2Ugd2l0aCBvdGhlciBoYXNoZXM6IHRoZXJlIGlzIGZsYWcgZm9yIGxhc3QgYmxvY2ssXG4gICAgICAgIC8vIHNvIHdlIGNhbm5vdCBwcm9jZXNzIGN1cnJlbnQgYmxvY2sgYmVmb3JlIHdlIGtub3cgdGhhdCB0aGVyZVxuICAgICAgICAvLyBpcyB0aGUgbmV4dCBvbmUuIFRoaXMgc2lnbmlmaWNhbnRseSBjb21wbGljYXRlcyBsb2dpYyBhbmQgcmVkdWNlcyBhYmlsaXR5XG4gICAgICAgIC8vIHRvIGRvIHplcm8tY29weSBwcm9jZXNzaW5nXG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgYnVmZmVyMzIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuYnVmZmVyO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICAvLyBJZiBidWZmZXIgaXMgZnVsbCBhbmQgd2Ugc3RpbGwgaGF2ZSBpbnB1dCAoZG9uJ3QgcHJvY2VzcyBsYXN0IGJsb2NrLCBzYW1lIGFzIGJsYWtlMnMpXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgc3dhcDMySWZCRShidWZmZXIzMik7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wcmVzcyhidWZmZXIzMiwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHN3YXAzMklmQkUoYnVmZmVyMzIpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgY29uc3QgZGF0YU9mZnNldCA9IG9mZnNldCArIHBvcztcbiAgICAgICAgICAgIC8vIGZ1bGwgYmxvY2sgJiYgYWxpZ25lZCB0byA0IGJ5dGVzICYmIG5vdCBsYXN0IGluIGlucHV0XG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4gJiYgIShkYXRhT2Zmc2V0ICUgNCkgJiYgcG9zICsgdGFrZSA8IGxlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEzMiA9IG5ldyBVaW50MzJBcnJheShidWYsIGRhdGFPZmZzZXQsIE1hdGguZmxvb3IoKGxlbiAtIHBvcykgLyA0KSk7XG4gICAgICAgICAgICAgICAgc3dhcDMySWZCRShkYXRhMzIpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvczMyID0gMDsgcG9zICsgYmxvY2tMZW4gPCBsZW47IHBvczMyICs9IGJ1ZmZlcjMyLmxlbmd0aCwgcG9zICs9IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoICs9IGJsb2NrTGVuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXByZXNzKGRhdGEzMiwgcG9zMzIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dhcDMySWZCRShkYXRhMzIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgY29uc3QgeyBwb3MsIGJ1ZmZlcjMyIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAgICAgc3dhcDMySWZCRShidWZmZXIzMik7XG4gICAgICAgIHRoaXMuY29tcHJlc3MoYnVmZmVyMzIsIDAsIHRydWUpO1xuICAgICAgICBzd2FwMzJJZkJFKGJ1ZmZlcjMyKTtcbiAgICAgICAgY29uc3Qgb3V0MzIgPSB1MzIob3V0KTtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKCh2LCBpKSA9PiAob3V0MzJbaV0gPSBzd2FwOElmQkUodikpKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIG91dHB1dExlbiwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih7IGRrTGVuOiBvdXRwdXRMZW4gfSkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQkxBS0UyYiBleHRlbmRzIEJMQUtFMiB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG9sZW4gPSBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyA2NCA6IG9wdHMuZGtMZW47XG4gICAgICAgIHN1cGVyKDEyOCwgb2xlbik7XG4gICAgICAgIC8vIFNhbWUgYXMgU0hBLTUxMiwgYnV0IExFXG4gICAgICAgIHRoaXMudjBsID0gQjJCX0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy52MGggPSBCMkJfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLnYxbCA9IEIyQl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMudjFoID0gQjJCX0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy52MmwgPSBCMkJfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLnYyaCA9IEIyQl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMudjNsID0gQjJCX0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy52M2ggPSBCMkJfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLnY0bCA9IEIyQl9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMudjRoID0gQjJCX0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy52NWwgPSBCMkJfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy52NWggPSBCMkJfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy52NmwgPSBCMkJfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy52NmggPSBCMkJfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy52N2wgPSBCMkJfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy52N2ggPSBCMkJfSVZbMTVdIHwgMDtcbiAgICAgICAgY2hlY2tCbGFrZTJPcHRzKG9sZW4sIG9wdHMsIDY0LCAxNiwgMTYpO1xuICAgICAgICBsZXQgeyBrZXksIHBlcnNvbmFsaXphdGlvbiwgc2FsdCB9ID0gb3B0cztcbiAgICAgICAgbGV0IGtleUxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAga2V5ID0gdG9CeXRlcyhrZXkpO1xuICAgICAgICAgICAga2V5TGVuZ3RoID0ga2V5Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnYwbCBePSB0aGlzLm91dHB1dExlbiB8IChrZXlMZW5ndGggPDwgOCkgfCAoMHgwMSA8PCAxNikgfCAoMHgwMSA8PCAyNCk7XG4gICAgICAgIGlmIChzYWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNhbHQgPSB0b0J5dGVzKHNhbHQpO1xuICAgICAgICAgICAgY29uc3Qgc2x0ID0gdTMyKHNhbHQpO1xuICAgICAgICAgICAgdGhpcy52NGwgXj0gc3dhcDhJZkJFKHNsdFswXSk7XG4gICAgICAgICAgICB0aGlzLnY0aCBePSBzd2FwOElmQkUoc2x0WzFdKTtcbiAgICAgICAgICAgIHRoaXMudjVsIF49IHN3YXA4SWZCRShzbHRbMl0pO1xuICAgICAgICAgICAgdGhpcy52NWggXj0gc3dhcDhJZkJFKHNsdFszXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcnNvbmFsaXphdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwZXJzb25hbGl6YXRpb24gPSB0b0J5dGVzKHBlcnNvbmFsaXphdGlvbik7XG4gICAgICAgICAgICBjb25zdCBwZXJzID0gdTMyKHBlcnNvbmFsaXphdGlvbik7XG4gICAgICAgICAgICB0aGlzLnY2bCBePSBzd2FwOElmQkUocGVyc1swXSk7XG4gICAgICAgICAgICB0aGlzLnY2aCBePSBzd2FwOElmQkUocGVyc1sxXSk7XG4gICAgICAgICAgICB0aGlzLnY3bCBePSBzd2FwOElmQkUocGVyc1syXSk7XG4gICAgICAgICAgICB0aGlzLnY3aCBePSBzd2FwOElmQkUocGVyc1szXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBQYWQgdG8gYmxvY2tMZW4gYW5kIHVwZGF0ZVxuICAgICAgICAgICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5ibG9ja0xlbik7XG4gICAgICAgICAgICB0bXAuc2V0KGtleSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh0bXApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgbGV0IHsgdjBsLCB2MGgsIHYxbCwgdjFoLCB2MmwsIHYyaCwgdjNsLCB2M2gsIHY0bCwgdjRoLCB2NWwsIHY1aCwgdjZsLCB2NmgsIHY3bCwgdjdoIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW3YwbCwgdjBoLCB2MWwsIHYxaCwgdjJsLCB2MmgsIHYzbCwgdjNoLCB2NGwsIHY0aCwgdjVsLCB2NWgsIHY2bCwgdjZoLCB2N2wsIHY3aF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldCh2MGwsIHYwaCwgdjFsLCB2MWgsIHYybCwgdjJoLCB2M2wsIHYzaCwgdjRsLCB2NGgsIHY1bCwgdjVoLCB2NmwsIHY2aCwgdjdsLCB2N2gpIHtcbiAgICAgICAgdGhpcy52MGwgPSB2MGwgfCAwO1xuICAgICAgICB0aGlzLnYwaCA9IHYwaCB8IDA7XG4gICAgICAgIHRoaXMudjFsID0gdjFsIHwgMDtcbiAgICAgICAgdGhpcy52MWggPSB2MWggfCAwO1xuICAgICAgICB0aGlzLnYybCA9IHYybCB8IDA7XG4gICAgICAgIHRoaXMudjJoID0gdjJoIHwgMDtcbiAgICAgICAgdGhpcy52M2wgPSB2M2wgfCAwO1xuICAgICAgICB0aGlzLnYzaCA9IHYzaCB8IDA7XG4gICAgICAgIHRoaXMudjRsID0gdjRsIHwgMDtcbiAgICAgICAgdGhpcy52NGggPSB2NGggfCAwO1xuICAgICAgICB0aGlzLnY1bCA9IHY1bCB8IDA7XG4gICAgICAgIHRoaXMudjVoID0gdjVoIHwgMDtcbiAgICAgICAgdGhpcy52NmwgPSB2NmwgfCAwO1xuICAgICAgICB0aGlzLnY2aCA9IHY2aCB8IDA7XG4gICAgICAgIHRoaXMudjdsID0gdjdsIHwgMDtcbiAgICAgICAgdGhpcy52N2ggPSB2N2ggfCAwO1xuICAgIH1cbiAgICBjb21wcmVzcyhtc2csIG9mZnNldCwgaXNMYXN0KSB7XG4gICAgICAgIHRoaXMuZ2V0KCkuZm9yRWFjaCgodiwgaSkgPT4gKEJCVUZbaV0gPSB2KSk7IC8vIEZpcnN0IGhhbGYgZnJvbSBzdGF0ZS5cbiAgICAgICAgQkJVRi5zZXQoQjJCX0lWLCAxNik7IC8vIFNlY29uZCBoYWxmIGZyb20gSVYuXG4gICAgICAgIGxldCB7IGgsIGwgfSA9IHU2NC5mcm9tQmlnKEJpZ0ludCh0aGlzLmxlbmd0aCkpO1xuICAgICAgICBCQlVGWzI0XSA9IEIyQl9JVls4XSBeIGw7IC8vIExvdyB3b3JkIG9mIHRoZSBvZmZzZXQuXG4gICAgICAgIEJCVUZbMjVdID0gQjJCX0lWWzldIF4gaDsgLy8gSGlnaCB3b3JkLlxuICAgICAgICAvLyBJbnZlcnQgYWxsIGJpdHMgZm9yIGxhc3QgYmxvY2tcbiAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgQkJVRlsyOF0gPSB+QkJVRlsyOF07XG4gICAgICAgICAgICBCQlVGWzI5XSA9IH5CQlVGWzI5XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaiA9IDA7XG4gICAgICAgIGNvbnN0IHMgPSBCU0lHTUE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgRzFiKDAsIDQsIDgsIDEyLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDAsIDQsIDgsIDEyLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDEsIDUsIDksIDEzLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDEsIDUsIDksIDEzLCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDIsIDYsIDEwLCAxNCwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigyLCA2LCAxMCwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMywgNywgMTEsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzJiKDMsIDcsIDExLCAxNSwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcxYigwLCA1LCAxMCwgMTUsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMCwgNSwgMTAsIDE1LCBtc2csIG9mZnNldCArIDIgKiBzW2orK10pO1xuICAgICAgICAgICAgRzFiKDEsIDYsIDExLCAxMiwgbXNnLCBvZmZzZXQgKyAyICogc1tqKytdKTtcbiAgICAgICAgICAgIEcyYigxLCA2LCAxMSwgMTIsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMiwgNywgOCwgMTMsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMiwgNywgOCwgMTMsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMWIoMywgNCwgOSwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgICAgICBHMmIoMywgNCwgOSwgMTQsIG1zZywgb2Zmc2V0ICsgMiAqIHNbaisrXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52MGwgXj0gQkJVRlswXSBeIEJCVUZbMTZdO1xuICAgICAgICB0aGlzLnYwaCBePSBCQlVGWzFdIF4gQkJVRlsxN107XG4gICAgICAgIHRoaXMudjFsIF49IEJCVUZbMl0gXiBCQlVGWzE4XTtcbiAgICAgICAgdGhpcy52MWggXj0gQkJVRlszXSBeIEJCVUZbMTldO1xuICAgICAgICB0aGlzLnYybCBePSBCQlVGWzRdIF4gQkJVRlsyMF07XG4gICAgICAgIHRoaXMudjJoIF49IEJCVUZbNV0gXiBCQlVGWzIxXTtcbiAgICAgICAgdGhpcy52M2wgXj0gQkJVRls2XSBeIEJCVUZbMjJdO1xuICAgICAgICB0aGlzLnYzaCBePSBCQlVGWzddIF4gQkJVRlsyM107XG4gICAgICAgIHRoaXMudjRsIF49IEJCVUZbOF0gXiBCQlVGWzI0XTtcbiAgICAgICAgdGhpcy52NGggXj0gQkJVRls5XSBeIEJCVUZbMjVdO1xuICAgICAgICB0aGlzLnY1bCBePSBCQlVGWzEwXSBeIEJCVUZbMjZdO1xuICAgICAgICB0aGlzLnY1aCBePSBCQlVGWzExXSBeIEJCVUZbMjddO1xuICAgICAgICB0aGlzLnY2bCBePSBCQlVGWzEyXSBeIEJCVUZbMjhdO1xuICAgICAgICB0aGlzLnY2aCBePSBCQlVGWzEzXSBeIEJCVUZbMjldO1xuICAgICAgICB0aGlzLnY3bCBePSBCQlVGWzE0XSBeIEJCVUZbMzBdO1xuICAgICAgICB0aGlzLnY3aCBePSBCQlVGWzE1XSBeIEJCVUZbMzFdO1xuICAgICAgICBjbGVhbihCQlVGKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcjMyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuLyoqXG4gKiBCbGFrZTJiIGhhc2ggZnVuY3Rpb24uIDY0LWJpdC4gMS41eCBzbG93ZXIgdGhhbiBibGFrZTJzIGluIEpTLlxuICogQHBhcmFtIG1zZyAtIG1lc3NhZ2UgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqIEBwYXJhbSBvcHRzIC0gZGtMZW4gb3V0cHV0IGxlbmd0aCwga2V5IGZvciBNQUMgbW9kZSwgc2FsdCwgcGVyc29uYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBibGFrZTJiID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZU9wdEhhc2hlcigob3B0cykgPT4gbmV3IEJMQUtFMmIob3B0cykpO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3Mocywgb2Zmc2V0LCBtc2csIHJvdW5kcywgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUpIHtcbiAgICBsZXQgaiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHM7IGkrKykge1xuICAgICAgICAoeyBhOiB2MCwgYjogdjQsIGM6IHY4LCBkOiB2MTIgfSA9IEcxcyh2MCwgdjQsIHY4LCB2MTIsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYwLCBiOiB2NCwgYzogdjgsIGQ6IHYxMiB9ID0gRzJzKHYwLCB2NCwgdjgsIHYxMiwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjEsIGI6IHY1LCBjOiB2OSwgZDogdjEzIH0gPSBHMXModjEsIHY1LCB2OSwgdjEzLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MSwgYjogdjUsIGM6IHY5LCBkOiB2MTMgfSA9IEcycyh2MSwgdjUsIHY5LCB2MTMsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYyLCBiOiB2NiwgYzogdjEwLCBkOiB2MTQgfSA9IEcxcyh2MiwgdjYsIHYxMCwgdjE0LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MiwgYjogdjYsIGM6IHYxMCwgZDogdjE0IH0gPSBHMnModjIsIHY2LCB2MTAsIHYxNCwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjMsIGI6IHY3LCBjOiB2MTEsIGQ6IHYxNSB9ID0gRzFzKHYzLCB2NywgdjExLCB2MTUsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYzLCBiOiB2NywgYzogdjExLCBkOiB2MTUgfSA9IEcycyh2MywgdjcsIHYxMSwgdjE1LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MCwgYjogdjUsIGM6IHYxMCwgZDogdjE1IH0gPSBHMXModjAsIHY1LCB2MTAsIHYxNSwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjAsIGI6IHY1LCBjOiB2MTAsIGQ6IHYxNSB9ID0gRzJzKHYwLCB2NSwgdjEwLCB2MTUsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYxLCBiOiB2NiwgYzogdjExLCBkOiB2MTIgfSA9IEcxcyh2MSwgdjYsIHYxMSwgdjEyLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MSwgYjogdjYsIGM6IHYxMSwgZDogdjEyIH0gPSBHMnModjEsIHY2LCB2MTEsIHYxMiwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjIsIGI6IHY3LCBjOiB2OCwgZDogdjEzIH0gPSBHMXModjIsIHY3LCB2OCwgdjEzLCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgICAgICAoeyBhOiB2MiwgYjogdjcsIGM6IHY4LCBkOiB2MTMgfSA9IEcycyh2MiwgdjcsIHY4LCB2MTMsIG1zZ1tvZmZzZXQgKyBzW2orK11dKSk7XG4gICAgICAgICh7IGE6IHYzLCBiOiB2NCwgYzogdjksIGQ6IHYxNCB9ID0gRzFzKHYzLCB2NCwgdjksIHYxNCwgbXNnW29mZnNldCArIHNbaisrXV0pKTtcbiAgICAgICAgKHsgYTogdjMsIGI6IHY0LCBjOiB2OSwgZDogdjE0IH0gPSBHMnModjMsIHY0LCB2OSwgdjE0LCBtc2dbb2Zmc2V0ICsgc1tqKytdXSkpO1xuICAgIH1cbiAgICByZXR1cm4geyB2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjcsIHY4LCB2OSwgdjEwLCB2MTEsIHYxMiwgdjEzLCB2MTQsIHYxNSB9O1xufVxuY29uc3QgQjJTX0lWID0gU0hBMjU2X0lWO1xuZXhwb3J0IGNsYXNzIEJMQUtFMnMgZXh0ZW5kcyBCTEFLRTIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBvbGVuID0gb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gMzIgOiBvcHRzLmRrTGVuO1xuICAgICAgICBzdXBlcig2NCwgb2xlbik7XG4gICAgICAgIC8vIEludGVybmFsIHN0YXRlLCBzYW1lIGFzIFNIQS0yNTZcbiAgICAgICAgdGhpcy52MCA9IEIyU19JVlswXSB8IDA7XG4gICAgICAgIHRoaXMudjEgPSBCMlNfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLnYyID0gQjJTX0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy52MyA9IEIyU19JVlszXSB8IDA7XG4gICAgICAgIHRoaXMudjQgPSBCMlNfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLnY1ID0gQjJTX0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy52NiA9IEIyU19JVls2XSB8IDA7XG4gICAgICAgIHRoaXMudjcgPSBCMlNfSVZbN10gfCAwO1xuICAgICAgICBjaGVja0JsYWtlMk9wdHMob2xlbiwgb3B0cywgMzIsIDgsIDgpO1xuICAgICAgICBsZXQgeyBrZXksIHBlcnNvbmFsaXphdGlvbiwgc2FsdCB9ID0gb3B0cztcbiAgICAgICAgbGV0IGtleUxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChrZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAga2V5ID0gdG9CeXRlcyhrZXkpO1xuICAgICAgICAgICAga2V5TGVuZ3RoID0ga2V5Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnYwIF49IHRoaXMub3V0cHV0TGVuIHwgKGtleUxlbmd0aCA8PCA4KSB8ICgweDAxIDw8IDE2KSB8ICgweDAxIDw8IDI0KTtcbiAgICAgICAgaWYgKHNhbHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2FsdCA9IHRvQnl0ZXMoc2FsdCk7XG4gICAgICAgICAgICBjb25zdCBzbHQgPSB1MzIoc2FsdCk7XG4gICAgICAgICAgICB0aGlzLnY0IF49IHN3YXA4SWZCRShzbHRbMF0pO1xuICAgICAgICAgICAgdGhpcy52NSBePSBzd2FwOElmQkUoc2x0WzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGVyc29uYWxpemF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBlcnNvbmFsaXphdGlvbiA9IHRvQnl0ZXMocGVyc29uYWxpemF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcnMgPSB1MzIocGVyc29uYWxpemF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudjYgXj0gc3dhcDhJZkJFKHBlcnNbMF0pO1xuICAgICAgICAgICAgdGhpcy52NyBePSBzd2FwOElmQkUocGVyc1sxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBQYWQgdG8gYmxvY2tMZW4gYW5kIHVwZGF0ZVxuICAgICAgICAgICAgYWJ5dGVzKGtleSk7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheSh0aGlzLmJsb2NrTGVuKTtcbiAgICAgICAgICAgIHRtcC5zZXQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHRtcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IHYwLCB2MSwgdjIsIHYzLCB2NCwgdjUsIHY2LCB2NyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFt2MCwgdjEsIHYyLCB2MywgdjQsIHY1LCB2NiwgdjddO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQodjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3KSB7XG4gICAgICAgIHRoaXMudjAgPSB2MCB8IDA7XG4gICAgICAgIHRoaXMudjEgPSB2MSB8IDA7XG4gICAgICAgIHRoaXMudjIgPSB2MiB8IDA7XG4gICAgICAgIHRoaXMudjMgPSB2MyB8IDA7XG4gICAgICAgIHRoaXMudjQgPSB2NCB8IDA7XG4gICAgICAgIHRoaXMudjUgPSB2NSB8IDA7XG4gICAgICAgIHRoaXMudjYgPSB2NiB8IDA7XG4gICAgICAgIHRoaXMudjcgPSB2NyB8IDA7XG4gICAgfVxuICAgIGNvbXByZXNzKG1zZywgb2Zmc2V0LCBpc0xhc3QpIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSB1NjQuZnJvbUJpZyhCaWdJbnQodGhpcy5sZW5ndGgpKTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IHsgdjAsIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIHY3LCB2OCwgdjksIHYxMCwgdjExLCB2MTIsIHYxMywgdjE0LCB2MTUgfSA9IGNvbXByZXNzKEJTSUdNQSwgb2Zmc2V0LCBtc2csIDEwLCB0aGlzLnYwLCB0aGlzLnYxLCB0aGlzLnYyLCB0aGlzLnYzLCB0aGlzLnY0LCB0aGlzLnY1LCB0aGlzLnY2LCB0aGlzLnY3LCBCMlNfSVZbMF0sIEIyU19JVlsxXSwgQjJTX0lWWzJdLCBCMlNfSVZbM10sIGwgXiBCMlNfSVZbNF0sIGggXiBCMlNfSVZbNV0sIGlzTGFzdCA/IH5CMlNfSVZbNl0gOiBCMlNfSVZbNl0sIEIyU19JVls3XSk7XG4gICAgICAgIHRoaXMudjAgXj0gdjAgXiB2ODtcbiAgICAgICAgdGhpcy52MSBePSB2MSBeIHY5O1xuICAgICAgICB0aGlzLnYyIF49IHYyIF4gdjEwO1xuICAgICAgICB0aGlzLnYzIF49IHYzIF4gdjExO1xuICAgICAgICB0aGlzLnY0IF49IHY0IF4gdjEyO1xuICAgICAgICB0aGlzLnY1IF49IHY1IF4gdjEzO1xuICAgICAgICB0aGlzLnY2IF49IHY2IF4gdjE0O1xuICAgICAgICB0aGlzLnY3IF49IHY3IF4gdjE1O1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyMzIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG4vKipcbiAqIEJsYWtlMnMgaGFzaCBmdW5jdGlvbi4gRm9jdXNlcyBvbiA4LWJpdCB0byAzMi1iaXQgcGxhdGZvcm1zLiAxLjV4IGZhc3RlciB0aGFuIGJsYWtlMmIgaW4gSlMuXG4gKiBAcGFyYW0gbXNnIC0gbWVzc2FnZSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICogQHBhcmFtIG9wdHMgLSBka0xlbiBvdXRwdXQgbGVuZ3RoLCBrZXkgZm9yIE1BQyBtb2RlLCBzYWx0LCBwZXJzb25hbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGJsYWtlMnMgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlT3B0SGFzaGVyKChvcHRzKSA9PiBuZXcgQkxBS0UycyhvcHRzKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibGFrZTIuanMubWFwIl0sIm5hbWVzIjpbIkJTSUdNQSIsIkcxcyIsIkcycyIsIlNIQTI1Nl9JViIsInU2NCIsImFieXRlcyIsImFleGlzdHMiLCJhbnVtYmVyIiwiYW91dHB1dCIsImNsZWFuIiwiY3JlYXRlT3B0SGFzaGVyIiwiSGFzaCIsInN3YXAzMklmQkUiLCJzd2FwOElmQkUiLCJ0b0J5dGVzIiwidTMyIiwiQjJCX0lWIiwiVWludDMyQXJyYXkiLCJmcm9tIiwiQkJVRiIsIkcxYiIsImEiLCJiIiwiYyIsImQiLCJtc2ciLCJ4IiwiWGwiLCJYaCIsIkFsIiwiQWgiLCJCbCIsIkJoIiwiQ2wiLCJDaCIsIkRsIiwiRGgiLCJsbCIsImFkZDNMIiwiYWRkM0giLCJyb3RyMzJIIiwicm90cjMyTCIsImgiLCJsIiwiYWRkIiwicm90clNIIiwicm90clNMIiwiRzJiIiwicm90ckJIIiwicm90ckJMIiwiY2hlY2tCbGFrZTJPcHRzIiwib3V0cHV0TGVuIiwib3B0cyIsImtleUxlbiIsInNhbHRMZW4iLCJwZXJzTGVuIiwiRXJyb3IiLCJrZXkiLCJzYWx0IiwicGVyc29uYWxpemF0aW9uIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiQkxBS0UyIiwiY29uc3RydWN0b3IiLCJibG9ja0xlbiIsImZpbmlzaGVkIiwiZGVzdHJveWVkIiwicG9zIiwiYnVmZmVyIiwiVWludDhBcnJheSIsImJ1ZmZlcjMyIiwidXBkYXRlIiwiZGF0YSIsImxlbiIsIm9mZnNldCIsImJ5dGVPZmZzZXQiLCJidWYiLCJjb21wcmVzcyIsInRha2UiLCJNYXRoIiwibWluIiwiZGF0YU9mZnNldCIsImRhdGEzMiIsImZsb29yIiwicG9zMzIiLCJzZXQiLCJzdWJhcnJheSIsImRpZ2VzdEludG8iLCJvdXQiLCJvdXQzMiIsImdldCIsImZvckVhY2giLCJ2IiwiaSIsImRpZ2VzdCIsInJlcyIsInNsaWNlIiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsImRrTGVuIiwiY2xvbmUiLCJCTEFLRTJiIiwib2xlbiIsInYwbCIsInYwaCIsInYxbCIsInYxaCIsInYybCIsInYyaCIsInYzbCIsInYzaCIsInY0bCIsInY0aCIsInY1bCIsInY1aCIsInY2bCIsInY2aCIsInY3bCIsInY3aCIsImtleUxlbmd0aCIsInNsdCIsInBlcnMiLCJ0bXAiLCJpc0xhc3QiLCJmcm9tQmlnIiwiQmlnSW50IiwiaiIsInMiLCJibGFrZTJiIiwicm91bmRzIiwidjAiLCJ2MSIsInYyIiwidjMiLCJ2NCIsInY1IiwidjYiLCJ2NyIsInY4IiwidjkiLCJ2MTAiLCJ2MTEiLCJ2MTIiLCJ2MTMiLCJ2MTQiLCJ2MTUiLCJCMlNfSVYiLCJCTEFLRTJzIiwiYmxha2UycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/blake2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/blake2b.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/blake2b.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BLAKE2b: () => (/* binding */ BLAKE2b),\n/* harmony export */   blake2b: () => (/* binding */ blake2b)\n/* harmony export */ });\n/* harmony import */ var _blake2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blake2.js */ \"(ssr)/./node_modules/@noble/hashes/esm/blake2.js\");\n/**\n * Blake2b hash function. Focuses on 64-bit platforms, but in JS speed different from Blake2s is negligible.\n * @module\n * @deprecated\n */ \n/** @deprecated Use import from `noble/hashes/blake2` module */ const BLAKE2b = _blake2_js__WEBPACK_IMPORTED_MODULE_0__.BLAKE2b;\n/** @deprecated Use import from `noble/hashes/blake2` module */ const blake2b = _blake2_js__WEBPACK_IMPORTED_MODULE_0__.blake2b; //# sourceMappingURL=blake2b.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vYmxha2UyYi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7OztDQUlDLEdBQzREO0FBQzdELDZEQUE2RCxHQUN0RCxNQUFNQSxVQUFVQywrQ0FBR0EsQ0FBQztBQUMzQiw2REFBNkQsR0FDdEQsTUFBTUMsVUFBVUMsK0NBQUdBLENBQUMsQ0FDM0IsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29tbXVuZS1wYWdlLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2JsYWtlMmIuanM/ZmNmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJsYWtlMmIgaGFzaCBmdW5jdGlvbi4gRm9jdXNlcyBvbiA2NC1iaXQgcGxhdGZvcm1zLCBidXQgaW4gSlMgc3BlZWQgZGlmZmVyZW50IGZyb20gQmxha2UycyBpcyBuZWdsaWdpYmxlLlxuICogQG1vZHVsZVxuICogQGRlcHJlY2F0ZWRcbiAqL1xuaW1wb3J0IHsgQkxBS0UyYiBhcyBCMkIsIGJsYWtlMmIgYXMgYjJiIH0gZnJvbSBcIi4vYmxha2UyLmpzXCI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvYmxha2UyYCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBCTEFLRTJiID0gQjJCO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL2JsYWtlMmAgbW9kdWxlICovXG5leHBvcnQgY29uc3QgYmxha2UyYiA9IGIyYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsYWtlMmIuanMubWFwIl0sIm5hbWVzIjpbIkJMQUtFMmIiLCJCMkIiLCJibGFrZTJiIiwiYjJiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/blake2b.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js":
/*!******************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */ // @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto : /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === \"object\" && \"randomBytes\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) ? /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) : undefined; //# sourceMappingURL=cryptoNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDRCxhQUFhO0FBQ3FCO0FBQzNCLE1BQU1DLFNBQVNELDJNQUFFQSxJQUFJLE9BQU9BLDJNQUFFQSxLQUFLLFlBQVksME5BQWlCQSxHQUNqRUEsa0RBQVksR0FDWkEsMk1BQUVBLElBQUksT0FBT0EsMk1BQUVBLEtBQUssWUFBWSw0TkFBbUJBLEdBQy9DQSwyTUFBRUEsR0FDRkcsVUFBVSxDQUNwQixzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21tdW5lLXBhZ2UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvTm9kZS5qcz9kYTVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgd2ViY3J5cHRvIGFsaWFzLlxuICogV2UgcHJlZmVyIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBub2RlLmpzIDE2Ky5cbiAqIEZhbGxzIGJhY2sgdG8gTm9kZS5qcyBidWlsdC1pbiBjcnlwdG8gZm9yIE5vZGUuanMgPD12MTQuXG4gKiBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIG5jIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBjb25zdCBjcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jXG4gICAgPyBuYy53ZWJjcnlwdG9cbiAgICA6IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3JhbmRvbUJ5dGVzJyBpbiBuY1xuICAgICAgICA/IG5jXG4gICAgICAgIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOlsibmMiLCJjcnlwdG8iLCJ3ZWJjcnlwdG8iLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */ \nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key){\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== \"function\") throw new Error(\"Expected instance of class which extends utils.Hash\");\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(pad);\n    }\n    update(buf) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0NBR0MsR0FDeUU7QUFDbkUsTUFBTU0sYUFBYUYsMkNBQUlBO0lBQzFCRyxZQUFZQyxJQUFJLEVBQUVDLElBQUksQ0FBRTtRQUNwQixLQUFLO1FBQ0wsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakJULGdEQUFLQSxDQUFDTTtRQUNOLE1BQU1JLE1BQU1QLGtEQUFPQSxDQUFDSTtRQUNwQixJQUFJLENBQUNJLEtBQUssR0FBR0wsS0FBS00sTUFBTTtRQUN4QixJQUFJLE9BQU8sSUFBSSxDQUFDRCxLQUFLLENBQUNFLE1BQU0sS0FBSyxZQUM3QixNQUFNLElBQUlDLE1BQU07UUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSSxDQUFDSixLQUFLLENBQUNJLFFBQVE7UUFDbkMsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSSxDQUFDTCxLQUFLLENBQUNLLFNBQVM7UUFDckMsTUFBTUQsV0FBVyxJQUFJLENBQUNBLFFBQVE7UUFDOUIsTUFBTUUsTUFBTSxJQUFJQyxXQUFXSDtRQUMzQix3Q0FBd0M7UUFDeENFLElBQUlFLEdBQUcsQ0FBQ1QsSUFBSVUsTUFBTSxHQUFHTCxXQUFXVCxLQUFLTSxNQUFNLEdBQUdDLE1BQU0sQ0FBQ0gsS0FBS1csTUFBTSxLQUFLWDtRQUNyRSxJQUFLLElBQUlZLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUk7UUFDZCxJQUFJLENBQUNYLEtBQUssQ0FBQ0UsTUFBTSxDQUFDSTtRQUNsQixtSEFBbUg7UUFDbkgsSUFBSSxDQUFDTSxLQUFLLEdBQUdqQixLQUFLTSxNQUFNO1FBQ3hCLHVDQUF1QztRQUN2QyxJQUFLLElBQUlVLElBQUksR0FBR0EsSUFBSUwsSUFBSUcsTUFBTSxFQUFFRSxJQUM1QkwsR0FBRyxDQUFDSyxFQUFFLElBQUksT0FBTztRQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQ1YsTUFBTSxDQUFDSTtRQUNsQmhCLGdEQUFLQSxDQUFDZ0I7SUFDVjtJQUNBSixPQUFPVyxHQUFHLEVBQUU7UUFDUnpCLGtEQUFPQSxDQUFDLElBQUk7UUFDWixJQUFJLENBQUNZLEtBQUssQ0FBQ0UsTUFBTSxDQUFDVztRQUNsQixPQUFPLElBQUk7SUFDZjtJQUNBQyxXQUFXQyxHQUFHLEVBQUU7UUFDWjNCLGtEQUFPQSxDQUFDLElBQUk7UUFDWkQsaURBQU1BLENBQUM0QixLQUFLLElBQUksQ0FBQ1YsU0FBUztRQUMxQixJQUFJLENBQUNSLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNHLEtBQUssQ0FBQ2MsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNILEtBQUssQ0FBQ1YsTUFBTSxDQUFDYTtRQUNsQixJQUFJLENBQUNILEtBQUssQ0FBQ0UsVUFBVSxDQUFDQztRQUN0QixJQUFJLENBQUNDLE9BQU87SUFDaEI7SUFDQU4sU0FBUztRQUNMLE1BQU1LLE1BQU0sSUFBSVIsV0FBVyxJQUFJLENBQUNLLEtBQUssQ0FBQ1AsU0FBUztRQUMvQyxJQUFJLENBQUNTLFVBQVUsQ0FBQ0M7UUFDaEIsT0FBT0E7SUFDWDtJQUNBRSxXQUFXQyxFQUFFLEVBQUU7UUFDWCxtR0FBbUc7UUFDbkdBLE1BQU9BLENBQUFBLEtBQUtDLE9BQU9sQixNQUFNLENBQUNrQixPQUFPQyxjQUFjLENBQUMsSUFBSSxHQUFHLENBQUMsRUFBQztRQUN6RCxNQUFNLEVBQUVSLEtBQUssRUFBRVosS0FBSyxFQUFFSCxRQUFRLEVBQUVDLFNBQVMsRUFBRU0sUUFBUSxFQUFFQyxTQUFTLEVBQUUsR0FBRyxJQUFJO1FBQ3ZFYSxLQUFLQTtRQUNMQSxHQUFHckIsUUFBUSxHQUFHQTtRQUNkcUIsR0FBR3BCLFNBQVMsR0FBR0E7UUFDZm9CLEdBQUdkLFFBQVEsR0FBR0E7UUFDZGMsR0FBR2IsU0FBUyxHQUFHQTtRQUNmYSxHQUFHTixLQUFLLEdBQUdBLE1BQU1LLFVBQVUsQ0FBQ0MsR0FBR04sS0FBSztRQUNwQ00sR0FBR2xCLEtBQUssR0FBR0EsTUFBTWlCLFVBQVUsQ0FBQ0MsR0FBR2xCLEtBQUs7UUFDcEMsT0FBT2tCO0lBQ1g7SUFDQUcsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDSixVQUFVO0lBQzFCO0lBQ0FELFVBQVU7UUFDTixJQUFJLENBQUNsQixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDYyxLQUFLLENBQUNJLE9BQU87UUFDbEIsSUFBSSxDQUFDaEIsS0FBSyxDQUFDZ0IsT0FBTztJQUN0QjtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTU0sT0FBTyxDQUFDM0IsTUFBTUksS0FBS3dCLFVBQVksSUFBSTlCLEtBQUtFLE1BQU1JLEtBQUtHLE1BQU0sQ0FBQ3FCLFNBQVNiLE1BQU0sR0FBRztBQUN6RlksS0FBS3JCLE1BQU0sR0FBRyxDQUFDTixNQUFNSSxNQUFRLElBQUlOLEtBQUtFLE1BQU1JLE1BQzVDLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbW11bmUtcGFnZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzPzBjY2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhaGFzaCwgY2xlYW4sIEhhc2gsIHRvQnl0ZXMgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYWhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgY2xlYW4ocGFkKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgYWJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuICogaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyJztcbiAqIGNvbnN0IG1hYzEgPSBobWFjKHNoYTI1NiwgJ2tleScsICdtZXNzYWdlJyk7XG4gKi9cbmV4cG9ydCBjb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1obWFjLmpzLm1hcCJdLCJuYW1lcyI6WyJhYnl0ZXMiLCJhZXhpc3RzIiwiYWhhc2giLCJjbGVhbiIsIkhhc2giLCJ0b0J5dGVzIiwiSE1BQyIsImNvbnN0cnVjdG9yIiwiaGFzaCIsIl9rZXkiLCJmaW5pc2hlZCIsImRlc3Ryb3llZCIsImtleSIsImlIYXNoIiwiY3JlYXRlIiwidXBkYXRlIiwiRXJyb3IiLCJibG9ja0xlbiIsIm91dHB1dExlbiIsInBhZCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJsZW5ndGgiLCJkaWdlc3QiLCJpIiwib0hhc2giLCJidWYiLCJkaWdlc3RJbnRvIiwib3V0IiwiZGVzdHJveSIsIl9jbG9uZUludG8iLCJ0byIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiY2xvbmUiLCJobWFjIiwibWVzc2FnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/sha2.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha2.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   SHA384: () => (/* binding */ SHA384),\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   SHA512_224: () => (/* binding */ SHA512_224),\n/* harmony export */   SHA512_256: () => (/* binding */ SHA512_256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */ \n\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */ // prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98,\n    0x71374491,\n    0xb5c0fbcf,\n    0xe9b5dba5,\n    0x3956c25b,\n    0x59f111f1,\n    0x923f82a4,\n    0xab1c5ed5,\n    0xd807aa98,\n    0x12835b01,\n    0x243185be,\n    0x550c7dc3,\n    0x72be5d74,\n    0x80deb1fe,\n    0x9bdc06a7,\n    0xc19bf174,\n    0xe49b69c1,\n    0xefbe4786,\n    0x0fc19dc6,\n    0x240ca1cc,\n    0x2de92c6f,\n    0x4a7484aa,\n    0x5cb0a9dc,\n    0x76f988da,\n    0x983e5152,\n    0xa831c66d,\n    0xb00327c8,\n    0xbf597fc7,\n    0xc6e00bf3,\n    0xd5a79147,\n    0x06ca6351,\n    0x14292967,\n    0x27b70a85,\n    0x2e1b2138,\n    0x4d2c6dfc,\n    0x53380d13,\n    0x650a7354,\n    0x766a0abb,\n    0x81c2c92e,\n    0x92722c85,\n    0xa2bfe8a1,\n    0xa81a664b,\n    0xc24b8b70,\n    0xc76c51a3,\n    0xd192e819,\n    0xd6990624,\n    0xf40e3585,\n    0x106aa070,\n    0x19a4c116,\n    0x1e376c08,\n    0x2748774c,\n    0x34b0bcb5,\n    0x391c0cb3,\n    0x4ed8aa4a,\n    0x5b9cca4f,\n    0x682e6ff3,\n    0x748f82ee,\n    0x78a5636f,\n    0x84c87814,\n    0x8cc70208,\n    0x90befffa,\n    0xa4506ceb,\n    0xbef9a3f7,\n    0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 32){\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [\n            A,\n            B,\n            C,\n            D,\n            E,\n            F,\n            G,\n            H\n        ];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);\n        for(let i = 16; i < 64; i++){\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ W15 >>> 3;\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ W2 >>> 10;\n            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for(let i = 0; i < 64; i++){\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = D + T1 | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = T1 + T2 | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = A + this.A | 0;\n        B = B + this.B | 0;\n        C = C + this.C | 0;\n        D = D + this.D | 0;\n        E = E + this.E | 0;\n        F = F + this.F | 0;\n        G = G + this.G | 0;\n        H = H + this.H | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\nclass SHA224 extends SHA256 {\n    constructor(){\n        super(28);\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (()=>_u64_js__WEBPACK_IMPORTED_MODULE_2__.split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((n)=>BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 64){\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [\n            Ah,\n            Al,\n            Bh,\n            Bl,\n            Ch,\n            Cl,\n            Dh,\n            Dl,\n            Eh,\n            El,\n            Fh,\n            Fl,\n            Gh,\n            Gl,\n            Hh,\n            Hl\n        ];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for(let i = 0; i < 16; i++, offset += 4){\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32(offset += 4);\n        }\n        for(let i = 16; i < 80; i++){\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for(let i = 0; i < 80; i++){\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = Eh & Fh ^ ~Eh & Gh;\n            const CHIl = El & Fl ^ ~El & Gl;\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 39);\n            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor(){\n        super(48);\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8,\n    0x19544da2,\n    0x73e19966,\n    0x89dcd4d6,\n    0x1dfab7ae,\n    0x32ff9c82,\n    0x679dd514,\n    0x582f9fcf,\n    0x0f6d2b69,\n    0x7bd44da8,\n    0x77e36f73,\n    0x04c48942,\n    0x3f9d85a8,\n    0x6a1d36c8,\n    0x1112e6ad,\n    0x91d692a1\n]);\n/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194,\n    0xfc2bf72c,\n    0x9f555fa3,\n    0xc84c64c2,\n    0x2393b86b,\n    0x6f53b151,\n    0x96387719,\n    0x5940eabd,\n    0x96283ee2,\n    0xa88effe3,\n    0xbe5e1e25,\n    0x53863992,\n    0x2b0199fc,\n    0x2c85b8aa,\n    0x0eb72ddc,\n    0x81c52ca2\n]);\nclass SHA512_224 extends SHA512 {\n    constructor(){\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor(){\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */ const sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA256());\n/** SHA2-224 hash function from RFC 4634 */ const sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA224());\n/** SHA2-512 hash function from RFC 4634. */ const sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512());\n/** SHA2-384 hash function from RFC 4634. */ const sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ const sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */ const sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDdUY7QUFDdkQ7QUFDc0I7QUFDdkQ7OztDQUdDLEdBQ0Qsa0JBQWtCO0FBQ2xCLE1BQU1XLFdBQVcsYUFBYSxHQUFHQyxZQUFZQyxJQUFJLENBQUM7SUFDOUM7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQ3BGO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFDcEY7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUNwRjtJQUFZO0lBQVk7SUFBWTtJQUFZO0lBQVk7SUFBWTtJQUFZO0NBQ3ZGO0FBQ0QsNkRBQTZELEdBQzdELE1BQU1DLFdBQVcsYUFBYSxHQUFHLElBQUlGLFlBQVk7QUFDMUMsTUFBTUcsZUFBZWQsMENBQU1BO0lBQzlCZSxZQUFZQyxZQUFZLEVBQUUsQ0FBRTtRQUN4QixLQUFLLENBQUMsSUFBSUEsV0FBVyxHQUFHO1FBQ3hCLG1FQUFtRTtRQUNuRSx1REFBdUQ7UUFDdkQsSUFBSSxDQUFDQyxDQUFDLEdBQUdkLDZDQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3hCLElBQUksQ0FBQ2UsQ0FBQyxHQUFHZiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNnQixDQUFDLEdBQUdoQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4QixJQUFJLENBQUNpQixDQUFDLEdBQUdqQiw2Q0FBUyxDQUFDLEVBQUUsR0FBRztRQUN4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QUFHO1FBQ3ZCLElBQUksQ0FBQzdDLEVBQUUsR0FBRzZDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDNUMsRUFBRSxHQUFHNEMsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUMzQyxFQUFFLEdBQUcyQyxPQUFPLENBQUMsR0FBRyxHQUFHO1FBQ3hCLElBQUksQ0FBQzFDLEVBQUUsR0FBRzBDLE9BQU8sQ0FBQyxHQUFHLEdBQUc7UUFDeEIsSUFBSSxDQUFDekMsRUFBRSxHQUFHeUMsT0FBTyxDQUFDLEdBQUcsR0FBRztRQUN4QixJQUFJLENBQUN4QyxFQUFFLEdBQUd3QyxPQUFPLENBQUMsR0FBRyxHQUFHO0lBQzVCO0FBQ0o7QUFDQTs7Ozs7O0NBTUMsR0FDTSxNQUFNRyxTQUFTLGFBQWEsR0FBR3hHLHVEQUFZQSxDQUFDLElBQU0sSUFBSU0sVUFBVTtBQUN2RSx5Q0FBeUMsR0FDbEMsTUFBTW1HLFNBQVMsYUFBYSxHQUFHekcsdURBQVlBLENBQUMsSUFBTSxJQUFJbUMsVUFBVTtBQUN2RSwwQ0FBMEMsR0FDbkMsTUFBTXVFLFNBQVMsYUFBYSxHQUFHMUcsdURBQVlBLENBQUMsSUFBTSxJQUFJNkMsVUFBVTtBQUN2RSwwQ0FBMEMsR0FDbkMsTUFBTThELFNBQVMsYUFBYSxHQUFHM0csdURBQVlBLENBQUMsSUFBTSxJQUFJbUcsVUFBVTtBQUN2RTs7O0NBR0MsR0FDTSxNQUFNUyxhQUFhLGFBQWEsR0FBRzVHLHVEQUFZQSxDQUFDLElBQU0sSUFBSXVHLGNBQWM7QUFDL0U7OztDQUdDLEdBQ00sTUFBTU0sYUFBYSxhQUFhLEdBQUc3Ryx1REFBWUEsQ0FBQyxJQUFNLElBQUlzRyxjQUFjLENBQy9FLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbW11bmUtcGFnZS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyLmpzPzdjNjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTSEEyIGhhc2ggZnVuY3Rpb24uIEEuay5hLiBzaGEyNTYsIHNoYTM4NCwgc2hhNTEyLCBzaGE1MTJfMjI0LCBzaGE1MTJfMjU2LlxuICogU0hBMjU2IGlzIHRoZSBmYXN0ZXN0IGhhc2ggaW1wbGVtZW50YWJsZSBpbiBKUywgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKiBDaGVjayBvdXQgW1JGQyA0NjM0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2MzQpIGFuZFxuICogW0ZJUFMgMTgwLTRdKGh0dHBzOi8vbnZscHVicy5uaXN0Lmdvdi9uaXN0cHVicy9GSVBTL05JU1QuRklQUy4xODAtNC5wZGYpLlxuICogQG1vZHVsZVxuICovXG5pbXBvcnQgeyBDaGksIEhhc2hNRCwgTWFqLCBTSEEyMjRfSVYsIFNIQTI1Nl9JViwgU0hBMzg0X0lWLCBTSEE1MTJfSVYgfSBmcm9tIFwiLi9fbWQuanNcIjtcbmltcG9ydCAqIGFzIHU2NCBmcm9tIFwiLi9fdTY0LmpzXCI7XG5pbXBvcnQgeyBjbGVhbiwgY3JlYXRlSGFzaGVyLCByb3RyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8qKlxuICogUm91bmQgY29uc3RhbnRzOlxuICogRmlyc3QgMzIgYml0cyBvZiBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vKiogUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlci4gXCJXXCIgY29tZXMgc3RyYWlnaHQgZnJvbSBzcGVjLiAqL1xuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmV4cG9ydCBjbGFzcyBTSEEyNTYgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbiA9IDMyKSB7XG4gICAgICAgIHN1cGVyKDY0LCBvdXRwdXRMZW4sIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IFNIQTI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IFNIQTI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IFNIQTI1Nl9JVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgY2xlYW4oU0hBMjU2X1cpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgICAgIHRoaXMuQSA9IFNIQTIyNF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTIyNF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTIyNF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IFNIQTIyNF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IFNIQTIyNF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IFNIQTIyNF9JVls3XSB8IDA7XG4gICAgfVxufVxuLy8gU0hBMi01MTIgaXMgc2xvd2VyIHRoYW4gc2hhMjU2IGluIGpzIGJlY2F1c2UgdTY0IG9wZXJhdGlvbnMgYXJlIHNsb3cuXG4vLyBSb3VuZCBjb250YW50c1xuLy8gRmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBLNTEyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB1NjQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpKSgpO1xuY29uc3QgU0hBNTEyX0toID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzBdKSgpO1xuY29uc3QgU0hBNTEyX0tsID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBLNTEyWzFdKSgpO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlcnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmV4cG9ydCBjbGFzcyBTSEE1MTIgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKG91dHB1dExlbiA9IDY0KSB7XG4gICAgICAgIHN1cGVyKDEyOCwgb3V0cHV0TGVuLCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IFNIQTUxMl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBTSEE1MTJfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gU0hBNTEyX0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFNIQTUxMl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBTSEE1MTJfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gU0hBNTEyX0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFNIQTUxMl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBTSEE1MTJfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gU0hBNTEyX0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFNIQTUxMl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBTSEE1MTJfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFNIQTUxMl9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gU0hBNTEyX0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBTSEE1MTJfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFNIQTUxMl9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gU0hBNTEyX0lWWzE1XSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSB1NjQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSB1NjQucm90clNIKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJIKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gdTY0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCTChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gdTY0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSB1NjQuYWRkNEgoU1VNbCwgczBoLCBzMWgsIFNIQTUxMl9XX0hbaSAtIDddLCBTSEE1MTJfV19IW2kgLSAxNl0pO1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IFNVTWggfCAwO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IFNVTWwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDgwIHJvdW5kc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFMxIDo9IChlIHJpZ2h0cm90YXRlIDE0KSB4b3IgKGUgcmlnaHRyb3RhdGUgMTgpIHhvciAoZSByaWdodHJvdGF0ZSA0MSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWggPSB1NjQucm90clNIKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTSChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkgoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTFsID0gdTY0LnJvdHJTTChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0woRWgsIEVsLCAxOCkgXiB1NjQucm90ckJMKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgLy9jb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3QgQ0hJaCA9IChFaCAmIEZoKSBeICh+RWggJiBHaCk7XG4gICAgICAgICAgICBjb25zdCBDSElsID0gKEVsICYgRmwpIF4gKH5FbCAmIEdsKTtcbiAgICAgICAgICAgIC8vIFQxID0gSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTUxMl9LW2ldICsgU0hBNTEyX1dbaV1cbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgVDFsbCA9IHU2NC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IHU2NC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IHU2NC5yb3RyU0goQWgsIEFsLCAyOCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSB1NjQucm90clNMKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZChEaCB8IDAsIERsIHwgMCwgVDFoIHwgMCwgVDFsIHwgMCkpO1xuICAgICAgICAgICAgRGggPSBDaCB8IDA7XG4gICAgICAgICAgICBEbCA9IENsIHwgMDtcbiAgICAgICAgICAgIENoID0gQmggfCAwO1xuICAgICAgICAgICAgQ2wgPSBCbCB8IDA7XG4gICAgICAgICAgICBCaCA9IEFoIHwgMDtcbiAgICAgICAgICAgIEJsID0gQWwgfCAwO1xuICAgICAgICAgICAgY29uc3QgQWxsID0gdTY0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IHU2NC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSB1NjQuYWRkKHRoaXMuQWggfCAwLCB0aGlzLkFsIHwgMCwgQWggfCAwLCBBbCB8IDApKTtcbiAgICAgICAgKHsgaDogQmgsIGw6IEJsIH0gPSB1NjQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSB1NjQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSB1NjQuYWRkKHRoaXMuRGggfCAwLCB0aGlzLkRsIHwgMCwgRGggfCAwLCBEbCB8IDApKTtcbiAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSB1NjQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSB1NjQuYWRkKHRoaXMuR2ggfCAwLCB0aGlzLkdsIHwgMCwgR2ggfCAwLCBHbCB8IDApKTtcbiAgICAgICAgKHsgaDogSGgsIGw6IEhsIH0gPSB1NjQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihTSEE1MTJfV19ILCBTSEE1MTJfV19MKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNDgpO1xuICAgICAgICB0aGlzLkFoID0gU0hBMzg0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFNIQTM4NF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBTSEEzODRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gU0hBMzg0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFNIQTM4NF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBTSEEzODRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gU0hBMzg0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFNIQTM4NF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBTSEEzODRfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gU0hBMzg0X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFNIQTM4NF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gU0hBMzg0X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBTSEEzODRfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFNIQTM4NF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gU0hBMzg0X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBTSEEzODRfSVZbMTVdIHwgMDtcbiAgICB9XG59XG4vKipcbiAqIFRydW5jYXRlZCBTSEE1MTIvMjU2IGFuZCBTSEE1MTIvMjI0LlxuICogU0hBNTEyX0lWIGlzIFhPUmVkIHdpdGggMHhhNWE1YTVhNWE1YTVhNWE1LCB0aGVuIHVzZWQgYXMgXCJpbnRlcm1lZGlhcnlcIiBJViBvZiBTSEE1MTIvdC5cbiAqIFRoZW4gdCBoYXNoZXMgc3RyaW5nIHRvIHByb2R1Y2UgcmVzdWx0IElWLlxuICogU2VlIGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgLlxuICovXG4vKiogU0hBNTEyLzIyNCBJViAqL1xuY29uc3QgVDIyNF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDhjM2QzN2M4LCAweDE5NTQ0ZGEyLCAweDczZTE5OTY2LCAweDg5ZGNkNGQ2LCAweDFkZmFiN2FlLCAweDMyZmY5YzgyLCAweDY3OWRkNTE0LCAweDU4MmY5ZmNmLFxuICAgIDB4MGY2ZDJiNjksIDB4N2JkNDRkYTgsIDB4NzdlMzZmNzMsIDB4MDRjNDg5NDIsIDB4M2Y5ZDg1YTgsIDB4NmExZDM2YzgsIDB4MTExMmU2YWQsIDB4OTFkNjkyYTEsXG5dKTtcbi8qKiBTSEE1MTIvMjU2IElWICovXG5jb25zdCBUMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4MjIzMTIxOTQsIDB4ZmMyYmY3MmMsIDB4OWY1NTVmYTMsIDB4Yzg0YzY0YzIsIDB4MjM5M2I4NmIsIDB4NmY1M2IxNTEsIDB4OTYzODc3MTksIDB4NTk0MGVhYmQsXG4gICAgMHg5NjI4M2VlMiwgMHhhODhlZmZlMywgMHhiZTVlMWUyNSwgMHg1Mzg2Mzk5MiwgMHgyYjAxOTlmYywgMHgyYzg1YjhhYSwgMHgwZWI3MmRkYywgMHg4MWM1MmNhMixcbl0pO1xuZXhwb3J0IGNsYXNzIFNIQTUxMl8yMjQgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgICAgIHRoaXMuQWggPSBUMjI0X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFQyMjRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gVDIyNF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBUMjI0X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFQyMjRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gVDIyNF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBUMjI0X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFQyMjRfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gVDIyNF9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBUMjI0X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFQyMjRfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFQyMjRfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFQyMjRfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFQyMjRfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFQyMjRfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFQyMjRfSVZbMTVdIHwgMDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDMyKTtcbiAgICAgICAgdGhpcy5BaCA9IFQyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDI1Nl9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjU2X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyNTZfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDI1Nl9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDI1Nl9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDI1Nl9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDI1Nl9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDI1Nl9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDI1Nl9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LlxuICpcbiAqIEl0IGlzIHRoZSBmYXN0ZXN0IEpTIGhhc2gsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICogVG8gYnJlYWsgc2hhMjU2IHVzaW5nIGJpcnRoZGF5IGF0dGFjaywgYXR0YWNrZXJzIG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcy5cbiAqIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEEyNTYoKSk7XG4vKiogU0hBMi0yMjQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0ICovXG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLyoqIFNIQTItNTEyIGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEE1MTIoKSk7XG4vKiogU0hBMi0zODQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0IGNvbnN0IHNoYTM4NCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbi8qKlxuICogU0hBMi01MTIvMjU2IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTJfMjU2ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbi8qKlxuICogU0hBMi01MTIvMjI0IFwidHJ1bmNhdGVkXCIgaGFzaCBmdW5jdGlvbiwgd2l0aCBpbXByb3ZlZCByZXNpc3RhbmNlIHRvIGxlbmd0aCBleHRlbnNpb24gYXR0YWNrcy5cbiAqIFNlZSB0aGUgcGFwZXIgb24gW3RydW5jYXRlZCBTSEE1MTJdKGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTAvNTQ4LnBkZikuXG4gKi9cbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIl0sIm5hbWVzIjpbIkNoaSIsIkhhc2hNRCIsIk1haiIsIlNIQTIyNF9JViIsIlNIQTI1Nl9JViIsIlNIQTM4NF9JViIsIlNIQTUxMl9JViIsInU2NCIsImNsZWFuIiwiY3JlYXRlSGFzaGVyIiwicm90ciIsIlNIQTI1Nl9LIiwiVWludDMyQXJyYXkiLCJmcm9tIiwiU0hBMjU2X1ciLCJTSEEyNTYiLCJjb25zdHJ1Y3RvciIsIm91dHB1dExlbiIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJIIiwiZ2V0Iiwic2V0IiwicHJvY2VzcyIsInZpZXciLCJvZmZzZXQiLCJpIiwiZ2V0VWludDMyIiwiVzE1IiwiVzIiLCJzMCIsInMxIiwic2lnbWExIiwiVDEiLCJzaWdtYTAiLCJUMiIsInJvdW5kQ2xlYW4iLCJkZXN0cm95IiwiYnVmZmVyIiwiU0hBMjI0IiwiSzUxMiIsInNwbGl0IiwibWFwIiwibiIsIkJpZ0ludCIsIlNIQTUxMl9LaCIsIlNIQTUxMl9LbCIsIlNIQTUxMl9XX0giLCJTSEE1MTJfV19MIiwiU0hBNTEyIiwiQWgiLCJBbCIsIkJoIiwiQmwiLCJDaCIsIkNsIiwiRGgiLCJEbCIsIkVoIiwiRWwiLCJGaCIsIkZsIiwiR2giLCJHbCIsIkhoIiwiSGwiLCJXMTVoIiwiVzE1bCIsInMwaCIsInJvdHJTSCIsInNoclNIIiwiczBsIiwicm90clNMIiwic2hyU0wiLCJXMmgiLCJXMmwiLCJzMWgiLCJyb3RyQkgiLCJzMWwiLCJyb3RyQkwiLCJTVU1sIiwiYWRkNEwiLCJTVU1oIiwiYWRkNEgiLCJzaWdtYTFoIiwic2lnbWExbCIsIkNISWgiLCJDSElsIiwiVDFsbCIsImFkZDVMIiwiVDFoIiwiYWRkNUgiLCJUMWwiLCJzaWdtYTBoIiwic2lnbWEwbCIsIk1BSmgiLCJNQUpsIiwiaCIsImwiLCJhZGQiLCJBbGwiLCJhZGQzTCIsImFkZDNIIiwiU0hBMzg0IiwiVDIyNF9JViIsIlQyNTZfSVYiLCJTSEE1MTJfMjI0IiwiU0hBNTEyXzI1NiIsInNoYTI1NiIsInNoYTIyNCIsInNoYTUxMiIsInNoYTM4NCIsInNoYTUxMl8yNTYiLCJzaGE1MTJfMjI0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   createOptHasher: () => (/* binding */ createOptHasher),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   createXOFer: () => (/* binding */ createXOFer),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   kdfInputToBytes: () => (/* binding */ kdfInputToBytes),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   swap32IfBE: () => (/* binding */ swap32IfBE),\n/* harmony export */   swap8IfBE: () => (/* binding */ swap8IfBE),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/./node_modules/@noble/hashes/esm/cryptoNode.js\");\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n}\n/** Asserts something is positive integer. */ function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"positive integer expected, got \" + n);\n}\n/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {\n    if (!isBytes(b)) throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n}\n/** Asserts something is hash */ function ahash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\") throw new Error(\"Hash should be wrapped by utils.createHasher\");\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {\n    if (instance.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance.finished) throw new Error(\"Hash#digest() has already been called\");\n}\n/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {\n    for(let i = 0; i < arrays.length; i++){\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {\n    return word << 32 - shift | word >>> shift;\n}\n/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {\n    return word << shift | word >>> 32 - shift >>> 0;\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ const isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([\n        0x11223344\n    ]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */ function byteSwap(word) {\n    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\n}\n/** Conditionally byte swap if on a big-endian platform */ const swap8IfBE = isLE ? (n)=>n : (n)=>byteSwap(n);\n/** @deprecated */ const byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */ function byteSwap32(arr) {\n    for(let i = 0; i < arr.length; i++){\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nconst swap32IfBE = isLE ? (u)=>u : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore\n    typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\")();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({\n    length: 256\n}, (_, i)=>i.toString(16).padStart(2, \"0\"));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */ function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin) return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = \"\";\n    for(let i = 0; i < bytes.length; i++){\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n    _0: 48,\n    _9: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102\n};\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */ function hexToBytes(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2) throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array = new Uint8Array(al);\n    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */ const nextTick = async ()=>{};\n/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for(let i = 0; i < iters; i++){\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick) continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */ function utf8ToBytes(str) {\n    if (typeof str !== \"string\") throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ function bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */ function toBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */ function kdfInputToBytes(data) {\n    if (typeof data === \"string\") data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {\n    let sum = 0;\n    for(let i = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for(let i = 0, pad = 0; i < arrays.length; i++){\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && ({}).toString.call(opts) !== \"[object Object]\") throw new Error(\"options should be object or undefined\");\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */ class Hash {\n}\n/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {\n    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = ()=>hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts)=>hashCons(opts);\n    return hashC;\n}\nconst wrapConstructor = createHasher;\nconst wrapConstructorWithOpts = createOptHasher;\nconst wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === \"function\") {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes === \"function\") {\n        return Uint8Array.from(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUNwRSxvRkFBb0Y7QUFDcEYsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSw4REFBOEQ7QUFDOUQsK0RBQStEO0FBQy9ELDJFQUEyRTtBQUM3QjtBQUM5QyxtRkFBbUYsR0FDNUUsU0FBU0MsUUFBUUMsQ0FBQztJQUNyQixPQUFPQSxhQUFhQyxjQUFlQyxZQUFZQyxNQUFNLENBQUNILE1BQU1BLEVBQUVJLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLO0FBQ3ZGO0FBQ0EsMkNBQTJDLEdBQ3BDLFNBQVNDLFFBQVFDLENBQUM7SUFDckIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNGLE1BQU1BLElBQUksR0FDaEMsTUFBTSxJQUFJRyxNQUFNLG9DQUFvQ0g7QUFDNUQ7QUFDQSxxQ0FBcUMsR0FDOUIsU0FBU0ksT0FBT0MsQ0FBQyxFQUFFLEdBQUdDLE9BQU87SUFDaEMsSUFBSSxDQUFDZCxRQUFRYSxJQUNULE1BQU0sSUFBSUYsTUFBTTtJQUNwQixJQUFJRyxRQUFRQyxNQUFNLEdBQUcsS0FBSyxDQUFDRCxRQUFRRSxRQUFRLENBQUNILEVBQUVFLE1BQU0sR0FDaEQsTUFBTSxJQUFJSixNQUFNLG1DQUFtQ0csVUFBVSxrQkFBa0JELEVBQUVFLE1BQU07QUFDL0Y7QUFDQSw4QkFBOEIsR0FDdkIsU0FBU0UsTUFBTUMsQ0FBQztJQUNuQixJQUFJLE9BQU9BLE1BQU0sY0FBYyxPQUFPQSxFQUFFQyxNQUFNLEtBQUssWUFDL0MsTUFBTSxJQUFJUixNQUFNO0lBQ3BCSixRQUFRVyxFQUFFRSxTQUFTO0lBQ25CYixRQUFRVyxFQUFFRyxRQUFRO0FBQ3RCO0FBQ0EsOERBQThELEdBQ3ZELFNBQVNDLFFBQVFDLFFBQVEsRUFBRUMsZ0JBQWdCLElBQUk7SUFD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ckksd0RBQU1BLElBQUksT0FBT0Esd0RBQU1BLENBQUNzSSxlQUFlLEtBQUssWUFBWTtRQUN4RCxPQUFPdEksd0RBQU1BLENBQUNzSSxlQUFlLENBQUMsSUFBSW5JLFdBQVdrSTtJQUNqRDtJQUNBLCtCQUErQjtJQUMvQixJQUFJckksd0RBQU1BLElBQUksT0FBT0Esd0RBQU1BLENBQUNvSSxXQUFXLEtBQUssWUFBWTtRQUNwRCxPQUFPakksV0FBV3VELElBQUksQ0FBQzFELHdEQUFNQSxDQUFDb0ksV0FBVyxDQUFDQztJQUM5QztJQUNBLE1BQU0sSUFBSXpILE1BQU07QUFDcEIsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb21tdW5lLXBhZ2UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/ZWY3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3IgaGV4LCBieXRlcywgQ1NQUk5HLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG4vKiogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiBCZSBjYXJlZnVsOiBub2RlanMgQnVmZmVyIHdpbGwgcmV0dXJuIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5leHBvcnQgZnVuY3Rpb24gYW51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgJyArIG4pO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuICovXG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICcgKyBsZW5ndGhzICsgJywgZ290IGxlbmd0aD0nICsgYi5sZW5ndGgpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIGhhc2ggKi9cbmV4cG9ydCBmdW5jdGlvbiBhaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLmNyZWF0ZUhhc2hlcicpO1xuICAgIGFudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIGFudW1iZXIoaC5ibG9ja0xlbik7XG59XG4vKiogQXNzZXJ0cyBhIGhhc2ggaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZCAvIGZpbmlzaGVkICovXG5leHBvcnQgZnVuY3Rpb24gYWV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuLyoqIEFzc2VydHMgb3V0cHV0IGlzIHByb3Blcmx5LXNpemVkIGJ5dGUgYXJyYXkgKi9cbmV4cG9ydCBmdW5jdGlvbiBhb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBhYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAnICsgbWluKTtcbiAgICB9XG59XG4vKiogQ2FzdCB1OCAvIHUxNiAvIHUzMiB0byB1OC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1MzIoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbn1cbi8qKiBaZXJvaXplIGEgYnl0ZSBhcnJheS4gV2FybmluZzogSlMgcHJvdmlkZXMgbm8gZ3VhcmFudGVlcy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbiguLi5hcnJheXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheXNbaV0uZmlsbCgwKTtcbiAgICB9XG59XG4vKiogQ3JlYXRlIERhdGFWaWV3IG9mIGFuIGFycmF5IGZvciBlYXN5IGJ5dGUtbGV2ZWwgbWFuaXB1bGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdHIod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG59XG4vKiogVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJvdGwod29yZCwgc2hpZnQpIHtcbiAgICByZXR1cm4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbn1cbi8qKiBJcyBjdXJyZW50IHBsYXRmb3JtIGxpdHRsZS1lbmRpYW4/IE1vc3QgYXJlLiBCaWctRW5kaWFuIHBsYXRmb3JtOiBJQk0gKi9cbmV4cG9ydCBjb25zdCBpc0xFID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0KSgpO1xuLyoqIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzIgKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0IGNvbnN0IHN3YXA4SWZCRSA9IGlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBzd2FwOElmQkU7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cbmV4cG9ydCBjb25zdCBzd2FwMzJJZkJFID0gaXNMRVxuICAgID8gKHUpID0+IHVcbiAgICA6IGJ5dGVTd2FwMzI7XG4vLyBCdWlsdC1pbiBoZXggY29udmVyc2lvbiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX3VpbnQ4YXJyYXlfZnJvbWhleFxuY29uc3QgaGFzSGV4QnVpbHRpbiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gXG4vLyBAdHMtaWdub3JlXG50eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgVWludDhBcnJheS5mcm9tSGV4ID09PSAnZnVuY3Rpb24nKSgpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIENvbnZlcnQgYnl0ZSBhcnJheSB0byBoZXggc3RyaW5nLiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaGFzSGV4QnVpbHRpbilcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnRvSGV4KCk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBBOiA2NSwgRjogNzAsIGE6IDk3LCBmOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2gpIHtcbiAgICBpZiAoY2ggPj0gYXNjaWlzLl8wICYmIGNoIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoIC0gYXNjaWlzLl8wOyAvLyAnMicgPT4gNTAtNDhcbiAgICBpZiAoY2ggPj0gYXNjaWlzLkEgJiYgY2ggPD0gYXNjaWlzLkYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuQSAtIDEwKTsgLy8gJ0InID0+IDY2LSg2NS0xMClcbiAgICBpZiAoY2ggPj0gYXNjaWlzLmEgJiYgY2ggPD0gYXNjaWlzLmYpXG4gICAgICAgIHJldHVybiBjaCAtIChhc2NpaXMuYSAtIDEwKTsgLy8gJ2InID0+IDk4LSg5Ny0xMClcbiAgICByZXR1cm47XG59XG4vKipcbiAqIENvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5LiBVc2VzIGJ1aWx0LWluIGZ1bmN0aW9uLCB3aGVuIGF2YWlsYWJsZS5cbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vKiogUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZy4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgbmV4dFRpY2soKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBieXRlcyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RyaW5nIGV4cGVjdGVkJyk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogSGVscGVyIGZvciBLREZzOiBjb25zdW1lcyB1aW50OGFycmF5IG9yIHN0cmluZy5cbiAqIFdoZW4gc3RyaW5nIGlzIHBhc3NlZCwgZG9lcyB1dGY4IGRlY29kaW5nLCB1c2luZyBUZXh0RGVjb2Rlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtkZklucHV0VG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGFieXRlcyhkYXRhKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHt9LnRvU3RyaW5nLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuLyoqIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlICovXG5leHBvcnQgY2xhc3MgSGFzaCB7XG59XG4vKiogV3JhcHMgaGFzaCBmdW5jdGlvbiwgY3JlYXRpbmcgYW4gaW50ZXJmYWNlIG9uIHRvcCBvZiBpdCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhhc2hlcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3B0SGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVhPRmVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGNvbnN0IHdyYXBDb25zdHJ1Y3RvciA9IGNyZWF0ZUhhc2hlcjtcbmV4cG9ydCBjb25zdCB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZU9wdEhhc2hlcjtcbmV4cG9ydCBjb25zdCB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGNyZWF0ZVhPRmVyO1xuLyoqIENyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBQUk5HLiBVc2VzIGludGVybmFsIE9TLWxldmVsIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYC4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0byAmJiB0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJjcnlwdG8iLCJpc0J5dGVzIiwiYSIsIlVpbnQ4QXJyYXkiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImNvbnN0cnVjdG9yIiwibmFtZSIsImFudW1iZXIiLCJuIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiYWJ5dGVzIiwiYiIsImxlbmd0aHMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsImFoYXNoIiwiaCIsImNyZWF0ZSIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiYWV4aXN0cyIsImluc3RhbmNlIiwiY2hlY2tGaW5pc2hlZCIsImRlc3Ryb3llZCIsImZpbmlzaGVkIiwiYW91dHB1dCIsIm91dCIsIm1pbiIsInU4IiwiYXJyIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJ1MzIiLCJVaW50MzJBcnJheSIsIk1hdGgiLCJmbG9vciIsImNsZWFuIiwiYXJyYXlzIiwiaSIsImZpbGwiLCJjcmVhdGVWaWV3IiwiRGF0YVZpZXciLCJyb3RyIiwid29yZCIsInNoaWZ0Iiwicm90bCIsImlzTEUiLCJieXRlU3dhcCIsInN3YXA4SWZCRSIsImJ5dGVTd2FwSWZCRSIsImJ5dGVTd2FwMzIiLCJzd2FwMzJJZkJFIiwidSIsImhhc0hleEJ1aWx0aW4iLCJmcm9tIiwidG9IZXgiLCJmcm9tSGV4IiwiaGV4ZXMiLCJBcnJheSIsIl8iLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiYnl0ZXNUb0hleCIsImJ5dGVzIiwiaGV4IiwiYXNjaWlzIiwiXzAiLCJfOSIsIkEiLCJGIiwiZiIsImFzY2lpVG9CYXNlMTYiLCJjaCIsImhleFRvQnl0ZXMiLCJobCIsImFsIiwiYXJyYXkiLCJhaSIsImhpIiwibjEiLCJjaGFyQ29kZUF0IiwibjIiLCJ1bmRlZmluZWQiLCJjaGFyIiwibmV4dFRpY2siLCJhc3luY0xvb3AiLCJpdGVycyIsInRpY2siLCJjYiIsInRzIiwiRGF0ZSIsIm5vdyIsImRpZmYiLCJ1dGY4VG9CeXRlcyIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiYnl0ZXNUb1V0ZjgiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInRvQnl0ZXMiLCJkYXRhIiwia2RmSW5wdXRUb0J5dGVzIiwiY29uY2F0Qnl0ZXMiLCJzdW0iLCJyZXMiLCJwYWQiLCJzZXQiLCJjaGVja09wdHMiLCJkZWZhdWx0cyIsIm9wdHMiLCJjYWxsIiwibWVyZ2VkIiwiT2JqZWN0IiwiYXNzaWduIiwiSGFzaCIsImNyZWF0ZUhhc2hlciIsImhhc2hDb25zIiwiaGFzaEMiLCJtc2ciLCJ1cGRhdGUiLCJkaWdlc3QiLCJ0bXAiLCJjcmVhdGVPcHRIYXNoZXIiLCJjcmVhdGVYT0ZlciIsIndyYXBDb25zdHJ1Y3RvciIsIndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJyYW5kb21CeXRlcyIsImJ5dGVzTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@noble/hashes/esm/utils.js\n");

/***/ })

};
;